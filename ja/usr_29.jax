COMMENT: プログラマー支援機能(tags、プレビュー、検索)
STATUS: finished 6.3.054
TRANSLATOR: 清水俊彦(しみず) <mailto:t_smz@syd.odn.ne.jp>
TRANSLATOR: nakadaira <hopper2@nanameue.jp>

*usr_29.txt*	For Vim version 6.3.  Last change: 2004 Feb 12

		     VIM USER MANUAL - by Bram Moolenaar

			      プログラム内の移動


vimはコンピュータプログラマが作っています。ですからvimにプログラムを書くのを
補助する機能がたくさん入っているのは別に不思義なことではありません。識別子が
定義されている場所や使っている場所にジャンプする方法。別のウィンドウで宣言個
所を参照する方法。この章と次の章ではこういった機能の説明をしましょう。

|29.1|	タグの利用
|29.2|	プレビューウィンドウ
|29.3|	プログラム内の移動コマンド
|29.4|	グローバルな識別子の検索
|29.5|	ローカルな識別子の検索

     Next chapter: |usr_30.txt|  プログラムの編集
 Previous chapter: |usr_28.txt|  フォールド（折り畳み）
Table of contents: |usr_toc.txt|

==============================================================================
*29.1*	タグの利用

タグって何でしょうか？これは何らかの識別子が宣言されている場所のことです。例
えば、ＣやＣ＋＋のプログラムの関数宣言がそうです。定義されたタグリストはタグ
ファイルの中に格納されます。vimはこのファイルにあるタグの定義を見てジャンプ
すべき場所を調べるのに使います。
現在のディレクトリにある全Ｃソースのタグファイルを生成するには、このコマンド
を使います。 >

	ctags *.c

"ctsgs"というのはvimとは独立した別コマンドです。たいていのUnixシステムには既
に用意されています。もし入っていないのであれば、Exuberant ctags を次のサイト
で探してください。

	http://ctags.sf.net ~

次にvimが動いている時に、ある関数の定義個所に移動したければ、このようなコマ
ンドでそれができます。 >

	:tag startlist

このコマンドは"startlist"という関数を（別のファイルにあったとしても）探しま
す。またCTRL-] コマンドでは、カーソル下にある単語をタグとみなしてその定義場
所にジャンプします。複数のＣソースを調べてまわることを簡単にしてくれます。
例えば、"write_block"という関数にいるとします。その中で"write_line"という関
数を呼び出しています。でも"write_line"という関数はどこにあるのでしょう？そん
な時はカーソルを"write_line"の上に置いて、CTRL-] を押しましょう。その関数を
定義してある場所にジャンプすることでしょう。
"write_line"関数の中でさらに"write_char"を呼び出しています。その関数の詳細を
調べる必要があります。今度も"write_char"の上にカーソルを動かして、CTRL-]を押
しましょう。すると"write_char"の定義個所にジャンプするのです。

	+-------------------------------------+
	|void write_block(char **s; int cnt)  |
	|{				      |
	|   int i;			      |
	|   for (i = 0; i < cnt; ++i)	      |
	|      write_line(s[i]);	      |
	|}	    |			      |
	+-----------|-------------------------+
		    |
	     CTRL-] |
		    |	 +----------------------------+
		    +--> |void write_line(char *s)    |
			 |{			      |
			 |   while (*s != 0)	      |
			 |	write_char(*s++);     |
			 |}	  |		      |
			 +--------|-------------------+
				  |
			   CTRL-] |
				  |    +------------------------------------+
				  +--> |void write_char(char c)		    |
				       |{				    |
				       |    putchar((int)(unsigned char)c); |
				       |}				    |
				       +------------------------------------+

":tags"コマンドはそれまでに渡り歩いたタグを一覧で表示します。

	:tags
	  # TO タグ	   FROM 行    in file/text ~
	  1  1 write_line	   8  write_block.c ~
	  2  1 write_char	   7  write_line.c ~
	> ~

では今度は戻りましょう。CTRL-Tコマンドを押すと直前のタグに戻ります。上の例で
あれば、"write_line"関数の中の"write_char"を呼んでいる個所に戻ります。
このコマンドにはカウンタを付けていくつタグを戻るか指定できます。これでタグ先
にジャンプするのも戻るのもできるようになりました。ではもう一度タグ先にジャン
プしましょう。次のコマンドはタグリストの先頭にあるタグにジャンプします。 >

	:tag

コマンドの前にプレフィクスとして回数を与えていくつ先のタグにジャンプするか指
定できます。例えば、":3tag"のように使います。CTRL-T でも同じように前に回数指
定できます。
結局、関数呼び出しを追いかけるのに CTRL-] を使い、逆に戻るのには CTRL-T を使
うということです。自分がどこにいるのかを見るには":tags"が使えます。


ウィンドウ分割
--------------

":tag"コマンドはカレントウィンドウのファイルをジャンプ先の関数が書いてある
ファイルに置き換えます。しかし古いウィンドウばかりじゃなくて新しいウィンドウ
で見たいこともあると思いませんか？これにはまず":split"コマンドでウィンドウを
分割してから、続けて":tag"コマンドを使います。実はvimはこの両方をいっぺんに
やってくれる短縮コマンドを用意しています。 > >

	:stag tagname

カレントウィンドウを分割してカーソル下にある単語にタグジャンプするのならこの
コマンドです。 >

	CTRL-W ]

カウンタを指定した場合は、新しいウィンドウの行数がその値となります。


追加のタグファイル
------------------

ファイルが多くのディレクトリに分れている場合、ディレクトリ毎にタグファイルを
作ることができます。その場合、vimはそのディレクトリの中で定義されているタグ
にしかジャンプできません。
多数のタグファイルを探させるには、対象となるタグファイルが全て含まれるように
'tags'オプションを設定します。このようになります。 >

	:set tags=./tags,./../tags,./*/tags

これは現在のファイルと同じディレクトリにある"tags"を探し、１つ親ディレクトリ
でも"tags"を探し、さらに全サブディレクトリの"tags"を探します。
これはかなり多数の"tags"ファイルになりますが、これでも不十分かも知れません。
例えば、"~/proj/src/"にあるファイルを編集している時に"~/proj/sub/tags"ファイ
ルを探し出せません。このような場合のためにvimではあるディレクトリ下の全ディ
レクトリを検索するように試みます。次のようにします。 >

	:set tags=~/proj/**/tags


１つのタグファイル
------------------

vimがタグファイルをいろんな場所から探そうとする場合、ハードディスクをガリガ
リとアクセスするのが聞こえるかも知れません。そのため多少遅く感じるかもしれま
せん。こういった場合は少々時間をかけてでも大きめのタグファイル１本を作った方
が良いでしょう。夜中にやっても構いません。
これには上で述べたディレクトリツリーの全体を検索してくれる"Exuberant ctags"
プログラムが必要です。 >

	cd ~/proj
	ctags -R .

この"Exuberant ctags"がいいのは、いろんなファイルタイプを認識してくれる点で
す。つまりＣやＣ＋＋のプログラムだけではなく、Eiffelやvimスクリプトでさえ正
しく動くのです。このチューニング方法は"ctags"のドキュメントをご覧ください。
さて、上で大きなタグファイルを作っておけば、後はvimにそれを教えるだけです。 >

	:set tags=~/proj/tags


多重定義
--------

ある関数が何度も定義されている(いくつかのクラスでメソッド名が重複している場
合も)場合、":tag"コマンドでは最初に見つかった場所にジャンプします。編集中の
ファイルで見つかった時はそれが使われます。
この時、このコマンドで同じタグファイルの他の定義箇所にジャンプできます。 >

	:tnext

さらに別の定義を探すにはこれを繰り返します。同じものが多数ある場合はどれにす
るかを選ぶことができます。 >

	:tselect tagname

vimは次のような選択可能なリストを表示します。

	  # pri kind tag	       file ~
	  1 F	f    mch_init	       os_amiga.c ~
		       mch_init() ~
	  2 F	f    mch_init	       os_mac.c ~
		       mch_init() ~
	  3 F	f    mch_init	       os_msdos.c ~
		       mch_init(void) ~
	  4 F	f    mch_init	       os_riscos.c ~
		       mch_init() ~
	Enter nr of choice (<CR> to abort):  ~

この一覧からジャンプしたい(行頭の)番号を入力してジャンプすることができます。
他のカラムはその一致場所がどこにあるかについての情報が提示されます。

一致したタグ間を移動するには、このようなコマンド群を用います。

	:tfirst			最初のヒット個所に移動
	:[count]tprevious	[count]数分、前(previous)のヒット個所に移動
	:[count]tnext		[count]数分、後ろ(next)のヒット個所に移動
	:tlast			最後のヒット個所に移動

[count] を省略した時は１を指定したものと扱います。


タグ名の推測
------------

長いタグ名の入力を省くにはコマンド行の補完を利用するのがよいでしょう。最初の
数文字を入力してから<Tab>キーを押します。 >

	:tag write_<Tab>

すると、最初に見つかったタグ名を展開します。それが望みのものでない場合は、目
的のタグが見つかるまで<Tab>キーを押してください。
場合によっては関数名の一部しか知らない場合もあるでしょう。また、始めの数文字
は同じで後半は違っているようなタグが大量にある場合もそうでしょう。こういった
場合はパターンを使ってタグを指定することができます。
例えば、"block"という文字列をタグ名のどこかに含んでいるようなタグにジャンプ
したいとしましょう。最初にこう入力します。 >

	:tag /block

ここで、コマンド行の補完をします。<Tab>キーを押しましょう。vimは"block"とい
う文字列を含んでいるタグを探し、最初にヒットしたものを表示します。
タグ名の前にある"/"は、その指定が文字列ではなくパターン指定であることを示し
ます。ここでは検索パターンでの全ての機能が使えます。例えば、"write_"で始まる
タグを選びたければ、こうします。 >

	:tselect /^write_

最初の"^"はタグ名が"write_"で始まることを示します。この指定がないと、タグ名
の途中に"write_"を含む文字列もヒットしてしまいます。同じように"$"を行末に使
えば、タグ名の最後に合致するパターンを指定することもできます。


タグブラウザ
------------

CTRL-]を使うと、カーソル下の識別子の定義場所にジャンプできるのを利用すると、
識別子のリストを目次のように使えます。例を示しましょう。
最初に識別子のリストを作ります。(これにはExuberant ctagsが必要です) >

	ctags --c-types=f -f functions *.c

次にvimをファイル名指定なしで起動し、上で作ったファイル("functions")を縦分割
したウィンドウで開きます。 >

	vim
	:vsplit functions

このウィンドウには全関数のリストが入っています。それ以外にもいろいろあります
が、ここでは無視します。":setlocal ts=99"を実行して少しだけ掃除しましょう。
このウィンドウでこのようなマップを定義します。 >

	:nnoremap <buffer> <CR> 0ye<C-W>w:tag <C-R>"<CR>

カーソルを移動したい関数名の行まで動かし、そこで<Enter>を押します。vimは他の
ウィンドウにカーソルを動かし、選択した関数にジャンプします。


関連項目
--------

タグ名の大文字／小文字を無視するようにしたければ、'ignorecase'をonにします。

'tagbsearch'オプションはタグファイルがソートしてあるかどうかを示します。デ
フォルトではタグファイルをソートしているものとみなします。これはタグの検索を
極めて高速に行いますが、逆にソートしていないタグファイルの場合はうまく動きま
せん。

'taglength'オプションはタグに識別に使う最大文字数を指定するのに使います。

"SNiFF+"プログラムを使う場合は、vimは|sniff|に対するインタフェースを用意して
います。なお、"SNiFF+"は商用のアプリケーションです。

"cscope"はフリーのプログラムです。これは識別子の宣言個所を探すだけではなく、
それを使っている個所のリストも作成してくれます。|cscope|をご覧ください。

==============================================================================
*29.2*	プレビューウィンドウ

関数呼び出しがあるソースコードを書く時にはそのパラメタを正確に書くことが必要
です。その関数に渡せる値を知るには、その関数の定義を見るのが良いでしょう。タ
グはこういった場合にとても便利に使えます。その場合は別ウィンドウにその定義を
表示する方が便利でしょう。このような場合にはプレビューウィンドウを使います。
例えば、"write_char"関数の定義をプレビューウィンドウを開くにはこうします。 >

	:ptag write_char

vimはウィンドウを開き、"write_char"のタグにジャンプします。そして最初の場所
に戻ってきます。ですから、CTRL-Wコマンドを使うことなく、目的の入力を続けるこ
とができるのです。
関数名が編集中のテキストにあるのなら、次のコマンドでプレビューウィンドウにそ
の定義を表示することができます。 >

	CTRL-W }

カーソル下にある単語が定義されている場所のテキストを自動的に表示してくれる
スクリプトもあります。|CursorHold-example|をご覧ください。

プレビューウィンドウを閉じるにはこのコマンドを使います。 >

	:pclose

プレビューウィンドウで指定のファイルを編集するには":pedit"を使います。これは
例えばヘッダファイルを編集したい時に便利です。 >

	:pedit defs.h

最後に、":psearch"という検索コマンドがあります。これは現在編集しているファイ
ルとincludeしているファイルの中から指定の単語を探しヒットしたものをプレビュ
ーウィンドウに表示します。これは特にタグファイルを生成していないようなライブ
ラリ関数を使う時に便利です。このコマンドはこのように使います。 >

	:psearch popen

これはプレビューウィンドウに"stdio.h"ファイルのpopen()関数のプロトタイプを表
示します。

	FILE	*popen __P((const char *, const char *)); ~

プレビューウィンドウを開いた時の行数は'previewheight'オプションで指定するこ
とができます。

==============================================================================
*29.3*	プログラム内の移動コマンド

プログラムには構造があります。vimはそういった項目を認識します。一部のコマン
ドではそれを移動に使うことができます。
例えば、Ｃのプログラムでは次のような構成の個所がよくあります。

	#ifdef USE_POPEN ~
	    fd = popen("ls", "r") ~
	#else ~
	    fd = fopen("tmp", "w") ~
	#endif ~

ですが、とても長くなったり何重にも入れ子になったりする場合があります。この場
合は"#ifdef"にカーソルを動かして % コマンドを使います。vimは"#else"の部分に
ジャンプします。もう一度 % を押すと、"#endif"に移動します。さらにもう一度 %
を押すと最初の"#ifdef"に戻ります。
入れ子になっている場合は、vimは呼応する項目を探そうとします。これを使うと、
"#endif"を忘れていないかどうかを簡単にチェックできます。
"#if"～"#endif"の途中にカーソルがある場合は、その先頭に戻るコマンドがありま
す。 >

	[#

もし"#if"や"#ifdef"が見つからなければvimは警告音を出します。逆に次の"#else"
や"#endif"にジャンプするコマンドもあります。 >

	]#

この２つのコマンドを使うと"#if"～"#endif"のブロックをスキップするこができま
す。例をあげましょう。

	#if defined(HAS_INC_H) ~
	    a = a + inc(); ~
	# ifdef USE_THEME ~
	    a += 3; ~
	# endif ~
	    set_width(a); ~

カーソルが最後の行にある時、"[#"を押すと最初の行に移動します。途中にある入れ
子の"#ifdef"～"#endif"のブロックはスキップされたわけです。


コードブロック内の移動
----------------------

Ｃではコードブロックを{ }で囲みます。これが多少長くなる場合もあります。外側
のブロックの開始位置にジャンプするには"[["コマンドを使います。 逆に末尾を探
すには"]["を使います。これは"{"や"}"が行頭にあるものとして動きます。
"[{"コマンドは現在のブロックの先頭まで移動します。同じレベルにある"{"や"}"は
無視します。"]}"は末尾に移動します。
整理するとこのようになります。

			function(int a)
	   +->		{
	   |		    if (a)
	   |	   +->	    {
	[[ |	   |		for (;;)	       --+
	   |	   |	  +->	{			 |
	   |	[{ |	  |	    foo(32);		 |     --+
	   |	   |   [{ |	    if (bar(a))  --+	 | ]}	 |
	   +--	   |	  +--		break;	   | ]}  |	 |
		   |		}		 <-+	 |	 | ][
		   +--		foobar(a)		 |	 |
			    }			       <-+	 |
			}				       <-+

C++やJavaでプログラムを書く時には、一番外側の{ }はクラスを示すブロックです。
次のレベルの{ }はメソッド用です。クラスの中で"[m"を使うと、直前にあるメソッ
ドの開始位置を探します。逆に"]m"は次のメソッドの末尾を探します。

さらに、"[]"は１つ前の関数の末尾まで戻り、"]]"は次の関数の最初に進みます。
関数の末尾には１桁目が"}"となっているものとみなします。

				int func1(void)
				{
					return 1;
		  +---------->  }
		  |
	      []  |		int func2(void)
		  |	   +->	{
		  |    [[  |		if (flag)
	start	  +--	   +--			return flag;
		  |    ][  |		return 2;
		  |	   +->	}
	      ]]  |
		  |		int func3(void)
		  +---------->	{
					return 3;
				}

カッコ類の呼応、( )や{ }や[ ]間を移動するのであれば、"%"も使えるのを忘れない
ようにしましょう。このコマンドは間に多くの行があっても正しく動きます。


カッコ内の移動
--------------

"[("と"])"コマンドは"[{"と"]}"とほとんど同じです。違っているのは、{ }ではな
く、( )に対して働く点です。
>
				  [(
<		    <--------------------------------
			      <-------
		if (a == b && (c == d || (e > f)) && x > y) ~
				  -------------->
			  --------------------------------> >
				       ])

コメント内の移動
----------------

コメントの開始位置まで戻るには"[/"コマンドを使います。コメントの終了位置まで
進むには"]/"を使います。この機能は /*  ～ */ 形式のコメントでのみ使えます。

	  +->	  +-> /*
	  |    [/ |    * A comment about      --+
       [/ |	  +--  * wonderful life.	| ]/
	  |	       */		      <-+
	  |
	  +--	       foo = bar * 3;	      --+
						| ]/
		       /* a short comment */  <-+

==============================================================================
*29.4*	グローバルな識別子の検索

Ｃのプログラムを編集していて、ある変数が"int"で宣言していたか"unsigned"だっ
たか解らなくなりました。こういった時には"[I"コマンドを使います。カーソルが
"column"という単語の上にあったとしましょう。そこで、 >

	[I

と入力するとvimは該当行のリストを表示します。これは現在のファイルだけではな
く、全インクルードファイルも対象となります。(さらにその中でインクルードして
いるファイルも含みます）例えば、次のようになります。

	structs.h ~
	 1:   29     unsigned     column;    /* column number */ ~

これがタグやプレビューウィンドウを使うよりいいのはインクルードファイルも検索
できる点です。ほとんどの場合は正しい場所を探し出してくれます。タグファイルが
古かったり、そのインクルードファイル用のタグがない場合でもうまく動いてくれま
す。
ただし、"[I"コマンドを使う時には、いくつか守らなければならない点があります。
まず最初に'include'オプションでどのようにファイルがインクルードされるのかを
定義しなければなりません。デフォルト値はＣとＣ＋＋用の値となっています。他の
言語では変更する必要があるかもしれません。


インクルードファイルの場所
--------------------------

vimは'path'オプションの指定に従ってインクルードファイルを検索します。ディレ
クトリがない場合、見つけられないインクルードファイルがあるかもしれません。
このコマンドを使えばそういったパターンを見つけることができます。 >

	:checkpath

これは見つけられなかったインクルードファイルのリストを表示します。インクルー
ドファイルの中にあるインクルードも見つけてくれます。出力結果はこのようになり
ます。

	--- Included files not found in path --- ~
	<io.h> ~
	vim.h --> ~
	  <functions.h> ~
	  <clib/exec_protos.h> ~

現在のファイルがインクルードしている"io.h"は見つかりませんでした。"vim.h"は
見つかりましたので、":checkpath"はさらにその中でインクルードしているものも
チェックします。ですが、"vim.h"ががインクルードしている"functios.h"ファイル
も"clib/exec_protos.h"ファイルも見つかりませんでした。

	Note:
	vimはコンパイラではありません。"#ifdef"ステートメントについては考慮
	しません。つまり"#if NEVER"という記述があったとしても、"#include"ス
	テートメントを全て調べるわけです。

見つけられなかったファイルを修正するには'path'オプションにディレクトリを追加
します。これを見つけるにはMakefileを見るのが良いでしょう。"-I"というパターン
がある行、例えば"-I/usr/local/X11"といった行を探して、それを追加します。 >

	:set path+=/usr/local/X11

サブディレクトリが大量にある場合は、ワイルドカード"*"が使えます。このように
使います。 >

	:set path+=/usr/*/include

上の例は"/usr/local/include"や"/usr/X11/include"といった場所にあるファイルを
探すようになります。

インクルードファイルが入っているディレクトリツリー全体を使うようなプロジェク
トでは、"**"という指定が便利でしょう。この指定はそのディレクトリ以下の全ての
サブディレクトリを探してくれます。例えばこのように指定します。 >

	:set path+=/projects/invent/**/include

上の指定は次のようなディレクトリにあるファイルを探してくれます。

	/projects/invent/include ~
	/projects/invent/main/include ~
	/projects/invent/main/os/include ~
	など

これ以外にも可能性があります。'path'オプションの解説をチェックしてください。
実際にどのインクルードファイルを探し出したのかを見たければ、こうします。 >

	:checkpath!

これでインクルードファイルの(長大な)リストを得られます。リストを少しでも短か
くするため、既に展開結果を出力済のインクルードファイルが２回以上現われた場合
は"(Already listed)"とだけ表示します。


ヒット個所にジャンプする
------------------------

"[I"はテキストの１行だけをリストにします。最初の項目の詳細を見たければ、次の
コマンドでその場所にジャンプできます。 >

	[<Tab>
<
<Tab>というのはCTRL-Iのことですから、これは"[ CTRL-I"でも入力できます。

"[I"で生成するリストには各行の最初に番号がついています。最初の項目以外の他の
項目にジャンプしたければ、その番号をカウンタとして指定します。 >

	3[<Tab>

これはリストの３番目の項目にジャンプします。ジャンプする前の場所に戻る時には
CTRL-Oが使えますので、覚えておきましょう。


関連コマンド
------------

	[i		最初に一致したものだけをリスト化する
	]I		カーソル位置以降のみをリスト化する
	]i		カーソル下にある最初の項目だけをリスト化する


定義済の識別子の検索
--------------------

"[I"コマンドはあらゆる識別子を探します。"#define"で定義してあるマクロだけを
探すのであれば、これを使います。 >

	[D

繰り返しになりますが、これはインクルードファイルの中を検索します。"[D"がどの
ように項目を定義している行を対象とするのかは'define'オプションで指定します。
ＣやＣ＋＋以外の言語でも正しく動くように変更できます。
この"[D"の関連コマンドには次のようなものがあります。

	[d		最初に一致したものだけをリスト化
	]D		カーソル下の項目だけをリスト化
	]d		カーソル下にある最初の項目だけをリスト化

==============================================================================
*29.5*	ローカルな識別子の検索

"[I"コマンドはインクルードファイルの中を探します。編集中のファイルだけを対象
としてカーソル位置の単語を探し、最初に見つかった場所にジャンプするにはこのコ
マンドを使います。 >

	gD

（このコマンドは「定義に移動(=Goto Definition)」の略と覚えましょう）このコマ
ンドはローカルに定義(Ｃの用語なら"static")された変数や関数を見つける時にとて
も便利です。例を示しましょう。（カーソルは"counter"の上にあるとします)

	   +->   static int counter = 0;
	   |
	   |     int get_counter(void)
	gD |     {
	   |	     ++counter;
	   +--	     return counter;
		 }

さらに検索範囲を制限して、現在の関数だけを探すのであればこのコマンドを使いま
す。 >

	gd

これはカーソル位置の単語を探すときに、まず関数の先頭まで戻り、最初にその単語
が現れる個所を探します。実際には、まず１桁目に"{"がある行の上の空白行まで戻
ります。次にその単語を前方検索します。例を示します。(カーソルは"idx"の上にあ
るとします)

		int find_entry(char *name)
		{
	   +->	    int idx;
	   |
	gd |	    for (idx = 0; idx < table_len; ++idx)
	   |		if (strcmp(table[idx].name, name) == 0)
	   +--		    return idx;
		}

==============================================================================

Next chapter: |usr_30.txt|  プログラムを編集する

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
