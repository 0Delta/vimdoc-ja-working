COMMENT: 使いやすくするちょっとした工夫
STATUS: finished 6.3.054
TRANSLATOR: 清水俊彦(しみず) <mailto:t_smz@syd.odn.ne.jp>
TRANSLATOR: nakadaira <hopper2@nanameue.jp>

*usr_12.txt*	For Vim version 6.3.  Last change: 2004 May 01

		     VIM USER MANUAL - by Bram Moolenaar

			    ちょっとしたテクニック


いくつかのコマンドを組み合わせれば、ほとんど何でもvimにさせることができます。
この章では、多くの便利な組み合せについて説明します。ここでは、今までに紹介し
たコマンドの他にいくつか新しいコマンドも使います。

|12.1|	単語の置き換え
|12.2|	"Last, First"を"First Last"に変更
|12.3|	リストの並べ替え
|12.4|	行の順を逆にする
|12.5|	単語数のカウント
|12.6|	マニュアルを探す
|12.7|	空白文字をまとめる
|12.8|	単語を使っている場所を探す

     Next chapter: |usr_20.txt|  コマンドラインのコマンドを素早く入力する
 Previous chapter: |usr_11.txt|  クラッシュから立ち直る
Table of contents: |usr_toc.txt|

==============================================================================
*12.1*	単語の置き換え

置換コマンドを使うとある単語を全て他の単語に置き換ることができます。 >

	:%s/four/4/g

ここで"%"というのは全行という意味の範囲指定です。行末の"g"は１行内でヒットし
た全部を置き換えるという意味になります。
JP注: 行末の"g"を付けないと、行の最初にヒットした個所だけを置換します。
ですが、これだと"thirtyfour"のようなパターンも含まれ、思った結果になりません。
この場合ですと、"thirty4"になります。これを避けるには"\<"を使って単語の先頭
にヒットさせます。 >

	:%s/\<four/4/g

これでもまだ、"fourty"のような場合はうまくいきません。今度は"\>"を使って単語
の末尾にヒットさせましょう。 >

	:%s/\<four\>/4/g

プログラムを作っている場合なら、コード中ではなくコメントにある"four"だけを置
き換えたい場合もあるでしょう。これは指定するのが難しいですから、"c"フラグを
置換コマンドに与えて、置換する前に確認するようにします。 >


	:%s/\<four\>/4/gc


複数のファイルで置換する
------------------------

２つ以上のファイルで単語の置換をしたい場合を考えます。各ファイルを開いて、手
でコマンドを入力することもできます。でもレコーディング(記録)とプレイバック
(再現)を使うと、はるかに素早くできます。
".cpp"で終わるC++ファイルの入ったディレクトリがあるとします。その中で使って
いる"GetResp"という関数を"GetAnswer"に名前を変更したいとします。

	vim *.cpp		引数を全Ｃ＋＋ファイルを対象としてvimを起動
				します。起動時はその最初のファイルから始まり
				ます。
	qq			レジスタ"q"にレコーディングを始めます。
	:%s/\<GetResp\>/GetAnswer/g
				最初のファイルで置換コマンドを実行します。
	:wnext			このファイルを保存し次のファイルに移ります。
	q			レコーディングを中止します。
	@q			レジスタ"q"を実行します。これは置換コマンド
				と":wnext"を繰り返します。ここでエラーメッセ
				ージが表示されたりしないか確認します。
	999@q			(エラーがなければ)残りの全ファイルに対して、
				レジスタ"q"の内容をプレイバックします。

最後のファイルで実行した時には、":wnext"コマンドの対象となる次のファイルがな
いためにエラーメッセージが表示されます。ここで実行を中断し、全てが完了です。

	Note:
	一連のレコーディング内容をプレイバックした時にエラーが発生すると実行
	を中断します。ですから、レコーディング中はエラーメッセージが出ないよ
	うに注意してください。

一点気をつけてください。もし".cpp"の中に"GetResp"を使っていないファイルが一
つでもあれば、置き換え時にエラーが発生し、処理を停止してしまいます。これを避
けるには置換コマンドの最後に"e"フラグを付けてください。 >

	:%s/\<GetResp\>/GetAnswer/ge

"e"フラグは":substitute"でヒットしなくてもエラーにしないという意味になります。

==============================================================================
*12.2*	"Last, First"を"First Last"に置換

次のような形式で名前の一覧があるとします。

	Doe, John ~
	Smith, Peter ~

これを次のように変更したいとします。

	John Doe ~
	Peter Smith ~

これは次の１コマンドでできてしまいます。 >

	:%s/\([^,]*\), \(.*\)/\2 \1/

これを各部品にバラしてみましょう。最初が置換コマンドであることは明らかです
ね。"%"は行範囲でファイル全体を示します。ですから、次の置換はファイル中の各
行に対して実施されます。
置換コマンドの引数は"/from/to"ですね。スラッシュ(/)は"from"パターンと"to"パ
ターンのセパレータに使います。"from"パターンは次のようになっています。
							\([^,]*\), \(.*\) ~

	最初の\( と \) で囲まれた部分は"Last"		\(     \)
	    カンマ(,)以外の全文示にヒット		  [^,]
	    何文字でもヒット				      *
	", "という文字パターンにヒット			         ,
	２つ目の\( と \)に囲まれた部分は"First"		           \(  \)
	    どんな文字でもヒット			             .
	    何文字でもヒット					      *

"to"部分には"\2"と"\1"という指定があります。これをバックリファレンスと呼びま
す。これは"from"パターンの"\( \)"部分にヒットした文字列を示します。"\2"は２つ
目の"\( \)"にヒットする文字列となります。この場合なら名("First" name)になりま
す。また、"\1"は最初の"\( \)"の文字列を示します。この場合なら姓("Last" name)で
す。
置換コマンドの"to"部分には最大で９つのバックリファレンスが指定できます。
"\0"はヒットしたパターン全体の意味となります。置換コマンドにはこの他にいくつ
か特殊なアイテムがあります。|sub-replace-special|をご覧ください。

==============================================================================
*12.3*	リストの並び替え

Makefileではファイル名リストをよく使います。例をあげます。

	OBJS = \ ~
		version.o \ ~
		pch.o \ ~
		getopt.o \ ~
		util.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		backup.o ~

このリストを並べ替えするには、外部のソートコマンドを使って文字列をフィルタリ
ングします。 >

	/^OBJS
	j
	:.,/^$/-1!sort

まず"OBJS"を行頭に含む最初の行にジャンプします。次に１行下にカーソルを動かし
て次の空行までをフィルタに通します。行範囲をビジュアルモードで選択し"!sort"
コマンドを使うこともできます。この方法は入力しやすいですが、行がたくさんある
場合は作業量が多くなります。
この結果、次のようになります。

	OBJS = \ ~
		backup.o ~
		getopt.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		pch.o \ ~
		util.o \ ~
		version.o \ ~


各行の最後に行結合のためのバックスラッシュ(\)を使っている点に注意して下さい。
並べ替えたために、これがうまくいかなくなっています！元々は"backup.o"は最後に
あったので行末にバックシュラッシュがありません。しかし並べ替えで他の場所に移
動してしまったのでバックスラッシュが必要です。
一番簡単な解決は"A \<Esc>"でバックスラッシュを追加することです。最後の行にあ
るバックスラッシュはそのままにしておいても、次の行を空白行にしておけば問題あ
りません。これで同じ問題は二度と起きないでしょう。

==============================================================================
*12.4*	行順序の逆転

|:global|コマンドは|:move|コマンドと組み合せて、全ての行を１行目の上に移動す
ることで、結果として行の順序が逆転したファイルを作ることができます。そのコマ
ンドは次の通りです。 >

	:global/^/m 0
< 
その短縮形はこの通りです。 >

 	:g/^/m 0
<

"^"という正規表現は行の先頭に(その行が空行でも)合致します。|:move|コマンドは
合致した行を０行目(実際には存在しない仮想的な行)の後に移動します。ですから、
現在の合致行はファイルの先頭行となるわけです。
|:global|コマンドでは行番号が変更となることによる混乱が生じませんので、条件
に合致する全ての行について、１つづつ最初の行としてプットすることになります。

これは行範囲を指定した時も正しく動きます。まず、範囲としたい最初の行にカーソ
ルを移動し、"mt"コマンドでマークします。次に範囲としたい最終行にカーソルを動
かし、次のように入力します。 >

 	:'t+1,.g/^/m 't

==============================================================================
*12.5*	単語数のカウント

時には単語数の最大値を気にしながら文章に書かなければならない場合もあるでしょ
う。vimは単語数を教えてくれます。
ファイル全体の単語数をカウントしたい場合は、次のコマンドを使います。 >

	g CTRL-G

"g"の後に空白キーを押さないでください。上の例で空白を使っているのはコマンド
を読み易くするためです。
この出力結果は次のようになります。

	Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~
JP注: 日本語環境では 次のように出力される。
JP注:	列 1 / 0; 行 141 of 157; 単語 748 / 774; 文字 4489 / 4976
smz なんで行のトコロだけ"of"なんだろう^^
KRN なんでだろうね? (^_^;

これを見れば、カーソルが何番目の単語にあり(748)、ファイル全体でいくつの単語
があるのか(774)がわかります。

ファイルの一部の文章だけの場合は、その先頭に移動し、"g CTRL-G"を入力し
ます。次に末尾に移動して"g CTRL-G"をもう一度押します。で、あとはあなたが、引
き算で単語数を求めてください。これは頭の体操にはなりますが、あまり簡単とは言
えません。ビジュアルモードを使えば、かぞえたい範囲を選んでから"g CTRL-G"を入
力します。結果は次のようになります。

	Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~
JP注: 日本語環境では 次のように出力される。
JP注:	選択 5 / 293 行; 70 / 1884 単語; 359 / 10928 文字

単語数や行数などをカウントする他の方法については、|count-items|をご覧くださ
い。

==============================================================================
*12.6*	マニュアルページの参照				*find-manpage*

シェルスクリプトやＣプログラムを編集している時に、(Unix環境なら)使っているコ
マンドや関数のマニュアルページ(man pages)を参照したいでしょう。まずは簡単な
方法でやってみましょう。カーソルを見つけたい単語の上に移動して、次のコマンド
を入力します。 >

	K

vimはカーソル位置の単語を"man"プログラムを使って探します。マニュアルページが
見つかった場合はそれを表示します。これは普通のページャ(ほとんど"more"コマン
ドと同じ)を使ってテキストをスクロール表示します。マニュアルの最後まで表示し
て、<Enter>を押すと、vimに戻ります。

これの欠点はマニュアルページと編集中の文章を同時に見れないことです。実はvim
ウィンドウの中にマニュアルページを表示させるテクニックもあります。最初に"man"
ファイルタイププラグインをロードします。 >

	:runtime! ftplugin/man.vim

このコマンドをいつも使うのであれば、vimrcファイルに書いておけばよいでしょう。
こうすると、":Man"コマンドを使ってマニュアルページ用のウィンドウを開くことが
できます。 >

	:Man csh

ハイライト化されたテキストをスクロールして見ることができます。スクロールした
り、ハイライト化したりできます。これで探しているヘルプを見つけることができま
す。CTRL-W w を使うと、ウィンドウ間をジャンプして編集中のプログラムに戻れま
す。
特定のセクションのマニュアルページを探すには、セクション番号を最初に付けま
す。例えば、セクション３にある"echo"を探すには次のようにします。 >

	:Man 3 echo

ヘルプ本文中の他のマニュアルページ(例えば"word(1)"の形式)にジャンプするには、
そこの上でCTRL-]を押します。もう一度":Man"コマンドを使った場合も同じウィンド
ウを使います。

カーソル下にある単語のマニュアルページを表示するのは次のコマンドです。 >

	\K

(もし<Leader>を再定義しているのであれば、"\"ではなくそれを使います)
例えば、次の行を編集中に"strstr()"の復帰値を知りたくなれば、

	if (strstr(input, "aap") == ) ~

カーソルを"strstr"の上に動かし、"\K"を入力します。ウィンドウが開いてstrstr()
のマニュアルページを表示してくれます。

==============================================================================
*12.7*	空白の圧縮(trim)

一部には、行末にある空白やTABの類を無用であり、浪費であり、見苦しいものである
と考える人々がいます。各行の末尾の空白類を取り除くには、次のコマンドを使いま
す。 >

	:%s/\s\+$//

ここでも行範囲に"%"を使っています。これはファイル全体を示します。
":substitute"コマンドが探すパターンは"\s\+$"です。これは空白類の文字(\s)が
１文字以上続き(\+)、そこで行が終わる($)パターンを探します。
後の章(|usr_27.txt|)で、このようなパターンの書き方を説明します。
この置換コマンドの"to"部分は空っぽ("//")です。つまり、「無」に置き換えるわけ
で、結局空白類を削除することになるわけです。

もう一つの浪費パターンとして、TABの直前に空白文字を使っている場合があります。
たいていは空白の(見た目の)量を変えずに削除できます。が、いつもというわけじゃ
ありません！ですから、これは手作業でやるのがベストです。次の検索コマンドを使
います。 >

	/ 	

何も見えないですが、このコマンドではTAB文字の前に空白文字があります。つまり
これは"/<Space><Tab>"なのです。ここで、"x"コマンドを使って空白を削除して、
TAB位置などに変化がないか確認します。次のヒットを探すために"n"を押し、同じ作
業をヒットするものがなくなるまで繰り返します。

==============================================================================
*12.8*	単語を使っている場所を探す

Unixユーザであれば、vimと"grep"コマンドを組み合せれば、ある単語を使っている全
ファイルを編集することができます。これはプログラムを作っていて、特定の変数を
使っている全ファイルを編集したい場合に、もの凄く便利です。
例えば、全Ｃプログラムファイル中の"frame_counter"という単語を含んでいる全て
のファイルを編集するとします。次のコマンドでそれができます。 >

	vim `grep -l frame_counter *.c`

このコマンドを詳しく見てみましょう。"grep"コマンドは与えられたファイル一覧か
ら、指定の単語を検索します。"-l"オプションが付いていますので、合致する行自体
を表示するのではなく、その単語を含んでいるファイル名だけを表示します。
検索する単語は"frame_counter"です。実際にはここにあらゆる正規表現が使えます。
(Note:grepで使える正規表現のパターンはvimとは完全には一致しません)
このコマンド全体をバッククオート(`)で囲んでいます。これはUNIXのシェルにこの
コマンドを先に実行し、その結果でコマンド行を置き換えます。ですからここでは
"grep"コマンドが実行して得たファイル一覧がvimのコマンド行に与えられます。
この結果、"grep"の出力のファイル一覧をvimで編集することになります。vimの中で
は":next"や":first"を使ってファイル間を行き来できます。


各行を探す
----------

上述のコマンドはその単語を含むファイルを見つけるだけでした。ファイル中の単語
は自力で探す必要があります。
vimには与えられた文字列をファイルリストから探すことのできる組み込みコマンド
があります。もし、全Ｃプログラムファイルから"error_string"が現れる場所を全て
探すのであれば、例えば次のコマンドを入力します。 >

	:grep error_string *.c

これは全ての指定ファイル(*.c)から"error_string"という文字列を探し出します。
vimはそのパターンを含んでいる最初のファイルを開き、カーソルを最初にヒットす
る場所に移動します。次にヒットしている場所に移動するには、(それが同じファイ
ルかどうかは気にせず)":cnext"コマンドを使います。一つ前に戻るには":cprev"コ
マンドを使います。":clist"を使うと、一致した全リストと現在位置を表示します。
":grep"コマンドは、外部コマンドの"grep"(Unixの場合)か"findstr"(Windowsの場
合)を使っています。実行するプログラムは'grepprg'オプションで設定できます。

==============================================================================

Next chapter: |usr_20.txt|  コマンド行のコマンドを素早く入力する

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
