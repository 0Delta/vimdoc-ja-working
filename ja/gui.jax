COMMENT: GUI機能:一般事項
STATUS: finished 5.7
TRANSLATOR: 高野亮(BlackLynx) <wolfpack@rose.ocn.ne.jp>
MAINTEINER: 村岡太郎 <koron@tka.att.ne.jp>

*gui.txt*       For Vim version 5.7.  Last change: 2000 Jun 22


		  VIMリファレンスマニュアル    by Bram Moolenaar


Vimのグラフィカルユーザインタフェース			*gui* *GUI*

1. GUIの開始			|gui-start|
2. スクロールバー		|gui-scrollbars|
3. マウス制御			|gui-mouse|
4. GUI選択の作成		|gui-selections|
5. メニュー			|menus|
6. 付記				|gui-extras|
7. シェルコマンド		|gui-shell|

他のGUIドキュメント:
|gui_x11.txt|	X11 GUIに特有の項目について。
|gui_w32.txt|	Win32 GUIに特有の項目について。

{Vi にはこれらのどのコマンドもない}

==============================================================================
1. GUIの開始						*gui-start*

最初に、本当にGUIのコードが含まれたVimのバージョンであるかを確かめなければなら
ない。":version"コマンドでこれを調べることができ、それは"+GUI_Athena",
"+GUI_BeOS", "+GUI_GTK", "+GUI_Motif"あるいは"MS-Windows ... 多少のGUIバージョ
ン"を含んでいるべきである。

どのようにGUIを始めるかは使用されているシステムに依存する。たいていはこれでVim
のGUIバージョンを実行することができる:
    gvim [options] [files...]

VimのX11バージョンはGUIとGUIでないモードの両方で実行することができる。
|gui-x11-start| を参照。

				*gui-init* *gvimrc* *.gvimrc* *_gvimrc*
GUIのスタートアップ時、初期化はこの順序で実行される:
- termcapオプションはGUIのためにデフォルト値にリセットされる。
- システムメニューファイルが存在するのであれば、それが情報源にされる。このファ
  イルの名前は通常"$VIMRUNTIME/menu.vim"である。":version"でこれを調べられる。
  |$VIMRUNTIME|も参照。システムメニューのロードを省略するには'guioptions'に'M'
  を含める。
					*buffers-menu* *no_buffers_menu*
  システムメニューファイルは"Buffers"メニューを含んでいる。これを望まないなら
  ば、あなたの.vimrc (.gvimrcではない!)に"no_buffers_menu"を設定する:
>		:let no_buffers_menu = 1
  ‘注意’: 構文強調表示をオンに切り替えることもメニューファイルをロードするた
  め、":syntax on"の前にバッファメニューが無効にされなければならない。
- Vimを開始するときに、"-U {gvimrc}"コマンドラインオプションが用いられているな
  らば、{gvimrc}ファイルが初期化のために読み込まれるだろう。以下の初期化は省略
  される。
- Unixに対しては、システムのgvimrcが存在するならば、それが情報源にされる。この
  ファイルの名前は通常"$VIM/gvimrc"である。":version"でこれを調べられる。
  |$VIM|も参照。
- 以下が試されて、存在する最初の1つだけが用いられる:
  - GVIMINIT環境変数が存在し空でないならば、それがExコマンドとして実行される。
  - ユーザのgvimrcファイルが存在するならば、それが情報源にされる。このファイル
    の名前は通常"$HOME/.gvimrc"である。":version"でこれを調べられる。
  - Win32に対しては、$HOMEが設定されないときには、"$VIM\_gvimrc"が用いられる。
  - "_gvimrc"ファイルが見つからないときには、".gvimrc"も試される。逆のときも同
    様である。
- 'exrc'オプションが設定されていて(これはデフォルト‘ではない’)、./.gvimrc
  ファイルが存在しシステムかユーザのgvimrcファイルと同じファイルでないならば、
  それが情報源にされる。このファイルがあなたの所有しているものでないならば、い
  くつかのセキュリティ上の制限が適用される。".gvimrc"が見つからないときには、
  "_gvimrc"も試される。MacintoshとDOS/Win32に対しては、"_gvimrc"が最初に試され
  る。

‘注意’: "-U"引数が与えられずに"-u NONE"でVimが開始されたか、あるいは
"-U NONE"で開始されたならば、最初のもの以外は全て実行されない。

これは全て、あなたの.vimrcファイルを読み込むような、通常のVimの初期化‘の後’
に起こる。|initialization|を参照。
しかし、GUIウィンドウは全ての初期化が実行された後にだけ開かれる。
GUIウィンドウを開いた直後にいくつかのコマンドを実行したいならば、|GUIEnter|
autocommandイベントを使用する。例えば:
>	autocommand GUIEnter * winpos 100 50

あなた自身のカスタマイズされたメニュー(|:menu|を参照)をセットアップしたり、
ターミナルバージョンとは異なったセットアップにしたい他のことを初期化するために
gvimrcファイルを使用することができる。

あなたの個人的なGUIの初期化のために推奨される場所:
	Unix		    $HOME/.gvimrc
	OS/2		    $HOME/.gvimrcあるいは$VIM/.gvimrc
	MS-DOSとWin32	    $HOME/_gvimrcあるいは$VIM/_gvimrc
	Amiga		    s:.gvimrcあるいは$VIM/.gvimrc

VimのGUIバージョンでだけ意味を持つ多くのオプションがある。'guicursor',
'guifont', 'guipty'と'guioptions'である。それらは他の全てのオプションと共に
|options.txt|に文書化されている。

GUIのMotifかあるいはAthenaバージョン(GTK+やWin32バージョンではない)を使用して
いるならば、多くのXのリソースが有効である。|gui-resources|を参照。

異なる理由により色を設定する別の方法はhighlightグループで行うことである。
"Normal"グループは背景色と前景色を設定するために用いられる。(よく見える)例:

>	:highlight Normal guibg=grey90

"guibg"と"guifg"の設定は通常の背景と前景の設定よりも優先される。Normal
highlightグループに対するその他の設定は用いられない。フォントを設定するには
'guifont'を使用する。

様々なモードでカーソルに色を設定するには、'guicursor'オプションも確認する。

Vimはスタートアップのときに、スクリーンにウィンドウを合せようとする。これはそ
の一部を見ることができなくならないようにする。X windowでは、これは少し憶測を必
要とする。'guiheadroom'オプションでウィンドウタイトルとタスクバーに用いられる
高さを変更することができる。

							*:winp* *:winpos*
:winp[os]
		GUI vimウィンドウの左上隅の現在の位置をピクセルで表示する。全
		てのバージョンで機能する訳ではない。

:winp[os] {X} {Y}
		与えられた{X}と{Y}の座標にGUI vimウィンドウを配置する。座標は
		ウィンドウの左上隅の位置をピクセルで指定すべきである。全てのバ
		ージョンで機能する訳ではない。(新しい)xtermで機能する
		|xterm-color|。

							*:win* *:winsize*
:win[size] {width} {height}
		{width}と{height}の文字によってウィンドウの高さを設定する。
		":set lines="と":set columns="を使用するのは古いやり方である。


==============================================================================
2. スクロールバー					*gui-scrollbars*

垂直スクロールバーと水平スクロールバーがある。'guioptions'オプションでどれが表
示されるかを設定してもよい。

インタフェースは(":set guioptions=mlrb"で)このように見える:

		       +------------------------------+
		       | ファイル 編集	       ヘルプ | <- メニューバー(m)
		       +-+--------------------------+-+
		       |^|			    |^|
		       |#| テキストエリア	    |#|
		       | |			    | |
		       |v|__________________________|v|
 Vimウィンドウ間の  -> |-+ File.c	       5,2  +-|
 通常のステータス行    |^|""""""""""""""""""""""""""|^|
		       | |			    | |
		       | | 別のファイルバッファ     | |
		       | |			    | |
		       |#|			    |#|
 左スクロールバー(l)-> |#|			    |#| <- 右スクロールバー(r)
		       |#|			    |#|
		       | |			    | |
		       |v|			    |v|
		       +-+--------------------------+-+
		       | |< ####		   >| | <- 下スクロールバー(b)
		       +-+--------------------------+-+

どのスクロールバーやメニューコンポーネントも'guioptions'文字列に適切な文字を付
加しないことでオフに切り替えてもよい。下スクロールバーは'nowrap'が設定されてい
るときに便利なだけである。


垂直スクロールバー					*gui-vert-scroll*

Vimウィンドウ毎に次へのスクロールバーを持っていて、そのバッファ内でテキスト全
体を動かすためにスクロールアップ・ダウンすることができる。スクロールバーのつま
みのサイズはウィンドウに見えているバッファの割合を示している。スクロールバーが
ずっと下方にドラッグされると、ファイルの最後の行はウィンドウの最上部に表示され
るだろう。

ウィンドウが(他のウィンドウの拡大によって)高さゼロに縮小されたならば、そのスク
ロールバーは表示されなくなる。それはウィンドウが復元されるときに再び表示され
る。

水平スクロールバー					*gui-horiz-scroll*

(Vim GUIの最下段の)水平スクロールバーは、'wrap'オプションがオフに切り替えられ
るときに、横にテキストをスクロールするために使用することができる。スクロール
バーのつまみのサイズは、現在のカーソルのある行のテキストが左右に可能な限りずっ
とスクロールすることができるくらいである。

							*athena-intellimouse*
インテリマウスを持っていて、Linuxを運用しており、Xサーバでホイールを使用するた
めの適切なパッチを持っているならば、gvimで上下にテキストをスクロールするために
ホイールを使用することができる。今のところ、それはathenaバージョンでしか機能し
ない。

これを使用するには、パッチの当たったXサーバがなくてはならない。以下のページに
はパッチとXサーバのバイナリへのリンクに加えて、Linux上でインテリマウスを使用す
ることについて多少の情報がある(けれども必要とするものはないかもしれない):
    http://www.inria.fr/koala/colas/mouse-wheel-scroll/

ホイールを使用するには、カーソルをスクロールバーエリアに置きホイールを上下に動
かす。これは上下に1行、テキストをスクロールするだろう。シフトキーを押したまま
にしておけば、一度に1ページ、スクロールするだろう。

==============================================================================
3. マウス制御						*gui-mouse*

マウスは、'mouse'オプションの中に適切なフラグが設定されている場合にだけ機能す
る。GUIがオンに切り替えられて、'mouse'がまだ設定されていないときには、'mouse'
オプションは自動的に"a"に設定され、|hit-return|プロンプトを除いて全てのモード
で有効になる。これを望まないならば、"gvimrc"ファイルが'mouse'オプションを変更
するにはよい場所である。

関連する他のオプション:
'mousefocus'	ウィンドウフォーカスがマウスポインタに追従する
		|gui-mouse-focus|
'mousemodel'	マウスのどのボタンがどのような動作をするか
'mousehide'	テキストをタイプしている間マウスポインタを隠す
'selectmode'	SelectモードあるいはVisualモードを開始するかどうか

素早くこれらを設定するには":behave"コマンドで行う。
							*:behave* *:be*
:be[have] {model}	マウスと選択の動作を設定する。有効な引数は:
			   mswin	MS-Windowsの動作
			   xterm	Xtermの動作

			":behave"を使用するとこれらのオプションが変更される:
			option		mswin			xterm	~
			'selectmode'	"mouse,key"		""
			'mousemodel'	"popup"			"extend"
			'keymodel'	"startsel,stopsel"	""
			'selection'	"exclusive"		"inclusive"

$VIMRUNTIMEディレクトリの中に、MS-Windowsのcut/copy/pasteコマンドのためのいく
つかのキーもマップする"mswin.vim"と呼ばれるスクリプトがある。
これは、CTRL-V, CTRL-XとCTRL-Cキーを用いるので、互換性が‘ない’。嫌でなけれ
ば、このコマンドを使用する:
>	:so $VIMRUNTIME/mswin.vim

マウスのホイールでスクロールするには、|scroll-mouse-wheel|を参照。


3.1 マウスによるカーソルの移動				*gui-mouse-move*

カーソルを持って行きたいテキストバッファのどこかでマウスの左ボタンをクリックす
ると、カーソルはそこに行く!
動作するモード	    'mouse'が以下を含んでいるとき
Normal mode	    'n' or 'a'
Visual mode	    'v' or 'a'
Insert mode	    'i' or 'a'

SelectモードはVisualモードのように扱われる。

現在のカーソル位置からマウスで指示する位置までのテキストを削除するために'd'の
ようなオペレータと共にこれを使用してもよい。つまり、'd'を打ち込んでからどこか
でマウスをクリックする。

							*gui-mouse-focus*
'mousefocus'オプションはキーボードフォーカスをマウスポインタに追従させるように
設定することができる。これはマウスポインタがあるウィンドウがアクティブウィンド
ウになることを意味する。警告: menuコマンドは常に一番上のウィンドウに適用される
だろうから、menuを使用しているときには、これは非常にうまく機能するという訳では
ない。

':'の行(あるいは'/'または'?')の上にあるならば、('mouse'が'c', 'a'あるいは'A'を
含んでいるならば)マウスの左かあるいは右ボタンをクリックすることで、':'の行に
カーソルが配置されるだろう。

どのような状況でも、現在の選択を貼り付けるために、マウスの中ボタンをクリックし
てもよい。


3.2 マウスによる選択					*gui-mouse-select*

マウスは選択を開始するために使用することができる。'mousemodel'オプションにどの
ように依存するかは:
'mousemodel'が"extend"である: マウスの右ボタンを使用する。
'mousemodel'が"popup"である: Shiftキーが押されている間、マウスの左ボタンを使用
する。

まだ何も選択していなければ、これはカーソルがあった位置からマウスで指示した位置
までを選択し始める。すでに選択しているならば、最も近くの終端が延長されるだろ
う。

'selectmode'が"mouse"を含んでいるならば、選択はSelectモードであるだろう。これ
は選択がタイプする通常のテキストで置き換えられることを意味する。|Select-mode|
を参照。そうでなければ、選択はVisualモードであるだろう。

ダブルクリックで単語の選択、トリプルクリックで行の選択、クワドルプルクリック
(4回クリック)で矩形ブロックを選択することができる。

どのように選択が用いられるかに関しては|gui-selections|を参照。


3.3 マウスによる他のテキスト選択			*gui-mouse-modeless*

Command-lineモードのときには、|hit-return|プロンプトにおいて、あるいは現在の
モードが'mouse'オプションの中にないときはいつでも、異なった種類の選択が用いら
れる。選択がそこになく、選択に関連付けられたモードがないようにVimが継続するの
で、これはモードレス選択と呼ばれる。Vimウィンドウの中のどんなテキストでも選択
することができる。開始点でマウスの左ボタンを押すことでテキストを選択し、終点ま
でドラッグして離す。選択を延長するには、'mousemodel'が"extend"のときにはマウス
の右ボタンを使用するか、あるいは'mousemodel'が"popup"のときにはシフトキーを押
しながらマウスの左ボタンを使用する。マウスの中ボタンはテキストを貼り付ける。


3.4 ステータス行でのマウスの使用			*gui-mouse-status*

Vimウィンドウの下のステータス行でマウスの左かあるいは右のボタンをクリックする
ことでそのウィンドウが現在のウィンドウになる。さらにステータス行を動かすために
上下にマウスをドラッグしてもよく、このようにして上下にウィンドウのサイズを変更
する。


3.5 様々なマウスクリック				*gui-mouse-various*

    <S-LeftMouse>	マウスクリックで単語を前方検索する。'mousemodel'が
			"popup"のときには、これは選択を開始するか、あるいは延
			長する。
    <S-RightMouse>	マウスクリックで単語を後方検索する。
    <C-LeftMouse>	マウスクリックでタグ名へジャンプする。
    <C-RightMouse>	直前のタグジャンプの前の位置に戻る("CTRL-T"と同じ)。


3.6 マウスマッピング					*gui-mouse-mapping*

修飾子付きのマウスイベントがマップされてもよい。例えば:
>   :map <S-LeftMouse>     <RightMouse>
>   :map <S-LeftDrag>      <RightDrag>
>   :map <S-LeftRelease>   <RightRelease>
>   :map <2-S-LeftMouse>   <2-RightMouse>
>   :map <2-S-LeftDrag>    <2-RightDrag>
>   :map <2-S-LeftRelease> <2-RightRelease>
>   :map <3-S-LeftMouse>   <3-RightMouse>
>   :map <3-S-LeftDrag>    <3-RightDrag>
>   :map <3-S-LeftRelease> <3-RightRelease>
>   :map <4-S-LeftMouse>   <4-RightMouse>
>   :map <4-S-LeftDrag>    <4-RightDrag>
>   :map <4-S-LeftRelease> <4-RightRelease>
これらのマッピングは、恐らくマウスの右ボタンよりむしろシフト－左ボタンで視覚的
な領域を拡張することを考慮しているMotifアプリケーションですべき方法で選択を機
能させる。

修飾子を伴うマウスマッピングはモードレス選択では機能しない。

==============================================================================
4. GUI選択の作成					*gui-selections*

							*quotestar*
マウス(|gui-mouse-select|を参照)か、あるいはVimのVisualモード(|v|を参照)を使用
して、選択を作成してもよい。'guioptions'に'a'が存在するならば、いつ選択が開始
される(VisualあるいはSelectモード)としても、あるいは選択が変更されるときには、
Vimがウィンドウシステムの主要な選択(MS-Windowsでは|gui-clipboard|が用いられる)
の所有者になる。

この選択を保存するための特別なレジスタがあり、それは"*レジスタである。どのテキ
ストが変更されようとして選択されているか(例えば、マウスの左ボタンでどこかをク
リックして)、あるいはいつ他のアプリケーションが選択されたテキストを貼り付けた
いのかという情報がない限りここには何も書き出されない。そのテキストは"*レジスタ
に書き出される。例えば、行を切り取って、それを現在の選択にする、あるいはクリッ
プボードにそれを書き出すためには:
>	"*dd

同様に、例えば、マウスの中ボタンをクリックすることで、他のアプリケーションから
選択を貼り付けたいときには、選択は始めに"*レジスタに書き出され、それから他のレ
ジスタのようなものに‘書き出す’。例えば、選択(クリップボードの内容)を書き出す
ためには:
>	"*p

あるVimから他の独立したVimにテキストを貼り付けたいときには、選択のタイプ(文
字、行あるいはブロック)もコピーされることに注意する。他のアプリケーションにつ
いては、タイプは常に文字である。

'clipboard'オプションに"unnamed"文字列が含まれているときには、無名レジスタは"*
レジスタと同じである。したがってコマンドの前に"*を付けずに選択をコピーし貼り付
けることができる。

==============================================================================
5. メニュー						*menus*

5.1 メニューの使用					*using-menus*

基本的には、メニューは単にマッピングのように使用することができる。あなた自身の
メニューを好きなだけたくさん定義することができる。メニューのデフォルト設定があ
るので、無から始めなくてもよい。長い間Vimユーザ達はメニューを十分に使用してこ
なかった。しかしあなた自身のメニューとメニュー項目を追加すること中にその力があ
る。それらはキーシーケンスが何だったかを覚えられないようなときに最も便利であ
る。

							*menu.vim*
デフォルトのメニューは"$VIMRUNTIME/menu.vim"ファイルから読み込まれる。パスがど
こを指すかについては|$VIMRUNTIME|を参照。あなた自身のメニューをセットアップす
ることができる。デフォルト設定をオフにして開始することができるのはよいアイデア
である。さらに項目を追加したり、あるいは、デフォルトが全く気に入らないなら、全
てのメニューを取り除いて開始することができる|:unmenu-all|。あなたの.vimrcファ
イル(.gvimrcファイル‘ではない’!)にこの行を追加することでデフォルトのメニュー
がロードされないようにすることもできる:
>	let did_install_default_menus = 1
Syntaxメニューもロードされないようにしたいなら:
>	let did_install_syntax_menu = 1

バッファのメニューの内容はbufmenu_fullpathとbufmenu_maxlen変数を設定することで
制御することができる。前者は、1に設定されるならば、メニューの中でファイルのフ
ルパスが用いられることを指定する。後者はメニューラベルの中のパスの長さの最大値
を指定する。パスが長くなると、最初と最後以外のパスの要素は取り除かれる。次に、
必要であれば、後ろと前の文字がこれらから取り除かれる。最後に全てのパスの要素が
取り除かれる。.gvimrcはmenu.vimの後に実行されるので、これらの変数は.vimrcかあ
るいは同様のファイルの中で設定されなければならない。デフォルト値は
bufmenu_fullpath=0とbufmenu_maxlen=50である。

							*console-menus*
このドキュメントはGUIセクションの中にあるけれども、コンソールモードでも実際に
メニューを使用することができる。そのときには明示的に|menu.vim|をロードしなけれ
ばならないだろう、それはデフォルトではなされない。ほぼ実際のメニューシステムの
ようにメニューのエントリにアクセスするために'wildmenu'で|:emenu|コマンドとコマ
ンドライン補完を使用することができる。これをするには、あなたの.vimrcファイルに
これらのコマンドを付加しておく:
>	:source $VIMRUNTIME/menu.vim
>	:set wildmenu
>	:set cpo-=<
>	:set wcm=<C-Z>
>	:map <F4> :emenu <C-Z>
<F4>を押すとメニューを開始するだろう。そのときにはメニューのエントリを選択する
ためにカーソルキーを使用することができる。それを実行するには<Return>を打ち込
む。キャンセルしたいならば<Esc>を打ち込む。これはコンパイル時に|+menu|機能を有
効にする必要がある。

							*tear-off-menus*
GTK+とMotifはTear-offメニューをサポートする。これらは張り付いたメニューかある
いはいつも存在しているポップアップメニューのようなものである。サイズの変更が正
確に機能しないならば、これはデフォルトで何か"Vim*geometry"のようなものを用いる
ことによって起こされるのかもしれない。代わりに"Vim.geometry"を使用する。

Win32 GUIバージョンはMotifのtear-offメニューをエミュレートする。実際には、
Motifユーザーは容易に相違を見つけるであろうが、うまく行けばそれらは同じくらい
に便利である。メインメニューバーには現れないフローティングメニューを作成するた
めに|:tearoff|コマンドと共に|win32-hidden-menus|を使用することもできる。


5.2 新しいメニューの作成				*creating-menus*

				*:me*  *:menu*  *:noreme*  *:noremenu*
				*:am*  *:amenu* *:an*      *:anoremenu*
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
新しいメニュー項目を作るには、":menu"コマンドを使用する。それらはまさにコマン
ドの":map"の設定と同様だが最初の引数はメニュー項目の名前であり、'.'で区切った
メニューとサブメニューのパスとして与えられる。例えば:
>   :menu File.Save  :w<CR>
>   :inoremenu File.Save  <C-O>:w<CR>
>   :menu Edit.Big\ Changes.Delete\ All\ Spaces  :%s/[ ^I]//g<CR>

この最後の1つは"Edit"と呼ばれるメニューバーに新しい項目を作るだろう、そしてこ
の上でマウスのボタンを押し続けると"Big Changes"サブメニューを含んだメニューを
ポップアップするだろう、このサブメニューは"Delete All Spaces"の項目を含んでい
て、この項目を選択したとき、その操作を行う。

メニュー名での特殊文字:
	&	次の文字はショートカットキーである。どのショートカットキーも
		(サブ)メニューの中で1度だけしか使用されていないことを確認する
		こと。
	<Tab>	右詰めされたテキストからメニュー名を分離する。これは同等のタイ
		プするコマンドを表示するために使用することができる。"<Tab>"テ
		キストは便宜上ここで使用してもよい。本当のTabを使用しているな
		らば、その前にバックスラッシュを付け忘れてはならない!
例:
>   :amenu &File.&Open<Tab>:e  :browse e<CR>
[文字通りタイプする]
(<Alt>キーを押し続けている間に)"F"、それから"O"のショートカットで、この
メニューを使用することができる。2番目の部分は"Open     :e"のように表示される。
":e"は右詰めされ、それがショートカットであることを示すために、"O"には下線が引
かれる。

":amenu"コマンドは1度で全てのモードにメニューのエントリを定義するために使用す
ることができる。コマンドを正確に機能させるために、いくつかのモードには文字が自
動的に挿入される:
	モード		挿入される文字	~
	Normal		なし
	Visual		<Esc>
	Insert		<C-O>
	Cmdline		<C-C>
	Op-pending	<Esc>

例:
>   :amenu File.Exit	:qa!^M
は以下と同じ:
>   :nmenu File.Exit	:qa!^M
>   :vmenu File.Exit	^[:qa!^M
>   :imenu File.Exit	^O:qa!^M
>   :cmenu File.Exit	^C:qa!^M
>   :omenu File.Exit	^[:qa!^M

注意: Insertモードでは、CTRL-Oのために、これは‘1つの’Normalモードのコマンド
に対してだけ機能する。2つかそれ以上のコマンドがあるならば、":imenu"コマンドを
使用する必要があるだろう。どのモードでもテキストを挿入するには、式のレジスタを
使用することができる:
>   :amenu Insert.foobar   "='foobar'<CR>P

'cpoptions'の中の'<'と'k'フラグはここにも適用する(含まれていたときには、それら
は認識されずに<>の書式と生のキーコードを作る)ことに注意する。

Cmdlineモードでの<Esc>はマッピングの中にあるようにコマンドを実行することに注意
する。これはVi互換である。Cmdlineモードを終了するにはCTRL-Cを使用する。

							*menu-priority*
メニューに優先度を与えることができる。より高い優先度を与えられたメニューほど右
に行く。優先度は":menu"コマンドの前の数字で与えれられる。
例:
>	:80menu Buffer.next :bn<CR>

デフォルトのメニューはこれらの優先度を持つ:
	File		10
	Edit		20
	Tools		40
	Syntax		50
	Buffers		60
	Window		70
	Help		9999

何も与えられないか、あるいはゼロの優先度が与えられるときには、500が用いられ
る。ポップアップメニューについては優先度は用いられない。

ヘルプメニューの後ろに置くために、9999より高い優先度を使用することができるが、
それは非標準であり、推奨しない。優先度の取り得る値は最高で約32000である。最低
は1である。

							*sub-menu-priority*
同じ機構はサブメニューを配置するために使用してもよい。優先度は、メニュー名の前
に、ドット区切りの優先度のリストとして与えられる:
>	:menu 80.500 Buffer.next :bn<CR>
サブメニューの優先度を与える必要があるのは、項目が通常の位置に置かれないときだ
けである。例えば、他の項目の前にサブメニューを置くには:
>	:menu 80.100 Buffer.first :brew<CR>
あるいは他の項目の後にサブメニューを置いて、それ以上のデフォルトの優先度を持つ
項目がその前に置かれるようにするには:
>	:menu 80.900 Buffer.last :blast<CR>
数字が抜けているときには、デフォルト値の500が用いられる:
>	:menu .900 myMenu.test :echo "text"<CR>
メニューの優先度は新しいメニューが生成されるときにだけ用いられる。それがすでに
存在するときには、例えば、別のモードでは、優先度は変わらないだろう。したがっ
て、優先度はメニューが使用される最初のときにだけ与えられる必要がある。
例外はポップアップメニューである。モード毎(Normal, Op-pending, Visual, Insert,
Cmdline)に分かれたメニューがある。これらのメニュー毎での順序は異なってもよい。
これはメニューバーメニューとは異なる。
注意: サブメニューの優先度は現在全てのGUIのバージョンに対して機能する訳ではな
い。

							*gui-toolbar*
現在、ツールバーはWin32とGTK+ (X11) GUIでだけ有効である。やがては他のGUIにも現
れるべきである。サンプルのツールバーの定義はmenu.vimに与えられている。ツール
バーの表示は'guioptions'の文字'T'によって制御される。したがって、メニューと
ツールバーを同時に、あるいはいずれかを持つことができるし、またどちらも持たない
ようにすることもできる。

ツールバーは、1つのレベルだけを持つToolBarと呼ばれる特別なメニューとして定義さ
れている。Vimはこのメニューの項目を以下のように解釈する:
1)  'BuiltIn##'(##は数字である)と呼ばれる項目はVimで利用可能な組み込みのビット
    マップの番号##と見なされる。現在、最も一般的な編集操作|builtin-tools|を包
    含する、0から27まで振られた28の番号がある。
2)  他の名前を持つ項目は最初に$VIM/bitmapsディレクトリから検索される。見つかっ
    たならば、そのビットマップファイルがツールバーボタンのイメージとして用いら
    れる。正確なファイル名はOS特有であることに注意する: 例えば、Win32でのコマ
    ンド
>	:amenu ToolBar.Hello :echo "hello"<CR>
    は、'hello.bmp'ファイルを検索するだろう。GTK+/X11では'Hello.xpm'である。カ
    スタムビットマップのロードはW95, NT4とGTK+でだけサポートされる。Win32では、
    ビットマップはボタンに合わせて大きさが調整されるが、GTK+ではされない。
    GTK+については、デフォルトのpixmapのサイズは20x20ピクセルが用いられる。
3)  $VIM/bitmapsにビットマップが見つからないならば、Vimは組み込みの名前のリス
    トに対して同等のものを探す。どの組み込みのボタンイメージも名前を持ってい
    る。だから、コマンド
>	:amenu ToolBar.Open :e
    は、open.bmpが存在しなければ、組み込みの"open a file"ボタンイメージを表示
    するだろう。全ての組み込みの名前はmenu.vimで用いられているのを見ることがで
    きる。
4)  他の全てが失敗するならば、空白だが、機能している、ボタンが表示される。

							*builtin-tools*
番号  名前		通常の動作  ~
00    New		新しいウィンドウを開く
01    Open		現在のウィンドウで開くためにファイルをブラウズする
02    Save		バッファをファイルに保存する
03    Undo		最後の変更を取り消す
04    Redo		最後の取り消した変更をやり直す
05    Cut		選択されたテキストを削除しクリップボードへ送る
06    Copy		選択されたテキストをクリップボードにコピーする
07    Paste		クリップボードからテキストをペーストする
08    Print		現在のバッファを印刷する
09    Help		Vimの組み込みのヘルプでバッファを開く
10    Find		検索コマンドを開始する
11    SaveAll		全ての修正されたバッファをファイルに保存する
12    SaveSesn		現在の状態をセッションファイルに保存する
13    NewSesn		新しいセッションファイルに保存する
14    LoadSesn		セッションファイルを読み込む
15    RunScript		Vimスクリプトとして実行するためにファイルをブラウズ
			する
16    Replace		置換コマンドのためのプロンプト
17    WinClose		現在のウィンドウを閉じる
18    WinMax		現在のウィンドウに使用する行数を最大にする
19    WinMin		現在のウィンドウに使用する行数を最小にする
20    WinSplit		現在のウィンドウを分割する
21    Shell		シェルを開始する
22    FindPrev		後方に再検索する
23    FindNext		前方に再検索する
24    FindHelp		ヘルプを検索する単語のためのプロンプト
25    Make		makeを実行し最初のエラーにジャンプする
26    TagJump		カーソルの下のtagにジャンプする
27    RunCtags		現在のディレクトリのファイルに対してtagsを作成する

							*win32-hidden-menus*
Win32 GUIでは、']'で始まるメニュー名はメインメニューバーから除外される。それを
表示するには|:tearoff|コマンドを使用しなければならない。

							*popup-menu*
Win32, GTK, MotifとAthena GUIでは、特別なメニュー"PopUp"を定義することができ
る。これは、'mousemodel'がpopupあるいはpopup_setposに設定されているならば、マ
ウスの右ボタンが押されたときに表示されるメニューである。


5.3 マップされているメニューの表示			*showing-menus*

存在しているどのメニューがマップされているかを見るには、(":map"コマンドでする
のと全く同様に)menuコマンドの後にたった1つの引数を使用するだけである。指定され
たメニューがサブメニューならば、その階層の下の全てのメニューが表示されるだろ
う。:menuの後に全く何も引数が与えられなかったならば、適切なモードに対する‘全
ての’メニュー項目が表示される(例えば、Command-lineモードに対して:cmenu)。

メニューコマンドの後にメニュー名を入力している間に<Tab>を打つことはメニュー項
目の名前を補完するのに使われるかもしれないことに注意する。


5.4 メニューの実行					*execute-menus*

							*:eme*  *:emenu*
コマンドラインからメニュー項目を手動で実行するには、:emenuコマンドを使用する。
例えば:
>	:emenu File.Exit

メニューに関連付けられた通常モードのコマンドが実行される(通常それがしたいこと
でなので)。コンソールモードのvimがWANT_MENUを定義されてコンパイルされている
ならば、GUIモードによって慣れてしまった便利なメニュー項目にアクセスするために
:emenuを使用することができる。これと共にうまく機能するオプションについては
'wildmenu'を参照。例については|console-menus|を参照。


5.5 メニューの削除					*delete-menus*

						*:unme*  *:unmenu*
						*:aun*   *:aunmenu*
						*:nunme* *:nunmenu*
						*:ounme* *:ounmenu*
						*:vunme* *:vunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
メニュー項目あるいは全てのサブメニューを削除するには、unmapコマンドに類似した
unmenuコマンドを使用する。例えば:
    :unmenu! Edit.Paste

これはInsertとCommand-lineモードに対してEditメニューからPaste項目を取り除くだ
ろう。

メニューコマンドの後にメニュー名を入力している間に<Tab>を打ち込むことは適切な
モードに対するメニュー項目の名前を補完するために使われるかもしれないことに注意
する。

全てのメニューを取り除くには以下を使用する:		 *:unmenu-all*
>	:unmenu *	" Normalとvisualモードで全てのメニューを取り除く
>	:unmenu! *	" InsertとCommand-lineモードで全てのメニューを取り除く


5.6 メニューの例					*menu-examples*

ここにあるのはメニューにメニュー項目を追加する方法の例である! カーソルの下の
キーワードに対してメニュー項目を追加することができる。レジスタ"z"が使用され
る。

>  :nmenu Words.Add\ Var	wb"zye:menu! Words.<C-R>z <C-R>z<CR>
>  :nmenu Words.Remove\ Var	wb"zye:unmenu! Words.<C-R>z<CR>
>  :vmenu Words.Add\ Var	"zy:menu! Words.<C-R>z <C-R>z <CR>
>  :vmenu Words.Remove\ Var	"zy:unmenu! Words.<C-R>z<CR>
>  :imenu Words.Add\ Var	<Esc>wb"zye:menu! Words.<C-R>z <C-R>z<CR>a
>  :imenu Words.Remove\ Var	<Esc>wb"zye:unmenu! Words.<C-R>z<CR>a

(rhsは<>表記の中にあり、マッピングを試すためにこのテキストをコピー/ペーストす
るか、あるいはあなたのgvimrcにこれらの行を付加することができる; "<C-R>"は
CTRL-Rであり、"<CR>"は<CR>キーである。|<>|)

ツールtipsとメニューtips

これらは現在Win32 GUIでだけサポートされている。しかしながら、それらはそう遠く
ない未来に他のguiプラットホームのために現われるべきである。

							*:tmenu* *:tm*
:tm[enu] {menupath} {rhs}	メニューあるいはツールにtipを定義する。{GTK+と
				Win32 GUIでだけ}

:tm[enu] [menupath]		メニューtipsをリストする。{GTK+とWin32 GUIでの
				み}

"tip"はどのメニュー項目にも定義することができる。例えば、このように項目を定義
した後で:
>	:amenu MyMenu.Hello :echo "Hello"<CR>
tipはこのように定義される:
>	:tmenu MyMenu.Hello Displays a greeting.

tipがメニュー項目に定義されるときには、マウスがその項目の上にあるとき、ステー
タスバーの標準Windowsメニューヒントとほとんど同様、Command-lineエリアに表示さ
れる。(VimがCommand-lineコマンドであるとき、もちろん何も表示されないときを除い
て。)
tipがツールバー項目に定義されるときには、普通の方法で、マウスがそのボタンの上
で一旦止まったとき、ツールtipが表示される。

":tmenu"コマンドは他のメニューコマンドと全く同様に機能し、それは同じ引数を使用
する。

							*:tunmenu* *:tu*
:tu[nmenu] {menupath}		メニューあるいはツールからtipを取り除く。{GTK+
				とWin32 GUIでだけ}

:tunmenuは、他のunmenuコマンドと同じ方法で、存在するメニューtipを削除する。例:
>	:tunmenu MyMenu.Hello
メニュー項目が無効になる(例えば、全てのモードでその動作が削除される)ならば、
Vimはメニューtip(と項目)を削除する。これは:aunmenuがメニュー項目を削除する、つ
まり、同様に:tunmenuする必要はないことを意味する

==============================================================================
6. 付記							*gui-extras*

このセクションはGUIと関係がある他の機能を記述する。

- GUIでは、キーコードは<Esc>で始まらないため、エスケープを打ち込んだ後1秒待た
  なくてよい。

- 用いられた内部の文字列は無意味なので、GUIで特殊キーが後に続く^Vをタイプする
  ことは "<Key>"を挿入するだろう。修飾子もまた"<Modifiers-Key>"を得るために抑
  制されるかもしれない。

- GUIでは、修飾子SHIFT, CTRLとALT(あるいはMETA)は特殊キーとマウスイベントの
  マッピングなしで使用されるかもしれない。例えば: :map <M-LeftDrag> <LeftDrag>

- GUIでは、いくつかの通常のキーはマッピング等で修飾子を持つかもしれない、これ
  らは<Space>, <Tab>, <NL>, <CR>, <Esc>である。

==============================================================================
7. シェルコマンド					*gui-shell*

X11 GUIについては、外部コマンドはgvimウィンドウの中で実行される。|gui-pty|を参
照。

‘警告’: X11 GUIから外部コマンドを実行することは常に機能するとは限らないだろ
う。"ls", "grep"と"make"のような"normal"コマンドはたいていよく機能する。"less"
と"ispell"のような知的ターミナルを要求するコマンドは機能しないだろう。あるもの
はハングさえするかもしれないし、他のターミナルからkillされる必要があるかもしれ
ない。だから気を付けなくてはならない!

Win32 GUIについては、外部コマンドは分離されたウィンドウで実行される。
|gui-shell-win32|を参照。

 vim:tw=78:sw=4:ts=8:ft=help:norl:
