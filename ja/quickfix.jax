COMMENT: クイックフィックス(プログラム開発支援)
STATUS: finish 6.3.054
TRANSLATOR: 村岡太郎 <koron@tka.att.ne.jp>
TRANSLATOR: 青山正太郎(mm) <jod@r9.dion.ne.jp>

*quickfix.txt*  For Vim version 6.3.  Last change: 2004 May 20


		VIMリファレンスマニュアル    by Bram Moolenaar


この話題に関してはユーザーマニュアルの|30.1|でも紹介されている。


1. QuickFixコマンドの使い方		|quickfix|
2. エラーウィンドウ			|quickfix-window|
3. 複数のエラーリストを使う		|quickfix-error-lists|
4. :makeの使い方			|:make_makeprg|
5. :grepの使い方			|grep|
6. コンパイラを選択する			|compiler-select|
7. エラーフォーマット			|error-file-format|
8. ディレクトリスタック			|quickfix-directory-stack|
9. 具体的なエラーファイルフォーマット	|errorformats|

{これらのコマンドはViには存在しない}

コンパイル時に|+quickfix|機能が無効にされた場合は、QuickFixコマンドは使えない。


=============================================================================
1. QuickFixコマンドの使い方			*quickfix* *Quickfix* *E42*

Vimには編集-コンパイル-編集のサイクルを加速するための特別なモードがある。これ
はAmigaのManx's Aztec C compilerにインスパイアされた。Cコンパイラから出力され
たエラーメッセージをファイルに保存し、Vimで一つずつのエラーにジャンプする。全
てのエラーメッセージを覚えることなくそれぞれの問題を検証し、修正することができ
る。

AmigaでManx's Aztec C compilerを使っているなら、Vimと連携させる方法について
|quickfix-manx|を見よ。別のコンパイラを使用するならば、エラーメッセージを一度
ファイルに保存してVimを"vim -q filename"で起動する。これをする簡単な方法の1つ
はコマンド|:make|である(後述)。各コンパイラからのエラーメッセージを解釈させる
ためには、オプション'errorformat'をセットする（下の|errorformat|を参照）。

以下のQuickFixコマンドが使える。

							*:cc*
:cc[!] [nr]		エラー[nr]を表示する。[nr]が省略されると同じエラーが
			再度表示される。[!]が無く、現在のバッファに変更が有り
			ウィンドウが1つしか無く、'hidden'も'autowrite'もoffで
			ある場合には、他のバッファへジャンプする事は無い。
			[!]を使用して他のバッファに移る時、現在のバッファへの
			変更点は、'hidden'がセットされているか別のウィンドウが
			開いているかしない場合、破棄されてしまう。
			バッファ移動の際は設定'switchbuf'が関係してくる。

							*:cn* *:cnext* *E553*
:[count]cn[ext][!]	ファイル名を含むエラーリストで[count]個後のエラーを表
			示する。ファイル名が無かった場合[count]個後のエラーに
			移動する。[!]と'switchbuf'については|:cc|を参照。

:[count]cN[ext][!]			*:cp* *:cprevious* *:cN* *:cNext*
:[count]cp[revious][!]	ファイル名を含むエラーリストで[count]個前のエラーを表
			示する。ファイル名が無かった場合[count]個前のエラーに
			移動する。[!]と'switchbuf'については|:cc|を参照。

							*:cnf* *:cnfile*
:[count]cnf[ile][!]	ファイル名を含むエラーリストで[count]個後のファイルの
                        最初のエラーを表示する。ファイル名が無いか後のファイル
                        が無い場合には、[count]後のエラーに移動する。[!]と
                        'switchbuf'については|:cc|を参照。


:[count]cNf[ile][!]			*:cpf* *:cpfile* *:cNf* *:cNfile*
:[count]cpf[ile][!]	ファイル名を含むエラーリストで[count]個前のファイルの
                        最後のエラーを表示する。ファイル名が無いか後のファイル
                        が無い場合には、[count]個前のエラーに移動する。[!]と
			'switchbuf'については|:cc|を参照。

							*:crewind* *:cr*
:cr[ewind][!] [nr]	[nr]のエラーを表示する。[nr]が省略されると一番最初の
			エラーが表示される。|:cc|を参照。

							*:cfirst* *:cfir*
:cfir[st][!] [nr]	":crewind"と同じ。

							*:clast* *:cla*
:cla[st][!] [nr]	[nr]のエラーを表示する。[nr]が省略されると一番最後の
			エラーが表示される。|:cc|を参照。

							*:cq* *:cquit*
:cq[uit]		Vimをエラーとして終了することで、コンパイラが同じ
			ファイルをコンパイルする事が無くなる。

							*:cf* *:cfile*
:cf[ile][!] [errorfile]	エラーファイルを読みこみ最初のエラーへ移動する。Vimが
			オプション-qで起動された時には自動的に行なわれる。
			コンパイルの間Vimを実行したままにしたい時に使うことが
			できる。エラーファイルの名前を与えればオプション
			'errorfile'に[errorfile]が設定される。[!]については
			|:cc|を参照。

							*:cg* *:cgetfile*
:cg[etfile][!] [errorfile]
			エラーファイルを読み込む。":cfile"に似ているが、最初のエ
			ラーに移動しない。

							*:cl* *:clist*
:cl[ist] [from] [, [to]]
			有効なエラーを全て列挙する|quickfix-valid|。[from]及び
			もしくは[to]で行数を指定された場合、その範囲のエラーが
			表示される。負であった場合最後のエラーから数える。-1
			が最後のエラーとなる。設定'switchbuf'がバッファの移動
			に関係する。

:cl[ist]! [from] [, [to]]
			全てのエラーを表示する。

正しいエラーの位置は隠されたマークによって示されているので、例え行を挿入したり
削除したとしても問題はない(Manx's Z editorではそうではない)。時々マークが幾つ
かの理由で消されてしまう事があり、メッセージ"line changed"がその警告となる。
一度Vimを終了し再起動した場合マークは失われ正しいエラー位置は把握できない。

=============================================================================
2. エラーウィンドウ					*quickfix-window*

							*:cope* *:copen*
:cope[n] [height]	現在のエラーリストを表示するウィンドウを開く。
			[height]が与えられたとき、（余地があれば）ウィンドウの
			高さがその値になる。与えられなければウィンドウの高さは
			10行になる。
			ウィンドウは'buftype'の値が"quickfix"である特別なバッフ
			ァを含んでいる。これを変更してはならない。
			すでにQuickFixウィンドウがある場合はそれがカレントウィ
			ンドウになる。２個目のQuickFixウィンドウを開くことは出
			来ない。
							*:ccl* *:cclose*
:ccl[ose]		QuickFixウィンドウを閉じる。

							*:cw* *:cwindow*
:cw[indow] [height]	認識されたエラーがあるときQuickFixウィンドウを開く。
			ウィンドウがすでに開いていて認識されたエラーがない
			場合はウィンドウを閉じる。

通常、QuickFixウィンドウはスクリーンの一番下に現れる。垂直分割したウィンドウが
ある場合は、一番右下に現れる。常に最大幅を占めるようにさせたい場合は
	:botright cwindow
とする。このウィンドウを|window-moving|コマンドで移動させることもできる。
例えば、一番上に移動させたければCTRL-W Kとする。
'winfixheight'オプションが設定されれば、'winheight'と'equalalways'を無視し、た
いていその高さを維持する。高さを手動で変更することも出来る（例えばステータスラ
インをマウスで上へドラッグするなど）。

QuickFixウィンドウには各行に１個ずつエラーが表示される。その行数はエラー番号に
等しい。":.cc"でカーソル下のエラーに移動できる。<CR>キーを押すのと行をダブルク
リックするのは同じ効果がある。そのエラーを含むファイルがQuickFixウィンドウの上
に開かれる。そのファイルがすでにウィンドウに開かれていたらそのウィンドウがアク
ティブになる。そのウィンドウにあるバッファが変更されていて、そのエラーが別のフ
ァイルにある場合はエラーへの移動は失敗する。まず、そのウィンドウが破棄してもよ
いバッファを含んでいることを確かめなければならない。

QuickFixウィンドウが一杯になったとき、２つの自動コマンドイベントが発生する。第
一は'filetype'オプションが"qf"にセットされ、FileTypeイベントが発生する。それか
らBufReadPostイベントが発生する。これを使ってエラーリストに対して操作を行うこ
とができる。例：
	au BufReadPost quickfix  setlocal nomodifiable
		\ | silent g/^/s//\=line(".")." "/
		\ | setlocal modifiable
これは各行に行番号を追加する。文字列の置換":s"コマンドの中で使われている"\="に
注目。これは式を評価するのに使われる。

注意：QuickFixウィンドウ内で変更を加えてもエラーのリストには何の影響もない。変
更を防ぐために'modifiable'がオフになっている。それでも行を削除や挿入した場合は
、テキストとエラー番号の関係がめちゃくちゃになる。本当にエラーリストを変更した
いのなら、QuickFixウィンドウの内容をファイルに保存し、":cfile"を実行、ファイル
をパースさせ、新しいエラーリストとして使うこと。

=============================================================================
3. 複数のエラーリストを使う			*quickfix-error-lists*

これまでは一つだけのエラーリストがあると仮定してきた。実際は最後に使った10個
迄のエラーリストが記憶される。新しいリストではじめた時には、以前のリストは自動
的に保存される。古いエラーリストにアクセスするために、2つのコマンドが用意され
ている。これらは存在するエラーリストの内１つを現在のエラーリストに設定する。

						*:colder* *:col* *E380*
:col[der] [count]	古いエラーリストへ移動する。[count]が与えられると、
			その回数繰り返し移動する。既に一番古いエラーリストに
			いる場合、エラーメッセージが表示される。

						*:cnewer* *:cnew* *E381*
:cnew[er] [count]	新しいエラーリストへ移動する。[count]が与えられると、
			その回数繰り返し移動する。既に一番新しいエラーリストに
			いる場合、エラーメッセージが表示される。

新しいエラーリストが追加された時には、それがカレントリストとなる。

":colder"が実行された後で":make"や":grep"が実行され新しいエラーリストが追加さ
れたときは１個新しいリストが上書きされる。これは":grep"|grep|でブラウジングし
ているときに特に便利である。もっと最近のエラーリストを残しておきたい場合は初め
に":cnewer 99"を行うこと。

=============================================================================
4. :makeの使い方					*:make_makeprg*

							*:mak* *:make*
:mak[e][!] [arguments]	1. オプション'autowrite'がonならば変更のあるバッファは
			   保存される。
			2. 'makeef'からエラーファイルの名前が生成される。
			   'makeef'が"##"を含まずかつ既に名前が存在する場合
			   それは削除される。
			3. オプション'makeprg'で与えられたプログラム(省略時 
			   "make")が[argument]をオプションにして実行され、
			   出力がerrorfileに保存される(Unixではそれも画面に
			   echoされる)。
			4. 'errorformat'を使ってerrorfileが読みこまれる。
			5. [!]が与えられていないときは最初のエラーに移動する。
			6. エラーファイルが削除される。
			7.|:cnext|や|:cprevious|などのコマンドでエラー間を移動
			できる。上を参照。
			このコマンドは如何なるコメントも受けつけず、どんな "
			という文字もargumentの一部とみなされる。

コマンド":make"はオプション'makeprg'で与えられるコマンドを実行する。これは
オプション'shell'で与えられたシェルにコマンドを渡す事で実行されている。以下を
タイピングするのとほぼ同じである。

	":!{makeprg} [arguments] {shellpipe} {errorfile}".

{makeprg}は'makeprg'オプションで指定された文字列である。"make"に限らず、どんな
コマンドでも使用できる。'%'と'#'の文字は通常通りコマンドライン中で展開される。
拡張子無しの現在ファイル名を表すのに"%<"、拡張子無しの代替ファイル名を表すのに
"#<"が使える。例えば：

   :set makeprg=make\ #<.o

[arguments] ":make"より後に入力した全て。
{shellpipe} オプション'shellpipe'
{errorfile} オプション'makeef'。"##"は一意な名前にする

コマンドがargumentsの後にオプションを必要とするならば、{makeprg}の中で引数リス
トに展開される置換子"$*"が使用できる。$*は引数全てに置換えられる。例:
   :set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}
またはより単純に
   :let &mp = 'latex \\nonstopmode \\input\{$*}'
"$*"は次の例のように何度でも与える事ができる:
   :set makeprg=gcc\ -o\ $*\ $*

オプション'shellpipe'の省略値はAmiga、MS-DOSとWin32では">"である。これはコンパ
イラの出力が直接ファイルに出力されスクリーンには出力されないことを意味する。
Unixでは"| tee"が使用される。コンパイラがファイルに出力すると同時にスクリーン
にも表示される。使っているシェルに応じて標準エラーへの出力も含めるために
"|& tee"や"2>&1| tee"が省略値となる。

'shellpipe'が空の場合、{errorfile}が省略される。これはコンパイラ自身がエラー
ファイルを作成する場合(Manx's Amiga C)に便利である。

==============================================================================
5. :grepの使い方					*grep* *lid*

Vimはコンパイラに対するのと同じ方法（|:make|参照）で"grep"やGNU id-utilsなどの
grepライクなプログラムと連携できる。

[Unix豆知識:Unixのコマンド"grep"の名前は":g/re/p"に由来している。"re"はRegular
 Expression(正規表現)を意味する。]
	
							    *:gr* *:grep*
:gr[ep][!] [arguments]	":make"と同じようにしかし'makeprg'の代りに'grepprg'が
			'errorformat'の代りに'grepformat'が使われる。|grep|
			参照。

							*:grepa* *:grepadd*
:grepa[dd][!] [arguments]
			":grep"と似ているが、新しいエラーリストを作らず、解釈さ
			れたエラーが現在のリストに追加される。
			Example: >
				:grep nothing %
				:bufdo grepadd! something %
			１番目のコマンドは新しい空のエラーリストを作成する。２
			番目のコマンドはバッファリスト内の各バッファに対し
			"grepadd"を実行する。最初のエラーへジャンプするのを避け
			るために!を使っていることに注意。|:bufdo|でジャンプする
			ことはできない。

5.1 grepをセットアップする

標準的な"grep"プログラムがインストールされていれば:grepコマンドはデフォルトの
ままで動くだろう。使い方は標準的なコマンドにとてもよく似ている：

	:grep foo *.c

これは拡張子.cの全てのファイルの中から部分文字列"foo"を検索する。:grepへの引数
はそのまま"grep"プログラムに渡されるので、その"grep"がサポートするオプションは
なんでも使うことができる。

デフォルトでは:grepはgrepを-nオプションつきで呼び出す（これはファイル名と行番号
を出力させる）。これは'grepprg'オプションで変更できる。次のような場合に'grepprg'
を変更する必要があるだろう：

a)	"grep"以外の名前のプログラムを使っているとき
b)	grepをフルパスで呼ばなければならないとき
c)	他のオプションを自動的に渡したいとき(例：大文字・小文字の無視）
			
"grep"が実行されると、Vimはその結果を'grepformat'オプションに従って解釈する。
このオプションは'errorformat'オプションと同様にはたらくので詳細はそちらを参照
すること。あなたのgrepが標準的でない書式で出力したり、あるいは特別な書式を持つ
他のプログラムを使っている場合は'grepformat'をデフォルト値から変更する必要が
あるだろう。

結果が解釈されると、|quickfix|モードにおけるコンパイルエラーと同様に、Vim
はマッチした部分を含む最初のファイルを読み込み、対応した行へジャンプする。その
後は|:cnext|,|:clist|などのコマンドを使って他のマッチにジャンプすることが出来
る。
			
			
5.2 id-utilsと共に:grepを使う

:grepをGNU id-utilsと共に使うにはこのようにする：

	:set grepprg=lid\ -Rgrep\ -s
	:set grepformat=%f:%l:%m

そして
	:grep (regexp)

これで期待通りの動作をする。
（最初にmkidをするのを忘れていなければ）
			

5.3 :grepを使ってソースコードをわたり歩く

Vimが保存するエラーリストのスタックを使うことによって、ファイルをわたり歩き、
関数とその関数が呼んでいる関数を探すことができる。例えば、read_file()関数に引
数を加えたいとする。次のようにコマンドを打てばよい：

	:grep read_file *.c

:cnでマッチのリストを巡り、引数を加えることが出来る。またあるとき上位の関数msg
()から新しい引数を得て、それを変更しなければならないとする。ならばこうするとよ
い：
	:grep msg *.c

msg()関数を変更しているときに、上位から引数を得なければならない関数をもう１個
見つけたとする。ならばその関数を見つけるのにまた":grep"を使えばよい。１つの関
数が終わったら、

	:colder

とすれば１つ前に戻ることができる。

これはツリーをわたるのに似ている：":grep"が１レベル深く進むにつれて、分岐のリ
ストが１つ作られる。":colder"は１つ上に戻る。":grep"と":colder"を使ってツリー
に似た方法ですべての場所をわたることができる。これを一貫して行えば、"todo"のリ
ストを書き留めることなく、すべての場所に行くことができる。

=============================================================================
6. コンパイラを選ぶ					*compiler-select*

						*:comp* *:compiler* *E666*
:comp[iler][!] {name}		コンパイラ{name}を使うときに機能するオプション
				を設定する。"!"オプションがない場合は現在のバ
				ッファに対して設定される。"!"がある場合はグロ
				ーバルオプションが設定される。
				"file.foo"で":compiler foo"とし、その後別のバッ
				ファで":compiler! bar"としたとき、Vimは"file.fo
				o"では"foo"を使い続ける。
				{|+eval|機能なしでコンパイルされた場合には使用
				できない}

"compiler"ディレクトリ内にあるVimプラグインによって、選択されたコンパイラを使
うためのオプションが設定される。":compiler"はローカルオプションを設定し、"compi
ler!"はグローバルオプションを設定する。

							*current_compiler*
Vimの古いバージョンをサポートするために、それらのプラグインは常に"b:current_com
piler"でなく"current_compiler"を使う。このコマンドが実際に行うことは次の通り：

- 変数"current_compiler"と"b:current_compiler"を削除する
- ユーザーコマンド"CompilerSet"を定義する。"!"がついた場合は":set"を行い、"!"が
  無い場合は":setlocal"を実行する。
- ":runtime! compiler/{name}.vim"を実行する。このプラグインは"CompilerSet"に伴
  うオプションを設定し、変数"current_compiler"をそのコンパイラの名前に設定する
  と期待される。
- ユーザーコマンド"CompilerSet"を削除する。
- "b:current_compiler"を"current_compiler"の値に設定する。
- "!"が無い場合は"current_compiler"の元の値を復元する。


コンパイラプラグインを書くためには|write-compiler-plugin|を参照せよ。


MANX AZTEC C				*quickfix-manx* *compiler-manx*

Amiga上でManx's Aztec C compilerとともにVimを使うには次のようにする：
- 環境変数CCEDITを次のコマンドで設定する：
	mset "CCEDIT=vim -q"
- -qfオプションをつけてコンパイルする。もしコンパイラがエラーを見つけたらVimが
  カーソルを最初のエラーの上に置いた状態で起動する。エラーメッセージは最後の行
  に表示される。上で述べたコマンドを使って他のエラーへ移動することができる。エ
  ラーを修正し、ファイルを保存できる。
- Vimを普通に終了するとコンパイラが同じファイルを再コンパイルする。:cqコマンド
  で終了した場合はコンパイラは終了する。エラーを修正できないときや、まず他のフ
  ァイルをコンパイルする必要があるときはそうするとよい。

AmigaにおけるQuickfixモードには他にも制限がある。コンパイラは最初の25個のエラ
ーしか出力しない(Manx'sのドキュメントにはそれ以上出力する方法が書かれていない)
。それ以上のエラーを探したいのならば、幾つかのエラーを修正しエディタを抜ける必
要がある。再コンパイルの後残り25個のエラーが出てくる

Vimがコンパイラから起動された場合、:shやいくつかの:!コマンドは機能しない。Vim
がコンパイラと同じプロセスの中で動いているため、標準出力が利用できないからで 
ある。


PYUNIT COMPILER						*compiler-pyunit*

これは実際にはコンパイラではなく、Python言語用のユニットテストフレームワークで
ある。PYUNITはバージョン2.0からPython標準ディストリビューションに含まれるよう
になった。それより古いバージョンは
http://pyunit.sourceforge.net
で入手できる。

フレームワークの助けを借りてテストを走らせるとき、エラーがあればVimによって解
釈され、QuickFixモードで表示される。

残念ながら、テストを走らせる標準的な方法はない。alltests.pyスクリプトがよく使
われると思われるが、それだけである。
よって、'makeprg'に対する実用的な値は
 setlocal makeprg=./alltests.py " テストスイートを走らせる
 setlocal makeprg=python %      " １つのテストケースを走らせる
となる。

次も参照。
http://vim.sourceforge.net/tip_view.php?tip_id=280.


TEX COMPILER						*compiler-tex*

ディストリビューションに含まれているTeX用のコンパイラスクリプト($VIMRUNTIME/com
piler/tex.vim)は、可能ならmakeコマンドを使う。コンパイラがカレントディレクトリ
に"Makefile"または"makefile"というファイルを見つけたら、*TeXファイルをmakeを使
って処理しようとし、そのmakefile通りの動作をする。この場合コンパイラは'errorfor
mat'を*TeX出力用にセットし、'makeprg'は触らずにそのままにしておく。"Makefie"も"
makefile"も見つからない場合はコンパイラはmakeを使わない。
makefileを無視するように指定することもできる。変数b:tex_ignore_makefileかg:tex_
ignore_makefileを設定すればよい（これらは存在するかのみチェックされる）。

コンパイラがmakeを使わないことになったら、コンパイラは入力を処理するプログラム
を選択する。変数b:tex_flavorかg:tex_flavor（この順で探される）が存在すれば、そ
れが:makeコマンドのためのオプションを定義する。もし両方とも存在しなければ、既
定値"latex"になる。例えば、AMS-TeXで書かれたmypaper.texから\input-ed chapter2.t
exを編集中に

	:let b:tex_flavor = 'amstex'
	:compiler tex
<	[editing...] >
	:make mypaper
	
処理するファイルの名前を引数に指定しなければならないことに注意（\input-edか\inc
lude-edファイルを編集中に正しいファイルを処理するため；%を引数なしに置換するポ
ータブルな方法もよい）。これはソースではなく、ターゲットを指定するというmakeの
意味論ではないが、拡張子".tex"を除いたファイル名を指定してもよい。その場合、
「"filename.dviまたはfilename.pdfまたは filename.some_result_extension 
をメイクしろ」ということを意味する。

注意：tex コマンドライン文法はMikTex(Srinath Avadhanulaによって提案された）とte
TeX(Artem Chuprinaによってチェックされた）の両方で使えるように設定されている。
|errorformat-LaTeX|からの提案は他のシェルやOSで動かせるようにするには複雑すぎる
し、他のTeXオプションを使うことも許さない。もしあなたのTeXが"-interaction=nonst
opmode"をサポートしていなければ、コマンドラインから\nonstopmodeを表現する他の
方法とともにその旨を報告してください。

=============================================================================
7. エラーフォーマット					*error-file-format*

					*errorformat* *E372* *E373* *E374*
						*E375* *E376* *E377* *E378*
'errorformat'オプションは認識されるエラーフォーマットのリストを指定する。その
中からエラーメッセージにマッチした最初のフォーマットが使われる。コンパイラが生
成する異なるメッセージのフォーマット用、あるいは複数のコンパイラに対応するために
複数のフォーマットを加えることができる。|efm-entries|を参照。

'errorformat'の各要素は、scanfに似たフォーマットを記述する文字列である。はじめ
に、scanfがどのようにはたらくか知る必要がある。Cコンパイラのドキュメントを読ん
でください。以下はVimが理解する%の項目である。他は無効になる。

'errorformat'中の特別な文字はコンマとバックスラッシュである。それがどう扱われ
るかは|efm-entries|を参照。"%%"はリテラル"%"にマッチする。よってこれはバック
スラッシュでエスケープしない。

注意：デフォルトでは大文字と小文字の違いは無視される。もし大文字・小文字の区別
をしたいなら"\C"をパターンに付け加える|/\C|。


基本要素

	%f		ファイル名（文字列を検索）
	%l		行番号（数字を検索）
	%c		桁番号（エラーの桁を表す数字（<Tab>1個は1桁と数える））
	%v		画面上の桁番号（エラーの画面上の桁を表す番号（<Tab>1個
			はスクリーン上8桁と数える)
	%t		エラーの種類（1文字を検索）
	%n		エラー番号（数字を検索）
	%m		エラーメッセージ（文字列を検索）
	%r		その行の残り全部 %O/%P/%Q
	%p		ポインタライン（'-', '.', ' 'の列を検索し、その長さを桁
			番号とする）
	%*{conv}	scanfに割り当てられない変換
	%%		1個のリテラル'%'

"%f"の変換は現在の'isfname'の設定に依存する。

変換"%f"と"%m"は文字列の終端を発見しなければならない。よってそれらには文字列
内にあり得ない終端文字が続く必要がある。その終端文字に達するまでの全てがマッチ
文字列に含まれる。注意:"%f%l"はファイル名中の最初の'%'に達するまでの全てを含む
だろう。"%f"や"%m"が行末まで達した場合、その行の終端までの全てが含まれる。

MS-DOS, MS-Windows and OS/2では、"C:"で始まる部分は"%f"に含まれる。"%f:"と指定
したときでもそうなる。これはアルファベット１文字の名前のファイルは検出されない
ことを意味する。

"%p"の後には通常"^"をつける。これは、以下のような出力によってエラーの桁を示す
コンパイラ用に使える：
	    ^
または >
   ---------^
これは複数行のエラーメッセージでも使える。実用的なサンプルとしては
|errorformat-javac|を参照。


ディレクトリを変更する

次の大文字の変換文字は、特別なフォーマット文字列のタイプを指定する。これらのう
ち高々１つをコンマ区切りのフォーマットパターンの先頭につけることができる。
"%f"によって読まれるファイル名の前につけたす必要があるディレクトリ名を出力する
コンパイラがある(例：GNU make）。以下のコードはそれらのディレクトリ名を解釈す
るのに使われる。そのディレクトリ名は内部のディレクトリスタックに保存される。
								*E379*
	%D		"enter directory" フォーマット文字列。これ以下の%fはそ
			のディレクトリ名を検索する。
	%X		"leave directory" フォーマット文字列。これ以下の%fはデ
			ィレクトリスタックの1つ前のディレクトリを検索する。

"enter directory"や"leave directory"フォーマットを定義する場合、"%D"や"%X"は部
分文字列の最初に置かれなけれならない。Vimはディレクトリ変更を追跡し
相対パスによって指定されたファイル名の前にカレントディレクトリ名をつけたす。
Tipsや制限など詳細は|quickfix-directory-stack|を参照。

複数行にわたるメッセージ			*errorformat-multi-line*

複数行メッセージにわたるメッセージを解釈することも可能である。取りうるプリフィ
ックスは：
	%E		複数行エラーメッセージの開始
	%W		複数行警告メッセージの開始
	%I		複数行情報メッセージの開始
	%A		複数行メッセージの開始（種類指定なし）
	%C		複数行メッセージの継続
	%Z		複数行メッセージの終了
これらに対して'+'と'-'をつけることもできる。|efm-ignore|を参照。

例：コンパイラが次のフォーマットでエラーを出力したとする。
（行頭の行番号は実際の出力の一部ではない）：

     1	Error 275
     2	line 42
     3	column 3
     4	' ' expected after '--'

適切なエラーフォーマット文字列はこのようになる：
   :set efm=%EError\ %n,%Cline\ %l,%Ccolumn\ %c,%Z%m

すると、このエラーに対し|:clist|が表示するエラーメッセージはこのようになる：

 1:42 col 3 error 275:  ' ' expected after '--'

別の例：次のエラーメッセージを出力するPythonインタープリタを考える。
（行頭の行番号は実際の出力の一部ではない）：

     1	==============================================================
     2	FAIL: testGetTypeIdCachesResult (dbfacadeTest.DjsDBFacadeTest)
     3	--------------------------------------------------------------
     4	Traceback (most recent call last):
     5	  File "unittests/dbfacadeTest.py", line 89, in testFoo
     6	    self.assertEquals(34, dtid)
     7	  File "/usr/lib/python2.2/unittest.py", line 286, in
     8	 failUnlessEqual
     9	    raise self.failureException, \
    10	AssertionError: 34 != 33
    11
    12	--------------------------------------------------------------
    13	Ran 27 tests in 0.063s

このメッセージに関する情報だけを|:clist|で表示させたいところだろう。
このように：
 5 unittests/dbfacadeTest.py:89:  AssertionError: 34 != 33

そのためにはエラーフォーマット文字列を次のように定義する：
  :set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m

"%C"を"%A"の前に置いていることに注意：' %.%#'（これは正規表現' .*'を意味する）
がスペースで始まるすべての行にマッチするので、それが7行目を以降を隠してくれる
。そうでないと7行目は別のエラーメッセージの始まりと解釈されてしまう。エラーフ
ォーマットは常に、リストの中から1つ1つ、最初のマッチが起こるまで試されていく。


ファイル名を分割する			*errorformat-separate-filename*

1度現れたファイル名を複数のメッセージが参照する場合には、これらのプリフィ
ックスが有効である。
	%O		1行ファイルメッセージ：マッチ部分を読み込む（それ以前に
			記憶されていたものは消去される）
	%P		1行ファイルメッセージ：ファイル%fをスタックにプッシュす
			る。
	%Q		1行ファイルメッセージ：スタックから最後のファイル名をポ
			ップする。

例：次のエラーログファイルを出力するコンパイラがあるとする（行番号は実際の出力
ではない)

     1	[a1.tt]
     2	(1,17)  error: ';' missing
     3	(21,2)  warning: variable 'z' not defined
     4	(67,3)  error: end of file found before string ended
     5
     6	[a2.tt]
     7
     8	[a3.tt]
     9	NEW compiler v1.1
    10	(2,2)   warning: variable 'x' not defined
    11	(67,3)  warning: 's' already defined

このログファイルは[...]で囲まれたファイルに対し複数のメッセージを示している。
これは次のエラーフォーマットで適切に解釈できる：
  :set efm=%+P[%f],(%l\\,%c)%*[\ ]%t%*[^:]:\ %m,%-Q

|:clist|を呼ぶとこれらをファイル名とともに適切に表示してくれる。：
  2 a1.tt:1 col 17 error: ';' missing
  3 a1.tt:21 col 2 warning: variable 'z' not defined
  4 a1.tt:67 col 3 error: end of file found before string ended
  8 a3.tt:2 col 2 warning: variable 'x' not defined
  9 a3.tt:67 col 3 warning: 's' already defined

行全体にマッチする他のプリフィックスとは違い、%P, %Q, %Oは同一行の複数のパター
ンにマッチさせるのに使える。それゆえ、次のようにファイルがネストした場合を解釈
することも出来る：
  {"file1" {"file2" error1} error2 {"file3" error3 {"file4" error4 error5}}}
%Oはファイル名情報のプッシュ・ポップを含まない文字列を解釈する。発展例について
は|errorformat-LaTeX|を参照。


メッセージ全体を無視する・使う				*efm-ignore*

'+','-'は大文字の指定文字と組み合わせて使う。'%+A'や'%-G'のように指定文字の前
につける。
	%-		複数行のマッチを含まない。
	%+		エラー文字列%m中でマッチした行全体

プリフィックス%Gだけは'+'か'-'と組み合わせたときのみ意味を持つ。これはコンパイ
ラバージョンのような一般的な情報を含む行か、無視するべきヘッダを読み込む。
	%-G		このメッセージを無視する
	%+G		一般的なメッセージ


パターンマッチング

古いバージョンのVimとの下位互換性の為にscanf()と同じ"%*[]"という記法がサポート
されている。しかし、フォーマット文字列にVimがサポートするほぼ全ての正規表現を
用いる事も可能である。正規表現言語のメタ文字は普通の文字列やファイル検索の一部
と重なってしまうから(従って内部的にはエスケープされる必要がある)、メタシンボル
は'%'を付加して表記される必要がある:
	%\		単体の'\'という文字。これは":set errorformat="の定義の
			中ではエスケープされて("%\\")書かれなければならない。
	%.		単体の'.'という文字。
	%#		単体の'*'(!)という文字。
	%^		単体の'^'という文字。
	%$		単体の'$'という文字。
	%[		単体の'['という文字。文字の範囲[]のために使われる。
	%~		単体の'~'という文字。
表現の中でキャラクタクラスを使用する場合(概要は|/\i|を参照)、数量子"\+"を含む
語はscanf()の中に"%*"という記法で書くことができる。例:"%\\d%\\+" ("\d\+", 
"どんな数(字)でも")は"%*\\d"と等価である。重要:\(...\)のグループ表現は、内部
変換に使うため予約されているからフォーマット指定内では使用することができない。


'errorformat'内の複数の要素				*efm-entries*

複数のコンパイラからの出力を見つけることを可能にするために、カンマで区切って
複数のフォーマットパターンを'errorformat'に設定することができるだろう(注:
カンマ直後の空白は無視される)。完全にマッチした最初のパターンが採択される。
マッチするものが無い場合、最後にマッチした部分が使われるが、ファイルネームは
除外されエラーメッセージは全体のメッセージとして設定される。複数のコンパイラ
からの出力メッセージにマッチしてしまうパターンがあった(しかし正確には
一致しない)時には、より制限されたもの(訳注:他のメッセージにマッチし難いもの)
の後に置く。パターンの先頭にカンマを含めるにはバックスラッシュ(コマンドset中
では2度タイプするべきだ)を添える。バックスラッシュを含めるためには2つ与える
(つまりコマンドsetの中では4つタイプする)。また、":set"コマンド内のスペースの前
にはバックスラッシュを置く必要がある。


有効なマッチ						*quickfix-valid*


もし'errorformat'に完全には一致しない行が現れた場合、エラーメッセージ全体が
表示され、エントリーは無効とされコマンド":cn"や":cp"使用時にはスキップされる
(有効なエントリーが全く無い場合で無い限り)。エラーメッセージの全てはコマンド
":cl!"で表示する事ができる。

エラーフォーマットがファイル名を含んでいないとVimは正しいファイルへジャンプ
することができない。手動でやる必要がある。


例

Aztec compilerのファイルの書式は:

	ファイル名>行:列:エラータイプ:識別番号:メッセージ

	ファイル名	エラーが見つかったファイルの名前
	行		エラーが見つかった行の通し番号
	列		エラーが見つかった場所の列数(行先頭からの文字数)
	タイプ		エラーの種類、通常は一文字で'E'か'W'
	識別番号	エラーの番号(マニュアルの検索用)
	メッセージ	エラーの説明

これは'errorformat'をこのように設定すればマッチできる：
	%f>%l:%c:%t:%n:%m

単行エラーを出力するCコンパイラのための幾つかの例:
%f:%l:\ %t%*[^0123456789]%n:\ %m	Manx/Aztec C エラーメッセージ
					(scanf()は[0-9]を理解しない)
%f\ %l\ %t%*[^0-9]%n:\ %m		SAS C用
\"%f\"\\,%*[^0-9]%l:\ %m		generic C compilers用
%f:%l:\ %m				GCC用
%f:%l:\ %m,%Dgmake[%*\\d]:\ Entering\ directory\ `%f',
%Dgmake[%*\\d]:\ Leaving\ directory\ `%f'
					GCC with gmake用（行を連結すること！）
%f(%l)\ :\ %*[^:]:\ %m			old SCO C compiler (pre-OS5)
%f(%l)\ :\ %t%*[^0-9]%n:\ %m		idem, エラーの種類と番号つき
%f:%l:\ %m,In\ file\ included\ from\ %f:%l:,\^I\^Ifrom\ %f:%l%m
					いくつかの拡張つきGCC

複数行メッセージを扱うために拡張した例が次の所で与えられる。
|errorformat-Jikes|と|errorformat-LaTeX|を参照。

:setコマンドで使うときにはスペースとダブルクォートの前にバックスラッシュが必要
なことに注意。コンマの前には２つのバックスラッシュを置く。１つは:setコマンド
のため、もう１つはコンマがエラーフォーマットの区切りと認識されるのを避けるため
である。


メッセージをフィルタリングする

もしコンパイラがフォーマットに合わないエラーメッセージを作成する場合、エラー
メッセージをこのフォーマットに変換するプログラムを書く方法もある。その時は
コマンド":make"によって起動されるプログラムオプション'makeprg'を変更することで
指定できる。例:
>  :set mp=make\ \\\|&\ error_filter
パイプ(|)の前のバックスラッシュはコマンドセパレータとして認識されないために
必要。コマンド"set"では空白の前にバックスラッシュが必要。

=============================================================================
8. ディレクトリスタック				*quickfix-directory-stack*

Quickfixはmakeの出力を解釈し、使われたディレクトリ全てをスタックで保持する。
GNU-Makeではディレクトリに入ったり出たりすると常に絶対パスで表示されるので、
これはむしろシンプルである。これはmakefile中のcdコマンドか、起動パラメータ
"-C dir"(makefileの読みこみ前にディレクトリを変更)なのかには因らない。GNU-Make
に強制的に処理の前後にワーキングディレクトリを表示されるためにスイッチ"-w"を
使用するのは便利かもしれない。

GNU-makeを使用しない場合、正しいディレクトリを管理する事はもっと複雑になる。
例えばAIX-makeはワーキングディレクトリに関してなんの情報も表示しない。
よってmakefileに"Making {target} in {dir}"をエコーするような細工が必要となる。
ここにはディレクトリを出る時の情報とその相対パスが表示されないという重要な
問題もある。

パスの関係とメッセージ"leave directory"が現れない問題のためにVimでは次の
アルゴリズムで対処している:

1) 与えられたディレクトリがカレントディレクトリの子か調べる。真ならばそれを
   カレントディレクトリとする。
2) カレントディレクトリの子ディレクトリでなかった場合、上のディレクトリの子
   ディレクトリか(つまり兄弟ディレクトリ)を調べる。
3) まだディレクトリが見つからない場合、これはVimのカレントディレクトリの子
   ディレクトリだと仮定される。

付け加えて、全てのファイルについて認識されたディレクトリに実際に存在するのか調
べられる。もしもなければディレクトリスタックの中の全てのディレクトリ(サブディ
レクトリではない)について探す。これでも見つからなければVimのカレントディレクト
リにあるものと仮定される。

このアルゴリズムには制限がある。この例はmakeがディレクトリに入った時に
"Making all in dir"の形で情報を表示すると仮定している。

1) 次のようなディレクトリとファイルがあったとする
   ./dir1
   ./dir1/file1.c
   ./file1.c

   カレントディレクトリの前にmakeが"./dir1"を処理し"./file1.c"にエラーがあると
   Vimは"./dir1/file.c"をロードしてしまう。

   これはメッセージ"leave directory"があれば解決する事ができる。

2) 次のようなディレクトリとファイルがあったとする
   ./dir1
   ./dir1/dir2
   ./dir2

   次のようになる:

   Makeの出力                     Vimが解釈するディレクトリ
   ------------------------       ----------------------------
   Making all in dir1             ./dir1
   Making all in dir2             ./dir1/dir2
   Making all in dir2             ./dir1/dir2

   これはメッセージ"enter directory"に相対パスが記述されるか、メッセージ
   "leave directory"が表示されれば解決される。

この問題を避けるため、ディレクトリの絶対パスとメッセージ"leave directory"
が表示されるようにすればよい。

Makefileの例:

Unix:
    libs:
            for dn in $(LIBDIRS); do                            \
                (cd $$dn; echo "Entering dir '$$(pwd)'"; make); \
                echo "Leaving dir";                             \
            done

上の出力を取り扱うために
    %DEntering\ dir\ '%f',%XLeaving\ dir
を'errorformat'につけ加える。

注意:Vimはメッセージ"leave directory"の中のディレクトリ名がカレント
ディレクトリかどうかはチェックしない。これが何故メッセージ"Leaveing dir"だけで
良いかの理由だ。

=============================================================================
9. 具体的なエラーファイルフォーマット		*errorformats*

						*errorformat-Jikes*
IBM Researchによって公開されているJavaコンパイラーJikes(TM)はシンプルなマルチ
ラインエラーメッセージを出力する。

このメッセージにマッチする'errorformat'の文字列を下に示す。これをユーザの
|vimrc|に書くことでVimがデフォルトで認識するフォーマットを上書きする事が
できる。またデフォルトに追加インストールする方法は|:set+=|を参照。

  :set efm=%A%f:%l:%c:%*\\d:%*\\d:,
	\%C%*\\s%trror:%m,
	\%+C%*[^:]%trror:%m,
	\%C%*\\s%tarning:%m,
	\%C%m

Jikes(TM)はオプション"+E"とともに起動されたときは１行エラーメッセージを出力す
る。これは次によってマッチできる。

  :set efm=%f:%l:%v:%*\\d:%*\\d:%*\\s%m

						*errorformat-javac*
この'errorformat'は、エラーの桁を示すのに"^"の行を出力するjavac用にうまく動作
すると報告されている：
  :set efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#
または：
  :set efm=%A%f:%l:\ %m,%+Z%p^,%+C%.%#,%-G%.%#
<
						*errorformat-ant*
ant(http://jakarta.apache.org/)用には、各javacの出力行の前につく[javac]を受け
取るために、上のエラーフォーマットを修正しなければならない：
  :set efm=%A\ %#[javac]\ %f:%l:\ %m,%-Z\ %#[javac]\ %p^,%-C%.%#

javacやjikesとantをともに扱うためにこの'errorformat'を調整することができる。jik
esを使っているなら、jikesの+Eコマンドラインスイッチを使うことをantに教えなけれ
ばならない（このスイッチはjikesに１行エラーメッセージを生成させる）。これがbuil
d.xmlファイルの2行目が行っていることである：
  <property name = "build.compiler"       value = "jikes"/>
  <property name = "build.compiler.emacs" value = "true"/>

javac、jikesと組み合わせたantを扱う'errorformat'はこうである：

  :set efm=\ %#[javac]\ %#%f:%l:%c:%*\\d:%*\\d:\ %t%[%^:]%#:%m,
	   \%A\ %#[javac]\ %f:%l:\ %m,%-Z\ %#[javac]\ %p^,%-C%.%#
<
						*errorformat-jade*

jade (http://www.jclark.com/参照)のエラーを解釈するのは簡単である：
  :set efm=jade:%f:%l:%c:%t:%m

						*errorformat-LaTeX*
次のは複数行に渡ってエラーメッセージを表示する(La)TeXタイプセッティング
システム用の'errorformat'文字列を指定する一つの例である。":clist"や":cc"
等々のコマンドは先行する空白を削除して複数行のものを一行にまとめて表示する。
以下のLaTeX用errorformatはマルチラインエラーを出力する他のコンパイラへ応用する
のは簡単だろう。

コマンドは|vimrc|ファイルか別のVimスクリプトファイルに書ける。例えばLaTeXに
関連した内容を含むスクリプトをLaTeXソースの編集時にだけ読みこまれるようにする。
サンプルの全行をコピーしたことを確認する(順番もそのまま)。行の始まりに見ること
のできる'\'の表記は|line-continuation|を参照。

		まず'makeprg'をLaTeXが最初のエラーで止まることなく複数のエラー
		を返すように準備する。
 :set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}

		マルチラインエラーメッセージの始まり:
 :set efm=%E!\ LaTeX\ %trror:\ %m,
	\%E!\ %m,
		マルチライン警告メッセージの始まり;最初の2つは行番号も含んで
		いる。幾つかの正規表現の意味:
		  - "%.%#"  (".*")   文字列(空文字列も含む)にマッチ
		  - "%*\\d" ("\d\+") matches a number >
	\%+WLaTeX\ %.%#Warning:\ %.%#line\ %l%.%#,
	\%+W%.%#\ at\ lines\ %l--%*\\d,
	\%WLaTeX\ %.%#Warning:\ %m,
<		エラー/警告メッセージが続く可能性;最初の一つは行番号も含んで
		いる: >
	\%Cl.%l\ %m,
	\%+C\ \ %m.,
	\%+C%.%#-%.%#,
	\%+C%.%#[]%.%#,
	\%+C[]%.%#,
	\%+C%.%#%[{}\\]%.%#,
	\%+C<%.%#>%.%#,
	\%C\ \ %m,
<		次のパターンにマッチする行には重要な情報は含まれていない;
		よってメッセージに含まないようにする。 >
	\%-GSee\ the\ LaTeX%m,
	\%-GType\ \ H\ <return>%m,
	\%-G\ ...%.%#,
	\%-G%.%#\ (C)\ %.%#,
	\%-G(see\ the\ transcript%.%#),
<		通常、空白文字だけの行は表示しない: >
	\%-G%*\\s,
<		LaTeXの出力ログには個々のライン毎にエラーのあったファイル名が
		特定(記述)されているわけではない;ログのあらゆる所で与えられ、
		括弧にくくられている。
		続くパターンはそれらの名前を取り出し内部スタックに保存しようと
		試みる。パターンは時として一つの行を複数回走査(一つ目を
		見つけた後、同じ行に次のを発見しようと)するので、パターンの
		末尾の"%r"が行の残りの部分が次の試行で解釈の対象になることと、
		行の末尾に達するまでそれが繰り返されることを示す。

		'('...')'でくくられたファイル名を読み飛ばす;明らかにエラーを
		含まないファイルはスタックに積まない: >
	\%+O(%f)%r,
<		ファイル名をスタックに積む。名前は'('の後に与えられる。 >
	\%+P(%f%r,
	\%+P\ %\\=(%f%r,
	\%+P%*[^()](%f%r,
	\%+P[%\\d%[^()]%#(%f%r,
<		')'が見つかったらファイル名をスタックから取り崩す。 >
	\%+Q)%r,
	\%+Q%*[^()])%r,
	\%+Q[%\\d%*[^()])%r

幾つかのケースにおいてLaTeXの出力したログの中のファイル名を正確に取り出す事が
できないことに注意。括弧の対応が正しくつかない時パーサは混乱してしまう。上記の
サンプルはもっとも一般的なケースだけ検出できるようにしてある。目的に合わせて
このサンプルを変える事はできる。例えば全てのいまいましい"Overfull ..."という
警告メッセージがエラーとして認識されてしまう事を防ぐ事ができる。
付け加えてLaTeXコンパイラの出力をフィルタリングするには、[La]TeXコンパイラに
よって生成されるファイル*.logを直接読むことも可能である。これは起こる可能性の
あるエラーについてより便利な情報を沢山含んでいる。しかしそのように複雑な
ファイルを正確に解釈するには、外部フィルタを使うほうが良い。そのようなVimに
識別されるフィルタの作り方はずっと以前に述べたので参照。

						*errorformat-Perl*
$VIMRUNTIME/tools にefm_perl.plスクリプトがある。これはPerlのエラーメッセー
ジをフィルタし、QuickFixモードが理解できるフォーマットに変換する。使い方は
ファイルの先頭を参照。



vim:tw=78:ts=8:ft=help:norl:
