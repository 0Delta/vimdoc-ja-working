COMMENT: 構文強調(テキストの着色)
STATUS: suspend 6.3.54
TRANSLATOR: 村岡太郎 <koron@tka.att.ne.jp>
TRANSLATOR: nakadaira <hopper2@nanameue.jp>
TRANSLATOR: mm

*syntax.txt*	For Vim version 6.3.  Last change: 2004 Jun 04


		VIMリファレンスマニュアル    by Bram Moolenaar


構文強調			*syntax* *syntax-highlighting* *coloring*

Vimは構文強調によりテキストの一部を異なるフォントや色で表示することができるよ
うになる。強調する箇所はキーワードやテキストのパターンにより指定することができ
る。Vimはファイル全体を構文解析するわけではないから(動作を速く保つため)、この
強調方法には限界が存在する。単語(レキシカル)強調と呼ぶのがより正しいが、皆が構
文強調と呼ぶのでそう呼び続けている。

Vimは全ての端末で構文強調をサポートしている。しかし多くの普通の端末には非常に
限られた強調効果しか提供されていないので、強調の最も良い効果はGUI版のgvimで動
作する。

ユーザマニュアルにおける記述:
|usr_06.txt| 構文強調の紹介。
|usr_44.txt| 構文ファイルの記述方法の紹介。

1.  クイックスタート			|:syn-qstart|
2.  構文強調ファイル			|:syn-files|
3.  構文ファイル読込の手順		|syntax-loading|
4.  構文ファイルの覚書			|:syn-file-remarks|
5.  構文を定義する			|:syn-define|
6.  :syntaxの引数			|:syn-arguments|
7.  syntaxのパターン			|:syn-pattern|
8.  クラスタ				|:syn-cluster|
9.  構文ファイルのインクルード		|:syn-include|
10. 表示のシンクロナイズ		|:syn-sync|
11. 構文アイテムのリストを表示する	|:syntax|
12. 強調コマンド			|:highlight|
13. グループのリンク			|:highlight-link|
14. 構文の消去				|:syn-clear|
15. タグの強調				|tag-highlight|
16. カラーxterms			|xterm-color|

{これらのコマンドはViには存在しない}

コンパイル時に|+syntax|機能を無効にした場合には構文強調は利用することはできな
い。

==============================================================================
1. クイックスタート					*:syn-qstart*

						*:syn-enable* *:syntax-enable*
次のコマンドで構文強調が有効になる: >

	:syntax enable

このコマンドにより実際には次のコマンドが実行される >
	:source $VIMRUNTIME/syntax/syntax.vim

環境変数VIMが設定されていない場合は、Vimは別の方法(|$VIMRUNTIME|参照)でパスの
検索を試みる。通常これでうまくいく。もしもうまく動作しない場合、環境変数VIMに
Vimの構成ファイルが置いてあるディレクトリの設定を試みる。例えば、構文ファイル
がディレクトリ"/usr/vim/vim50/syntax"にあるならば、$VIMRUNTIMEに
"/usr/vim/vim50"を設定する。これはVimを起動する前に、シェルで設定しておかなけ
ればならない。

							*:syn-on* *:syntax-on*
コマンド":syntax enable"は現在の色設定を保持する。これによりこのコマンドを使用
する前後にコマンド":highlight"で好みの色を設定することが可能になる。Vimにより
強制的にデフォルトの色を設定させたい場合は次のコマンドを使用する: >
	:syntax on
<
					*:hi-normal* *:highlight-normal*
GUIを使用している場合は、次のコマンドで黒地に白文字を設定できる: >
	:highlight Normal guibg=Black guifg=White
カラー端末については|:hi-normal-cterm|を参照。
独自色の構文強調を設定する方法については|syncolor|を参照。

NOTE: MS-DOSとWindowsの構文ファイルは改行コードが<CR><NL>である。UNIXでは<NL>
である。これは使用しているシステムに合ったタイプのファイルを使わなければならな
いことを意味している。しかしながらMS-DOSとWindowsではオプション'fileformats'が
空でなければ正しい形式が自動的に選択される。

NOTE: 反転表示("gvim -fg white -bg black")を使用する際は、.gvimrcが読込まれた
後で、GUIウィンドウが開かれるまでオプション'background'のデフォルト値が設定さ
れない。そのせいで誤ったデフォルト強調手法が使用されてしまう。強調表示を有効化
する前に'background'のデフォルト値を設定するには、.gvimrcにコマンド":gui"を含
める: >

   :gui		" ウィンドウを開き'background'にデフォルト値を設定する
   :syntax on	" 強調を有効化し、色を設定するのに'background'を使用する

NOTE: .gvimrcの中で":gui"を使用すると"gvim -f"によりフォアグラウンドで開始する
ことができなくなる。その際は":gui -f"を使用すること。


次のコマンドで構文強調の有・無効を切換えることができる >
   :if exists("syntax_on") | syntax off | else | syntax enable | endif

これをキーマップに設定するには、以下の設定を使うことができる: >
   :map <F7> :if exists("syntax_on") <Bar>
	\   syntax off <Bar>
	\ else <Bar>
	\   syntax enable <Bar>
	\ endif <CR>
[|<>|表記を入力する際は、文字通りそのままキー入力する]

詳細
コマンド":syntax"はファイルを取り込むことで実装されている。その際取り込まれる
ファイルの中身を見ることで、このコマンドがどのように動作しているのか正確に知る
ことができる。
    コマンド		ファイル ~
    :syntax enable	$VIMRUNTIME/syntax/syntax.vim
    :syntax on		$VIMRUNTIME/syntax/syntax.vim
    :syntax manual	$VIMRUNTIME/syntax/manual.vim
    :syntax off		$VIMRUNTIME/syntax/nosyntax.vim
|syntax-loading|も参照。

==============================================================================
2. 構文強調ファイル					*:syn-files*

ある1つの言語用の構文と強調色定義コマンドは通常1つのファイル(以下構文ファイル)
に格納される。名前は"{name}.vim"と付ける慣習になっている。{name}はその言語の名
前か短縮名となる(DOSファイルシステムで要求される、8.3文字の形式にあわせること
が望ましい)。
例:
	c.vim		perl.vim	java.vim	html.vim
	cpp.vim		sh.vim		csh.vim

構文ファイルはvimrcファイルと同様にExコマンドを記述することができる。しかし1つ
のファイルには或る1つの言語用コマンドのみを記載するよう取り決めている。ある言
語が別の言語のスーパーセットである時には、他のファイルを内包していても良く、例
えば、ファイルcpp.vimはファイルc.vimを取り込むようになっている: >
   :so $VIMRUNTIME/syntax/c.vim

通常それら構文ファイル*.vimは自動実行コマンドにより読込まれる。例: >
   :au Syntax c	    source $VIMRUNTIME/syntax/c.vim
   :au Syntax cpp   source $VIMRUNTIME/syntax/cpp.vim
通常このようなコマンドはファイル$VIMRUNTIME/syntax/synload.vimに在る。


独自構文ファイルの作成					*mysyntaxfile*

独自の構文ファイルを作成し、そのファイルを":syntax enable"によって自動的にVim
に使わせるようにするには、以下のようにする:

1. ユーザランタイムディレクトリを作成する。通常はオプション'runtimepath'に示さ
   れる最初のディレクトリを使用する。UNIXの例では: >
	mkdir ~/.vim

2. "syntax"という名のディレクトリを作成する。UNIXでは: >
	mkdir ~/.vim/syntax

3. Vimの構文ファイルを作成する。もしくはインターネットからダウンロードする。そ
   のファイルはディレクトリsyntaxに置く。構文"mine"の例では: >
	:w ~/.vim/syntax/mine.vim

これで独自構文ファイルを手動で使うことはできるようになっている: >
	:set syntax=mine
このコマンドを実行するためにVimを再起動する必要はない。

Vimにそのファイル形式を認識させたいならば、|new-filetype|を参照。

システム管理者としてユーザ全てに独自構文ファイルを使わせる際には、各ユーザに同
じ構文ファイルをインストールさせる必要はなく、'runtimepath'に示される他の各
ユーザ共通のディレクトリにインストールすることができる。


既存の構文ファイルに設定を追加する		*mysyntaxfile-add*

既存の構文ファイルでほぼ満足だが、幾つかの設定を追加したり強調手法を変更したい
場合には、以下の手順に従う:

1. 上同様、'runtimepath'に示されるユーザディレクトリを作成する。

2. "after/syntax"というディレクトリを作成する。UNIXの例: >
	mkdir ~/.vim/after
	mkdir ~/.vim/after/syntax

3. 追加設定を行なうコマンドを含むVimスクリプトファイルを作成する。例として、C
   構文の色を変更するならば: >
	highlight cComment ctermfg=Green guifg=Green

4. その設定ファイルをディレクトリ"after/syntax"に置く。名前には構文名に".vim"を
   追加して使用する。Cの構文を拡張するならば: >
	:w ~/.vim/after/syntax/c.vim

以上。次回Cのファイルを編集する時にはコメントが異なった色で表示される。Vimを再
起動する必要はない。


既存の構文ファイルを置き換える				*mysyntaxfile-replace*

配布される構文ファイルが気に入らない場合や、新しいバージョンをダウンロードした
際には、上で述べた|mysyntaxfile|に従えば良い。ただ'runtimepath'内のより先に記
されたディレクトリに構文ファイルを置くように気を付ければ良い。Vimは適合する構
文ファイルのうち最初に見つけた1つだけを読込む。


名前付けの慣習		
							*group-name*
強調や構文グループの名前はアスキー文字、数字、アンダースコアだけでつけなければ
ならない。正規表現では: "[a-zA-Z0-9_]*"

各ユーザが好みの色セットを使用できるように、多くの言語に共通する強調グループに
は優先名が与えられている。推奨されているグループ名は以下のとおり(構文強調がち
ゃんと機能していれば、"Ignore"以外はそのグループに設定された色で表示されるだろ
う):

	*Comment	o コメント

	*Constant	o 定数
	 String		o 文字列定数: "これは文字列です"
	 Character	o 文字定数: 'c', '\n'
	 Number		o 数値定数: 234, 0xff
	 Boolean	o ブール値の定数: TRUE, false
	 Float		o 不動小数点数の定数: 2.3e10

	*Identifier	o 変数名
	 Function	o 関数名(クラスメソッドを含む)

	*Statement	o 命令文
	 Conditional	o if, then, else, endif, switch, その他
	 Repeat		o for, do, while, その他
	 Label		o case, default, その他
	 Operator	o "sizeof", "+", "*", その他
	 Keyword	o その他のキーワード
	 Exception	o try, catch, throw

	*PreProc	o 一般的なプリプロセッサ命令
	 Include	o #include プリプロセッサ
	 Define		o #define プリプロセッサ
	 Macro		o Defineと同値
	 PreCondit	o プリプロセッサの #if, #else, #endif, その他

	*Type		o int, long, char, その他
	 StorageClass	o static, register, volatile, その他
	 Structure	o struct, union, enum, その他
	 Typedef	o typedef宣言

	*Special	o 特殊なシンボル
	 SpecialChar	o 特殊な文字定数
	 Tag		o この上で CTRL-] を使うことができる
	 Delimiter	o 注意が必要な文字
	 SpecialComment	o コメント内の特記事項
	 Debug		o デバッグ命令

	*Underlined	o 目立つ文章, HTMLリンク

	*Ignore		o (見た目上)空白, 不可視

	*Error		o エラーなど、なんらかの誤った構造

	*Todo		o 特別な注意がひつようなもの; 大抵はTODO FIXME XXXなど
			  のキーワード

マーク(*)されている名前が優先グループ、その他はマイナーグループである。優先グ
ループには、"syntax.vim"によりデフォルトの強調手法が定義されている。マイナーグ
ループは優先グループにリンクされ、リンクした先と同じ強調手法になる。ファイル
"syntax.vim"が読込まれた後でコマンド":highlight"を使えば、そのデフォルトを上書
することができる。

強調グループ名には大文字小文字の区別がないことに注意。"String" と "string"はど
ちらも同じグループを意味する。

以下の名前は予約されているのでグループ名として使用することはできない:
	NONE   ALL   ALLBUT   contains   contained

==============================================================================
3. 構文ファイル読込の手順				*syntax-loading*

ここではコマンド":syntax enable"を実行した時に何が起こるかの詳細を説明する。
Vimは初期化の時に、ランタイムファイルの在り処を自動的に発見する。ここでは変数
|$VIMRUNTIME|にその場所が格納されているとする。

":syntax enable" と ":syntax on"では以下のことが起こる:

    $VIMRUNTIME/syntax/syntax.vimを読込む
    |
    +-	$VIMRUNTIME/syntax/nosyntax.vimを読込んで古い構文を削除する
    |
    +-	'runtimepath'から$VIMRUNTIME/syntax/synload.vimを読込む
    |	|
    |	+-  構文強調の色を設定する。
    |	|   カラースキームが定義されている場合は":colors {name}"で再度読込む。
    |	|   そうでない場合は":runtime! syntax/syncolor.vim"が使用される。
    |	|   ":syntax on"は既存の色設定を上書設定し、":syntax enable"はまだ設定
    |	|   されていないグループのみを設定する。
    |	|
    |	+-  適切な構文ファイルをオプション'syntax'が設定される時に読込む自動実
    |	|   行コマンドを設定する。 *synload-1*
    |	|
    |	+-  ユーザによる追加ファイルを変数|mysyntaxfile|から読込む。これは
    |       Vim 5.xとの互換性のためだけに存在する。 *synload-2*
    |
    +-	":filetype on"を実行し":runtime! filetype.vim"が実行される。これは見つ
    |	けることのできる全てのfiletype.vimを読込む。$VIMRUNTIME/filetype.vimは
    |	常に読込まれ、以下のことが実行される。
    |	|
    |	+-  拡張子に基づいてオプション'filetype'を設定する自動実行コマンドをイ
    |	|   ンストールする。これにより既知のファイル形式に付いて、ファイル名と
    |	|   当該形式との関連付けが成される。 *synload-3*
    |	|
    |	+-  ユーザによる追加ファイルを変数 *myfiletypefile* から読込む。これは
    |	|   Vim 5.xとの互換性のためだけに存在する。 *synload-4*
    |	|
    |	+-  ファイル形式が検出されなかった時にscripts.vimを読込むための自動実
    |	|   行コマンドをインストールする。 *synload-5*
    |	|
    |   +-  構文メニュー設定のため$VIMRUNTIME/menu.vimを読込む。 |menu.vim|
    |
    +-	ファイル形式が検出された時にオプション'syntax'を設定するためのFileType
    |	自動実行コマンドを設定する。 *synload-6*
    |
    +-	既に読込まれているバッファに対して構文強調を行なうために、関連した自動
	実行コマンドを実行する。


ファイルを読込む時には、Vimは以下のように関連した構文ファイルを見つける:

    ファイルを読込むとBufReadPost自動実行コマンドが起動する。
    |
    +-	|synload-3|(既知ファイル形式)か|synload-4|(ユーザ定義ファイル形式)の自
    |	動実行コマンドがヒットした場合、オプション'filetype'にそのファイル形式
    |	名が設定される。
    |
    +-	|synload-5|の自動実行コマンドが実行される。まだファイル形式が決定され
    |	ていない場合は、'runtimepath'からscripts.vimが検索される。これは常に以
    |	下のことを行なう$VIMRUNTIME/scripts.vimを読込む。
    |	|
    |	+-  ユーザによる追加ファイルを変数 *myscriptsfile* から読込む。これは
    |	|   Vim 5.xとの互換性のためだけに存在する。 *synload-4*
    |	|
    |	+-  未だにファイル形式が決定できない場合、ファイルの内容を検査する。検
    |	    査は"getline(1) =~ pattern"のように認識できるファイル形式かどうか
    |	    行なわれ、認識できるならば'filetype'を設定する。
    |
    +-	ファイル形式が決定されて'filetype'が設定された時に、上記|synload-6|の
    |	FileType自動実行コマンドが実行される。決定したファイル形式名がそれによ
    |	り'syntax'へ設定される。
    |
    +-	上記でオプション'syntax'が設定されると、|synload-1|(と|synload-2|)の自
    |	動実行コマンドが実行される。これにより次のコマンドでメインとなる構文
    |	ファイルが'runtimepath'から読込まれる。
    |		runtime! syntax/<name>.vim
    |
    +-	ユーザがインストールしたその他のFileTypeおよびSyntax自動実行コマンドが
	実行される。これは特定の構文の強調を変更するのに使うことができる。

==============================================================================
4. 構文ファイルの覚書					*:syn-file-remarks*

						*b:current_syntax-variable*
Vimはロードした構文の名前を変数"b:current_syntax"に記憶している。どの構文が選
択されたかに応じて他の設定を読込みたい時にはこれを使うことができる。例: >
   :au BufReadPost * if b:current_syntax == "csh"
   :au BufReadPost *   do-some-things
   :au BufReadPost * endif


2HTML						*2html.vim* *convert-to-HTML*

これは構文ファイルではなくて、現在のウィンドウの内容をHTMLに変換するスクリプト
である。Vimは新しいウィンドウを作成しそこにHTMLファイルを構築する。

使う際にはオプション'filetype'や'syntax'に"2html"を設定してはならない!
現在のファイルをコンバートするためにはこのスクリプトを読込む: >

	:runtime! syntax/2html.vim
<
	警告: この処理には時間がかかる!

							*:TOhtml*
またはユーザコマンド":TOhtml"を使ってもよい。これは標準プラグイン中で定義され
ている。":TOhtml"は範囲指定やビジュアルモードにも対応している: >

	:10,40TOhtml

出力結果をファイルに保存すれば、あらゆるNetscapeのようなHTML Viewerでそれを観
ることができる。Vimで表示されるのと寸分たがわぬ色が再現される。

変換の範囲を指定するには、"html_start_line"と"html_end_line"をその範囲の最初と
最後に設定すること。例えば、最後に選択された範囲だけを変換するには: >

	:let html_start_line = line("'<")
	:let html_end_line = line("'>")

オプション'number'が設定されている場合には、各行にNumberで強調された行番号が付
加される。"html_number_lines"に非0の値を設定すればHTMLの出力へ強制的に行番号を
付加することができる: >
   :let html_number_lines = 1
値0を設定すれば行番号を強制的に省略することができる: >
   :let html_number_lines = 0
変数を削除すればデフォルトの'number'を使うように戻すことができる: >
   :unlet html_number_lines

デフォルトでは、古いブラウザ用に最適化されたHTMLが生成される。属性を表現するの
にカスケードスタイルシートを使用したい場合には次の設定を使用する(結果的にかな
り短いHTML 4に準拠したファイルが得られる): >
   :let html_use_css = 1

デフォルトでは、テキストの周りに"<pre>"と"</pre>"がつけられる。これによって、
ブラウザでも折り返しをせずに、Vimで表示される通りになる。一部が少々変わっても
いいから折り返しをさせたいなら、次のようにする: >
   :let html_no_pre = 1
こうすると、各行末に<br>を使い、連続するスペースに"&nbsp;"を使うようになる。

HTMLファイルの文字集合の指定には現在の'encoding'の値が使われる。ただしこれは
'encoding'の値が同値なHTML文字集合名を持つ場合だけ機能する。これを上書きするに
は、g:html_use_encodingを使用したい文字集合名にセットすればよい: >
   :let html_use_encoding = "foobar"
文字集合指定の行を省略するには、g:html_use_encodingを空文字列にする: >
   :let html_use_encoding = ""
自動的に判断する設定に戻したいなら、変数g:html_use_encodingを削除する: >
   :unlet html_use_encoding
<
					    *convert-to-XML* *convert-to-XHTML*
代わりにXHTML(XML準拠のHTML)を生成するスクリプトを使うこともできる。そうするに
は変数"use_xhtml"をセットする: > :let use_xhtml = 1
これを無効にするにはこの変数を削除する: >
    :unlet use_xhtml
生成されたXHTMLファイルはDocBook XMLドキュメントで使用できる。次を参照:
	http://people.mech.kuleuven.ac.be/~pissaris/howto/src2db.html

覚書き:
- この機能はGUIをサポートしたバージョンでしか動作しない。(X11などの)GUIが実際
  に機能していない状況でも動作はするが、良い結果は得られない(色が異なってしま
  う)。
- 古いブラウザでは背景色が表示されないことがある。
- 大半のブラウザでは(なんとカラーで)印刷することができる!

ここではUNIXのシェル上で全ての.cと.hをコンバートする方法を例として示す: >
   for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
<

ABEL							*abel.vim* *abel-syntax*

ABELの強調にはユーザが定義できるオプションが幾つかある。それらを有効化するには
それぞれの変数に何か値を設定すれば良い。例: >
	:let abel_obsolete_ok=1
無効化するには":unlet"を使用する。例: >
	:unlet abel_obsolete_ok

変数				強調 ~
abel_obsolete_ok		古いキーワードをエラーでなく命令文として扱う
abel_cpp_comments_illegal	'//'をインラインコメントリーダとして扱わない


ADA							*ada.vim* *ada-syntax*

このモードはオブジェクト指向プログラムや型保護等の機能がサポートされた、Adaの
1995年版("Ada95")を想定して作られている。Ada95で追加されたキーワードを使用して
いるAda83のコード(そのようなコードは修正をすべき)は誤った強調色で表示してしま
うものの、オリジナルのAda言語("Ada83"や"Ada87")で書かれたコードも概ね取り扱う
ことができる。Adaについての詳細はhttp://www.adapower.com/を参照。

Adaモードは多くの状況を綺麗に取り扱う。例えば、"-5"のなかの"-"は数字の一部とし
て認識するが、"A-5"という表記の中の同じ文字は演算子として認識される。通常、他
のコンパイル単位を参照する"with"や"use"節は、Cにおける"#include"と同じ強調色で
表示される。"Conditional"や"Repeat"グループを異なる強調色に設定すれば、"end
if"と"end loop"はそれぞれのグループの強調色で表示される。これらにはコマンド
"highlight"を使って異なる強調色を設定することができる。
(例:ループの色を変えるには":hi Repeat"に続けて強調色指定を続ける; 単純な端末上
ではctermfg=Whiteという指定がしばしば見やすい)

Adaモードではユーザが設定できる幾つかのオプションが存在する。有効化するには、
オプションに値を設定する。あるオプションを有効化する例は: >
   let ada_standard_types = 1
無効化するには":unlet"を使用する。例: >
   unlet ada_standard_types = 1
Adaファイルを読込む前に、コマンドラインで":"とこれらコマンドをキー入力すること
で、設定することができる。ファイルに"~/.vimrc"、コロン(":")を除いて"let"コマン
ドを追加すれば、これらのオプション設定を永続化することができる。

以下、Adaモードのオプションの一覧:

変数			 動作 ~
ada_standard_types       標準パッケージ内の型(例:"Float")を強調表示する
ada_space_errors         余分な空白文字をエラーとして強調表示する…
ada_no_trail_space_error   ただし行末の空白はエラーから除外する
ada_no_tab_space_error     ただしスペース後のタブ文字は除外する
ada_withuse_ordinary     "with"と"use"を通常のキーワードで表示する
			   (これらが他のコンパイル単位への参照として使われた場
			   合には、特別に通常の強調として表示する)。
ada_begin_preproc        beginのようなキーワードの全てをCプリプロセッサ命令同
			   様の強調色を使用して表示する。

このモードは遅いコンピュータ(90MHz)上でも高速に動作するが、もしもパフォーマン
スが受け入れられないほど低いようならば、ada_withuse_ordinaryを有効化する。


ANT						*ant.vim* *ant-syntax*

ANTの構文ファイルにはデフォルトでJavaScriptとPythonの構文強調が含まれている。
関数AntSyntaxScript()の第1引数にタグ名を、第2引数にファイル名を指定することで
その他のスクリプト言語用構文強調をインストールすることができる。例: >

	:call AntSyntaxScript('perl', 'perl.vim')

これは次のようなANTのコードにPerlの構文強調をインストールするものである >

	<script language = 'perl'><![CDATA[
	    # everything inside is highlighted as perl
	]]></script>

スクリプト言語を永続的にインストールするには|mysyntaxfile-add|を参照。


APACHE						*apache.vim* *apache-syntax*

apacheの構文ファイルはHTTPサーババージョンのApache(デフォルトでは1.3.x)に基づ
いた構文強調を提供する。他のバージョン用の構文強調を利用するには
"apache_version"にApacheのバージョンを文字列としてセットする。例: >

	:let apache_version = "2.0"
<

		*asm.vim* *asmh8300.vim* *nasm.vim* *masm.vim* *asm68k*
アセンブリ言語	*asm-syntax* *asmh8300-syntax* *nasm-syntax* *masm-syntax*
		*asm68k-syntax*

"*.i"にマッチする名前のファイルのタイプはProgressかアセンブリである。自動検出
が動作しない場合や、Progressを編集しないことが判っている場合には、起動設定ファ
イルvimrcに次のコマンドを書くことができる: >
   :let filetype_i = "asm"
"asm"には使用するアセンブリ言語の種類を指定する。

ファイル名の同じ拡張子を使用しているアセンブリ言語には沢山の種類がある。従って
ユーザは自分が使用する種類を選択するか、もしくはアセンブリファイルそのものに
Vimがそれと判断できるような行を追加しなければならない。現在は以下の構文ファイ
ルが利用可能:
	asm		GNUアセンブラ(デフォルト)
	asm68k		モトローラ680x0アセンブラ
	asmh8300	日立H-8300用GNUアセンブラ
	ia64		インテルItanium 64
	fasm		Flat アセンブラ (http://flatassembler.net)
	masm		マイクロソフトアセンブラ(たぶん80x86汎用)
	nasm		ネットワイドアセンブラ
	tasm		ターボアセンブラ(80x86,Pentium,MMXの命令コードを含む)
	pic		PICアセンブラ(現在はPIC16F84用)

アセンブリファイルに次のような行を書き加えるのが一番柔軟である: >
	:asmsyntax=nasm
"nasm"は実際に使用するアセンブリ構文の名前に置き換える。このような記述はファイ
ルの先頭5行以内に書いてなければならない。

構文の種類はバッファ変数b:asmsyntaxを設定することで常にそちらが優先される: >
	:let b:asmsyntax=nasm

自動にしろ手動にしろb:asmsyntaxが設定されていないときには、グローバル変数
asmsyntaxが使用される。これによりデフォルトのアセンブリ言語を設定することがで
きる: >
	:let asmsyntax=nasm

最後の手段として、何も設定されていない場合には、"asm"構文が使用される。


ネットワイドアセンブラ(nasm.vim)の補助強調 ~

機能を有効化するには: >
	:let   {variable}=1|set syntax=nasm
無効化するには: >
	:unlet {variable}  |set syntax=nasm

変数			強調内容 ~
nasm_loose_syntax	非オフィシャルな拡張構文をエラーとしない
			  (パーザ依存; 非推奨)
nasm_ctx_outside_macro	マクロ外のコンテキストをエラーとしない
nasm_no_warn		潜在的に危険な構文をToDoとして強調しない


ASPPERLとASPVBS				*aspperl-syntax* *aspvbs-syntax*

*.aspと*.aspという名のファイルはどちらもPerlもしくはVisual Basicのスクリプトた
りえる。Vimにとってこれを判別するのは難しいので、グローバル変数を設定すること
でどちらを使用するのか宣言することができる。どちらでもPerlスクリプトを使用する
なら: >
	:let g:filetype_asa = "aspperl"
	:let g:filetype_asp = "aspperl"
Visual Basicを使用するなら次のように設定する: >
	:let g:filetype_asa = "aspvbs"
	:let g:filetype_asp = "aspvbs"


BASIC				*basic.vim* *vb.vim* *basic-syntax* *vb-syntax*

Visual Basicも「通常の」BASICも、どちらも拡張子には".bas"が使用される。どちら
が使用されているか判別するのに、Vimはファイルの先頭5行以内に"VB_Name"という文
字列が存在するかどうかを検査する。存在しなければ、ファイル形式は"basic"とな
り、そうでなければ"vb"となる。拡張子が".frm"のファイルは常にVisual Basicとして
扱われる。


C							*c.vim* *c-syntax*

Cには幾つかの補助的な強調方法がある。それらを有効化するには対応した変数に値を
設定する。例: >
	:let c_comment_strings=1
これを無効化するには":unlet"を使う。例: >
	:unlet c_comment_strings

変数			強調内容 ~
c_gnu			GNU gcc固有の要素
c_comment_strings	コメント内の文字列と数値
c_space_errors		行末の空白文字とタブ文字前のスペース文字
c_no_trail_space_error	 ... 但し行末の空白文字は除外
c_no_tab_space_error	 ... 但しタブ文字前のスペース文字は除外
c_no_bracket_error	[]の中の{}をエラーとして表示しない
c_no_ansi		ANSI標準の型と定数を強調しない
c_ansi_typedefs		 ... 但し標準ANSI型は強調する
c_ansi_constants	 ... 但し標準ANSI定数は強調する
c_no_utf		文字列中の\uと\Uを強調しない
c_syntax_for_h		ファイル*.hにC++ではなくCの構文を適用する
c_no_if0		"#if 0"のブロックをコメントとして強調しない
c_no_cformat		文字列中の"%"によるフォーマットを強調しない
c_no_c99		C99の標準要素を強調しない

バックスクロール中に強調表示のエラーが生じて、そのエラーが<CTRL-L>の再描画で解
消される場合には、内部変数"c_minlines"にもっと大きな値を設定すれば解消されるか
もしれない: >
	:let c_minlines = 100
これにより構文判定のシンクロナイズ位置が表示開始行の100行手前に設定される。初
期設定の値は50行(c_no_if0を使用した場合は15行)である。ただしこれには、大きな値
を設定すると再描画が遅くなるという短所がある。

"#if 0" / "#endif"のブロックをコメントとして強調している場合には、"#if 0"が
ウィンドウのトップから"c_minlines"以内にある時にしか正しく動作しないことに注意
する。長い"#if 0"のブロックを使用した場合には、それは正しく強調されない。

コメント内で追加要素にマッチを行なうには、クラスタcCommentGroupを使用する。
例: >
   :au Syntax c call MyCadd()
   :function MyCadd()
   :  syn keyword cMyItem contained Ni
   :  syn cluster cCommentGroup add=cMyItem
   :  hi link cMyItem Title
   :endfun

ANSIの定数はグループ"cConstant"で強調される。これには"NULL", "SIG_IGN"やその他
のものが含まれる。しかしANSI標準でないもの、例えば"TRUE"は含まれない。もしもこ
れが紛らわしいならば、cConstant用の強調を削除する: >
	:hi link cConstant NONE

文法上エラーではないはずの'{'と'}'がエラーとして強調されてしまう場合には、
cErrInParen及びcErrInBracketの強調をリセットする。

Cファイルで折り畳みをしたいなら、以下の行を'runtimepath'中の"after"ディレクト
リ内のファイルに加えるとよい。Unixなら~/.vim/after/syntax/c.vimに加えるとよい
だろう: >
    syn region myFold start="{" end="}" transparent fold
    syn sync fromstart
    set foldmethod=syntax


CHILL						*chill.vim* *chill-syntax*

Chillの構文強調はCに似ている。設定に関しては|c.vim|を参照。それに加えて次のも
のがある:

chill_syntax_for_h	use Ch syntax for *.h files, instead of C or C++
chill_space_errors	like c_space_errors
chill_comment_string	like c_comment_strings
chill_minlines		like c_minlines


CHANGELOG				*changelog.vim* *changelog-syntax*
ChangeLogでは行頭のスペースの強調できる。これをオフにしたいなら、次の行を
.vimrcに加える: >
	let g:changelog_spacing_errors = 0
これは次にchangelogファイルを編集するときから有効になる。バッファごとに設定し
たいなら"b:changelog_spacing_errors"が使える(構文ファイルを読み込む前に設定す
ること)。

例えばスペースをエラーとするかどうかなどの強調方法を変えることができる: >
	:hi link ChangelogError Error
強調をやめるには: >
	:hi link ChangelogError NONE
これは即座に有効になる。


COBOL						*cobol.vim* *cobol-syntax*

既存のCOBOLコードに要求される強調方法と、新規に開発されるコードに要求されるそ
れには違いがある。この違いはコードのおかれている状況(保守 vs 開発)やその他の要
素によって決定する。既存コードの強調を行なうには.vimrcに次の行を書き足す: >
	:let cobol_legacy_code=1
それを再び無効にするには次のようにする: >
	:unlet cobol_legacy_code


COLD FUSION				*coldfusion.vim* *coldfusion-syntax*

ColdFusionには独自版のHTMLコメントが存在する。ColdFusionのコメント強調を有効化
するには、次の行を起動設定ファイルに書き足す: >

	:let html_wrong_comments=1

ColdFusionの構文ファイルはHTML用構文ファイルに基づいている。


CSH						*csh.vim* *csh-syntax*

これは"csh"という名前のシェルに対応している。いくつかのシステムでは実際には
tcshが使われていることに注意。

ファイルがcshかtcshかを判定するのは難しいことがよく知られている。いくつかのシ
ステムでは/bin/cshを/bin/tcshにシンボリックリンクしていることが、この判別をほ
ぼ不可能にしている。Vimが間違った判定をする場合には変数"filetype_csh"を設定す
ることが出来る。cshを使うには: >

	:let filetype_csh = "csh"

tcshを使うには: >

	:let filetype_csh = "tcsh"

拡張子がtcshであるか標準的なtcshファイル名(.tcshrc, tcsh.tcshrc, tcsh.login)を
持つスクリプトはすべてtcshファイル形式とされる。他のtcsh/cshスクリプトは、
"filetype_csh"変数が存在しない限り、すべてtcshとみなされる。変数"filetype_csh"
が存在するならファイル形式はその値にセットされる。


CYNLIB						*cynlib.vim* *cynlib-syntax*

Cynlibファイルは、ハードウェアのモデリングとシミュレーションを行なうCynlibクラ
スライブラリを使用したC++ファイルである。通常Cynlibのファイルは.ccや.cppという
拡張子を持つので、CynlibではないC++ファイルと区別するのは非常に困難である。だ
から.ccファイルをCynlibで強調する際には、ファイル.vimrcに次の行を書き足す: >

	:let cynlib_cyntax_for_cc=1

cppファイルについても同様(この拡張子は通常Windowsだけで使用される) >

	:let cynlib_cyntax_for_cpp=1

これらを再び無効にするには次のコマンドを使用する: >

	:unlet cynlib_cyntax_for_cc
	:unlet cynlib_cyntax_for_cpp
<

CWEB						*cweb.vim* *cweb-syntax*

"*.w"にマッチする名前のファイルのタイプはProgressかCWEBである。自動検出が動作
しない場合や、Progressを編集しないことが判っている場合には、起動設定ファイル
vimrcに次のコマンドを書くことができる: >
   :let filetype_w = "cweb"


DESKTOP					   *desktop.vim* *desktop-syntax*

この構文ファイルの本来の目的はfreedesktop.org標準:
http://pdx.freedesktop.org/Standards/の.desktopと.directoryファイルを構文強調
することである。しかし実際にはこの標準を完全に実装したものはほとんどない。なの
でこれは全てのiniファイルを強調する。ただし次をvimrcファイルに書くことによって
厳格に標準に準拠した強調をさせることもできる: >
	:let enforce_freedesktop_standard = 1


DIRCOLORS			       *dircolors.vim* *dircolors-syntax*

dircolorsユーティリティ用の強調定義には、Slackware GNU/Linuxディストリビューシ
ョン版のdircolorsに対応するためのオプションがある。このオプションはほとんどの
バージョンでは無視されるいくつかのキーワードを付け加える。しかしSlackwareシス
テムではdircolorsはこれらのキーワードを認め、処理に用いる。Slackwareキーワード
を有効化するには次を起動設定ファイルに付け加えればよい: >
	let dircolors_is_slackware = 1


DOCBOOK					*docbk.vim* *docbk-syntax* *docbook*
DOCBOOK	XML				*docbkxml.vim* *docbkxml-syntax*
DOCBOOK	SGML				*docbksgml.vim* *docbksgml-syntax*

DocBookファイルには2つの種類: SGMLとXMLがある。どちらのタイプを使用するのかを
指定するには変数"b:docbk_type"をセットする。Vimがそのタイプを認識できた場合に
はこれを自動的に行う。認識できなかった場合にはデフォルトはXMLになる。
これを手動で設定するには: >
	:let docbk_type = "sgml"
または: >
	:let docbk_type = "xml"
これは構文ファイルを読み込む前に行う必要がある。しかし構文ファイルの読み込みは
込み入っている。より単純な方法はファイル形式を"docbkxml"または"docbksgml"にセ
ットすることである: >
	:set filetype=docbksgml
または: >
	:set filetype=docbkxml


DOSバッチファイル			*dosbatch.vim* *dosbatch-syntax*

DOSバッチファイルの強調にはオプションが1つある。このオプションによりWindows
2000で導入されたコマンドインタプリタの新しい拡張機能がカバーされ、変数
dosbatch_cmdextversionによりその有/無効が制御される。Windows NTでは値1を設定
し、Windows 2000では2を設定するのが良い。次のような行で使用するバージョンを選
択できる: >

  :let dosbatch_cmdextversion = 1

変数が定義されていない際のデフォルトはWindows 2000をサポートする2となる。


DTD						*dtd.vim* *dtd-syntax*

初期状態ではDTD構文強調は大/小文字を無視しない。無視する状態にするには、起動設
定ファイルに次の行を書き足す: >

	:let dtd_ignore_case=1

DTD構文ファイルでは未知のタグをエラーとして強調する。これが煩わしいならば、構
文ファイルdtd.vimが読込まれる前に: >

	:let dtd_no_tag_errors=1

と設定することで無効化することができる。定義部内のパラメータのエンティティ名は
強調グループ'Type'、句読点と'%'は'Comment'を使用して強調される。パラメータエン
ティティの実体は強調グループ'Constant'を、区切り文字の%と;は強調グループ'Type'
を使用して強調される。以下を設定するとこれを無効化できる: >

	:let dtd_no_param_entities=1

XML内の埋め込みDTDを強調表示するために、DTDの構文ファイルはxml.vimからも参照さ
れる。


EIFFEL						*eiffel.vim* *eiffel-syntax*

Eiffelは大小文字の区別をしないけれども、スタイルガイドラインが示すように、構文
強調ではそれらが区別される。これにより大小文字が違えば違うクラス名として強調表
示することが可能になっている。大小文字の違いを無視して強調を行なうならば、起動
設定ファイルに次の行を書き足す: >

	:let eiffel_ignore_case=1

これを行なってもコメント内のクラス名とTODOの印には大小文字の区別がなされる。

逆に、もっと厳密に検査するには、次の行のいずれかを書き足す: >

	:let eiffel_strict=1
	:let eiffel_pedantic=1

eiffel_strictを設定すると"Current", "Void", "Result", "Precursor"そして"NONE"
の5つの既定単語について、不正な大小文字の使用を捕捉し、機能やクラス名としてそ
れらが使用されれば警告を与えるようになる。

eiffel_pedanticを設定すると、Eiffelのスタイルガイドラインを相当に厳格に強制す
る。(キーワードを大文字で書く時代遅れの方法と同様に、大小文字を任意にミックス
したようなものが補足される)

"Current", "Void", "Result"そして"Precursor"の小文字版を使用するには、大小文字
を区別する強調方法を無効化する代わりに: >

	:let eiffel_lower_case_predef=1

という方法を使うことができる。

ISEが提案し、実験的に幾つかのコンパイラでは取り扱うことのできる、新しい生成構
文は次のコマンドで使用できるようになる: >

	:let eiffel_ise=1

最後に幾つかのベンダは16進数定数値をサポートしている。それを取り扱うには: >

	:let eiffel_hex_constants=1

この行を起動設定ファイルに書き足す。


ERLANG						*erlang.vim* *erlang-syntax*

これはErlang(ERicsson LANGuage: エリクソン言語)をサポートする構文強調ファイル
である。Erlangは大小文字を区別しデフォルトの拡張子は".erl"である。

キーワード強調を無効化するには、これを.vimrcに書き足す: >
	:let erlang_keywords = 1
組み込み関数強調を無効化するには、これを.vimrcに書き足す: >
	:let erlang_functions = 1
特殊文字の強調を無効化するには、これを.vimrcに書き足す: >
	:let erlang_characters = 1


FORM						*form.vim* *form-syntax*

FORMファイルの構文要素に使用するカラースキームには、Conditional, Number,
Statement, Comment, PreProc, Type, そしてStringが、次の文献で定義される言語仕
様に沿って行なわれる。
文献: 'Symbolic Manipulation with FORM'' by J.A.M. Vermaseren, CAN,
      Netherlands, 1991.

初期設定の色に変更を加えるには、次の構文グループを再定義すれば良い:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

構文ファイルform.vimではFORMプリプロセッサコマンドとディレクティブをそれぞれ、
デフォルトでは同じ構文グループにしていることに注意。

FORM用の既定の拡張カラーモードではヘッダ命令ととFORMプログラム本体での命令を区
別できるような色設定が利用可能である。拡張カラーモードを使用可能にするには、
ファイルvimrcに次の設定を書き足す: >

	:let form_enhanced_color=1

拡張モードを使うことは、gvimで暗いディスプレイを使用した場合にも利点がある。命
令文は黄色ではなく明るい黄色で表示され、条件文は視認性のため明るい青で表示され
る。


FORTRAN					*fortran.vim* *fortran-syntax*

デフォルトの強調と方言 ~
デフォルトではf95(Fortran 95)に相当する強調が行なわれる。Fortran 95はFortran
90のスーパーセットでかつFortran 77のだいたいのスーパーセットであるから、多くの
ユーザにとって多くのケースで適切な選択である。

Fortranソースコードの形式 ~
Fortran 9xのソースコードには固定形式と自由形式が有る。形式が誤って設定されてい
ると構文強調が正しくされないことに注意。

新規にFortranのファイルを作成する場合には、構文ファイルは固定形式であると仮定
する。常に自由形式を使う場合には >
    :let fortran_free_source=1
これを.vimrcでコマンド:syntaxを実行する前に行なう必要がある。常に固定形式を使
うには >
    :let fortran_fixed_source=1
これも.vimrcでコマンド:syntaxを実行する前に行う必要がある。

ソースコードの形式がファイル拡張子によって決定できる場合には、ftpluginファイル
の1つでfortran_free_sourceを設定すると便利になる。ftpluginファイルについての詳
細は|ftplugin|を参照のこと。例えば、拡張子.f90を持つファイルについては全て自由
形式として扱い、それ以外のものは固定形式とする場合には、次のコードをftpluginフ
ァイルに記述すれば良い。 >
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let fortran_free_source=1
	unlet! fortran_fixed_source
    else
	let fortran_fixed_source=1
	unlet! fortran_free_source
    endif
これは.vimrcで"syntax on"より前に"filetype plugin indent on"が書かれていないと
機能しないことに注意。

既存のFortranファイルを編集する時には、変数fortran_free_sourceが設定されていれ
ば構文ファイルは自由形式のソースであると仮定し、変数fortran_fixed_sourceが設定
されていれば固定形式のソースであると仮定する。どちらも設定されていないときには
、ファイルの先頭25行の行頭5カラムを調べて、その形式が固定なのか自由なのかを決
定しようと試みる。自由形式コードの兆候が見られない場合には、ファイルは固定形式
コードとして取り扱われる。このアルゴリズムはほとんどのケースにおいて有効に機能
する。しかしいつかのケース、例えば先頭25行以上が行コメントで占められているよう
なファイルでは、構文ファイルが固定形式コードであると誤った判断をしてしまうだろ
う。そのような場合には、ファイルの先頭25行の行頭5カラムのどこかに、コメント以
外の命令文を追加し、ファイルの保存(:w)そして再読込(:e!)を行なえば良い。

Fortranファイル内のタブ文字 ~
標準のFortranではタブ文字は認識されない。固定カラム位置での境界を必要とする固
定形式のFortranソースコードでTab文字を使用するのは良いアイデアではない。従って
タブ文字はエラーとして強調される。しかしながらプログラマーによってはタブ文字を
使用することを望む場合があるだろう。Fortranファイルにタブ文字が含まれている場
合には、変数fortran_have_tabsをコマンド:syntaxが実行される前に >
    :let fortran_have_tabs=1
このように.vimrcで設定すれば良い。タブ文字を使う場合には残念ながら、構文ファイ
ルによって不正な余白を検出することができなくなる。

Fortranファイルの構文による折畳み ~
foldmethod=syntaxを使用したいならば、まず変数fortran_foldを >
    :let fortran_fold=1
このようなコマンドで設定しなければならない。これにより構文ファイルはプログラム
単位の領域、プログラム命令文で始まるメインプログラム、サブルーチン、関数、
サブプログラム、ブロックデータサブプログラム、そしてモジュールといったプログラ
ム単位の領域で折畳を定義する。同時に変数fortran_fold_conditionalsを >
    :let fortran_fold_conditionals=1
このように設定すると、doループ、ifブロック、そしてselect-case構造の領域が折畳
まれる。さらに変数fortran_fold_multilinecommentsも >
    :let fortran_fold_multilinecomments=1
このように設定すれば3行以上にわたり続くコメントの領域が折畳まれる。大きなファ
イルに対してこのように構文による折畳を使用した場合、非常に遅くなることに注意。

fortran_foldを設定し、fortran_fold_conditionalsか
fortran_fold_multilinecomments(どちらか片方でも両方でも)を設定した場合には、
foldmethod=syntaxを設定してある時に、Vimはファイルを折畳む。2つのプログラム単
位の間にあるコメントや空行は折畳まれない。なぜならそれらは構文によって定義され
るプログラム単位に属していないからである。

より正確なFortranの構文 ~
変数fortran_more_preciseを >
    :let fortran_more_precise=1
このようなコマンドで設定した場合には、構文強調がより正確になるが動作は遅くな
る。とりわけ、do、goto、そして算術if命令文に使用される命令ラベルが、do、if、
selectもしくはforall構造の終端で使用される名前として認識されるようになる。

非標準のFortran方言 ~
構文ファイルは5つのFotranの方言をサポートしている: f95, f90, f77, the Lahey
サブセットの elf90, そして Imagine1 サブセットの F.

f77の拡張機能を使うときには、それがg77(GNU Fortran)を含む多くのコンパイラがサ
ポートしている一般的な、do/enddoループ、do/whileループ、自由形式ソースコード、
拡張機能であるならば、恐らくデフォルトの強調で満足するだろう。しかしながら、拡
張機能を使用せずに厳密なf77を使用する場合や、自由形式やMIL STD 1753の拡張を用
いない場合には問題がある。そのような時に方言としてf77を指定することには、SUMの
ようなf9xの持つ関数として認識されてしまう名前が、ユーザ変数として認識され強調
されないという利点がある。また廃れてしまったASSIGN命令文のような構造も修正用
TODOとしては強調されなくなり、固定形式が仮定されるようになる。

elf90やFを使う場合には適切な方言を設定する。それにより、これらの方言においては
除外されるf90の機能はtodoとして強調され、これらの方言で必要とされる自由形式の
ソースコードが仮定される。

方言は変数fortran_dialectを設定することで選択できる。fortran_dialectに設定でき
る値には大小文字の区別があり"f95"、"f70"、"elf"もしくは"F"である。無効な値を
fortran_dialectへ設定した場合にはそれは無視される。

全てのFortranファイルで同じ方言を使用するならば、.vimrcでsyntax onが実行される
前にfortran_dialectを設定する。方言がファイルの拡張子に依存して決定する場合に
は、ftpluginファイル内で設定するのが最良の手段である。ftpluginファイル付いての
詳細な情報は、|ftplugin|を参照。例、全ての.f90という拡張子のファイルが"elf"サ
ブセットにより書かれているならば、ftpluginファイルに次のようなコードを書き足す
べきである >
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let fortran_dialect="elf"
    else
	unlet! fortran_dialect
    endif 
これは.vimrcで"syntax on"より前に"filetype plugin indent on"が書かれていないと
機能しないことに注意。

拡張子が方言を一意に決定できない場合には、もっと良い制御方法が必要になる。各
ファイルの先頭3行以内にコメントで"fortran_dialect=xx"という命令を書けば方言の
設定を上書することができる(xxにはf77やelfやFやf90やf95が入る)。これによりファ
イル毎に方言を設定できる。例えば、古い.fファイルはf77の拡張を使用して書かれて
いるが、新しい.fファイルがFで書かれている場合には >
  ! fortran_dialect=F
このような形で新しいファイルの先頭3行以内にコメントを追加することで、Fで書かれ
ていることが判別できるようになる。Fとelfの両方が指定された場合には、Fの方が優
先される。

制限事項 ~
丸カッコチェックは、閉じカッコの不足については捕捉できない。ホレリス定数は認識
されない。幾つかのキーワードはFortran90の予約語ではないので誤って強調される。

Fortranに関するその他の情報は|fortran-indent|や|fortran-plugin|を参照。


FVWM CONFIGURATION FILES			*fvwm.vim* *fvwm-syntax*

Vimに*fvwmrc*や*fvwm2rc*などにマッチしないFvwmコンフィギュレーションファイルを
認識させるためには、ファイルmyfiletypefile.vimで適切な追加の認識パターンを設定
しなければならない。このパターンでは変数"b:fvwm_version"にFvwmのメジャーバージ
ョンを指定し、オプション'filetype'にfvwmを設定しなければならない。

以下は/etc/X11/fvwm2/配下のファイルをFvwm2のコンフィギュレーションとして認識さ
せるための追加設定を示している: >

  :au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |
					 \ set filetype=fvwm

有効な色の名前を全てVimに強調させたいならば、システムの色データベース(rgb.txt)
の在り処を知らせる必要がある。設定は変数"rgb_file"に行なう。色データベースが
/usr/X11/lib/X11/にあるとすれば: >

	:let rgb_file = "/usr/X11/lib/X11/rgb.txt"

このような内容をファイル.vimrcに追加する。


GSP							*gsp.vim*

GSPページのデフォルトカラーは|html.vim|にて定義され、Javaコード(Javaタグ内部や
インラインのバッククォート内)のカラーは|java.vim|にて定義される。|html.vim|で
定義される以下のHTMLグループは、インラインJavaコードを挿入したり強調するために
再定義されている:

    htmlString
    htmlValue
    htmlEndTag
    htmlTag
    htmlTagN

書かれた大抵の場所のインラインJavaコードは適切に強調されるが、幾つかの特殊な
ケースではそうはならない。他のHTMLグループ内にインラインJavaコードを書いてそれ
が正しく強調されない場合には、必要な行を|html.vim|からコピーしてgspJavaを
constains節に加えれば、正しく強調されるようになる。

インラインJavaを示すバッククォートは、目立ちやすくするためにhtmlErrorグループ
で強調される。


GROFF						*groff.vim* *groff-syntax*

groff構文ファイルは|nroff.vim|のラッパーであり、使用例と設定例についてはそこの
下書かれている注意を参照。このラッパーの目的は、モードラインか個人用のファイル
定義ファイル(|filetype.txt|参照)からファイル形式をセットすることにより、groff
構文拡張を設定することである。


HASKELL			     *haskell.vim* *lhaskell.vim* *haskell-syntax*

Haskell構文ファイルはプレーンHaskellコードliterate Haskellコード両方をサポート
している。後者はBirdスタイルとTeXスタイル両方に対応している。Haskell用の構文強
調はCプリプロセッサ命令も強調できる。

区切り文字も強調したいなら(明るい背景色を使っているなら便利)、次を.vimrcに書き
足す: >
	:let hs_highlight_delimiters = 1
TrueとFalseを通常の識別子と区別してキーワードとして扱うにはこれを書き足す: >
	:let hs_highlight_boolean = 1
プリミティブ型の名前をキーワードして扱うには: >
	:let hs_highlight_types = 1
より比較的一般的な型の名前をキーワードとして扱うには: >
	:let hs_highlight_more_types = 1
デバッグ関数の名前を強調したいなら、これを.vimrcに書き足す: >
	:let hs_highlight_debug = 1

Haskell用の構文強調はCプリプロセッサ命令も強調し、#で始まるが命令として有効で
ない行をエラーとして警告する。Haskellの演算子の構文は#で始まることもあるため、
これらが干渉する。これらをエラーでなく演算子として強調したいなら、次を.vimrcに
書く: >
	:let hs_allow_hash_operator = 1

literate Haskellコード用の構文強調はファイルがTeXマークアップを含んでいるかど
うか、それに応じてTeX要素を強調するかどうかを自動的に推測しようとする。
.vimrcに次のような行を書くと、これをグローバルに上書きすることができる >
	:let lhs_markup = none
と書くとまったく強調しなくする。または >
	:let lhs_markup = tex
と書くと常にTeXマークアップを強調するように強制する。より柔軟に、この変数のバ
ッファローカル版を使うことも出来る。例. >
	:let b:lhs_markup = tex
と書くと特定のバッファにTeX強調させるようにする。これはそのバッファに構文強調
を有効化するかファイルを読み込む前に設定しなければならない。


HTML						*html.vim* *html-syntax*

HTMLファイルのタグ用の構文ファイルは以下のように動作する。

開きタグの<>は、閉じタグの</>とは異なった色で強調される。これは意図的にそうし
てある!。開きタグには強調'Function'が使用され、閉じタグには強調'Type'が使用さ
れる(どのようにそれらがどのように定義されているかはsyntax.vimを参照)。

既知のタグ名はC命令文と同じように強調される。未知のタグ名は間違いを見分けやす
くするために、<>や</>と同じ強調がなされる。

引数(もしくは属性)名にも同じことが言える。既知の属性名と未知の属性名には異なる
強調がなされる。

幾つかのHTMLタグは表示する文字種を変更するために使用される。以下のタグは構文
ファイルhtml.vimによって認識され、その内容は通常の文字種とは異なる文字種で表示
される: <B> <I> <U> <EM> <STRONG> (<EM>は<I>のエイリアスとして使われ、<STRONG>
は<B>のエイリアス)、<H1> - <H6>、<HEAD>、<TITLE>そして<A>、ただしhrefが含まれ
ていてリンクとして使われている(例<A href="somefile.html">)場合。

それらのテキストの文字種を変更するには、以下の構文グループを再定義する必要があ
る:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlTitle for titles
    - htmlH1 - htmlH6 for headings

この再定義が機能するためには最後の2つを除くすべてを再定義しなければならない。
最後の2つ、htmlTitleとhtmlH[1-6]は任意である。そして次の変数をvimrcで設定しな
ければならない(初期化の際に読み込まれるファイルの順序のせい)。 >
	:let html_my_rendering=1

この例については以下からmysyntax.vimをダウンロードすること。
http://www.fleiner.com/vim/download.html

次の行をvimrcに加えればこの描画を無効にできる: >
	:let html_no_rendering=1

HTMLコメントはむしろ特別で(詳細はHTMLリファレンスドキュメントを参照)、すべての
エラーを強調する。しかしその間違ったスタイル(<!--で始まり--!>で終わる)を使いた
いならこれを定義する >
	:let html_wrong_comments=1

HTMLドキュメント中に埋め込まれたJavaScriptやVisual Basicについては、文は
'Special'で強調され、コメントや文字列などは標準のプログラミング言語と同じよう
に色づけされる。現在のところサポートされているのはJapaScriptとVisual Basicだけ
であり、他のスクリプト言語はまだ加えられていない。

カスケードスタイルシート(CSS)の埋め込みとインラインも強調される。

htmlプロセッサ言語は複数ある。html.vimはインクルードしやすいように簡素に書かれ
ている。html.vimをインクルードするには以下の2行をその言語用の構文ファイルに書
き足すこと(この例はasp.vimからとった): 

    runtime! syntax/html.vim
    syn cluster htmlPreproc add=asp

そしてプリプロセッサ言語を含むすべての領域をクラスタhtmlPreprocに加えればよい。


HTML/OS (by Aestiva)				*htmlos.vim* *htmlos-syntax*

HTML/OS用のカラースキームは以下のように機能する:

デフォルトでは関数名と変数名は同じである。これは、Vimは関数と識別子に異なる色
を指定しないためである。これを変えるには(関数名を違う色にしたいならこうすると
よい)次の行を~/.vimrcに書き加える: >
  :hi Function term=underline cterm=bold ctermfg=LightGray

もちろん好みに応じてctermfgは違う色にしてよい。

HTML/OSに関するもう1つの問題は、ファイルがHTML/OSコーディングであることを示す
特別なファイル形式が存在しないことである。そのため、ファイルを開いた後に次のよ
うにしてHTML/OS構文をオンにしなければならない: >
  :set syntax=htmlos

HTML/OSコードのブロックの開始と終了を示す文字は、それぞれ<<または[[,
>>または]]のどちらであってもよい。


IA64				*ia64.vim* *intel-itanium* *ia64-syntax*

Intel Itanium 64アセンブリ言語用の強調。このファイル形式を認識させる方法につい
ては|asm.vim|を参照。
*.incファイルをIA64と認識させるには次を.vimrcに書き足す: >
	:let g:filetype_inc = "ia64"


INFORM						*inform.vim* *inform-syntax*

Inform構文強調はInform Libraryによって提供されるシンボルを含んでいる。ほとんど
のプログラムがそれを利用しているためである。Libraryのシンボルを強調させたくな
いなら、次をvim初期化ファイルに加える: >
	:let inform_highlight_simple=1

デフォルトではInformプログラムはZ-machineターゲットと仮定され、Z-machineアセン
ブリ言語シンボルが適切に強調される。もしプログラムがGlulx/Glk環境をターゲット
としたものなら、次を初期化ファイルに加える: >
	:let inform_highlight_glulx=1

こうすると代わりにGlulxオペコードを強調し、glk()をシステム関数として強調する。

Informコンパイラはある古いキーワードをエラーとみなす。それらのキーワードは通常
エラーとして強調される。これをエラーとして強調するのをやめるには、次を初期化フ
ァイルに加える: >
	:let inform_suppress_obsolete=1

デフォルトでは強調される言語機能はコンパイラのバージョン6.30とライブラリのバー
ジョン6.11に従う。これより古いInform開発環境を使っているなら、次の行を初期化フ
ァイルに加えるとよいかもしれない: >
	:let inform_highlight_old=1


JAVA						*java.vim* *java-syntax*

The java.vim syntax highlighting file offers several options:

In Java 1.0.2 it was never possible to have braces inside parens, so this was
flagged as an error.  Since Java 1.1 this is possible (with anonymous
classes), and therefore is no longer marked as an error. If you prefer the old
way, put the following line into your vim startup file: >
	:let java_mark_braces_in_parens_as_errors=1

All identifiers in java.lang.* are always visible in all classes.  To
highlight them use: >
	:let java_highlight_java_lang_ids=1

You can also highlight identifiers of most standard java packages if you
download the javaid.vim script at http://www.fleiner.com/vim/download.html.
If you prefer to only highlight identifiers of a certain package, say java.io
use the following: >
	:let java_highlight_java_io=1
Check the javaid.vim file for a list of all the packages that are supported.

Function names are not highlighted, as the way to find functions depends on
how you write java code.  The syntax file knows two possible ways to highlight
functions:

If you write function declarations that are always indented by either
a tab, 8 spaces or 2 spaces you may want to set >
	:let java_highlight_functions="indent"
However, if you follow the Java guidelines about how functions and classes are
supposed to be named (with respect to upper and lowercase), use >
	:let java_highlight_functions="style"
If both options do not work for you, but you would still want function
declarations to be highlighted create your own definitions by changing the
definitions in java.vim or by creating your own java.vim which includes the
original one and then adds the code to highlight functions.

In java 1.1 the functions System.out.println() and System.err.println() should
only be used for debugging. Therefor it is possible to highlight debugging
statements differently. To do this you must add the following definition in
your startup file: >
	:let java_highlight_debug=1
The result will be that those statements are highlighted as 'Special'
characters. If you prefer to have them highlighted differently you must define
new highlightings for the following groups.:
    Debug, DebugSpecial, DebugString, DebugBoolean, DebugType
which are used for the statement itself, special characters used in debug
strings, strings, boolean constants and types (this, super) respectively. I
have opted to chose another background for those statements.

In order to help you to write code that can be easily ported between
java and C++, all C++ keywords are marked as error in a java program.
However, if you use them regularly, you may want to define the following
variable in your .vimrc file: >
	:let java_allow_cpp_keywords=1

Javadoc is a program that takes special comments out of java program files and
creates HTML pages. The standard configuration will highlight this HTML code
similarly to HTML files (see |html.vim|). You can even add javascript
and CSS inside this code (see below). There are four differences however:
  1. The title (all characters up to the first '.' which is followed by
     some white space or up to the first '@') is colored differently (to change
     the color change the group CommentTitle).
  2. The text is colored as 'Comment'.
  3. HTML comments are colored as 'Special'
  4. The special javadoc tags (@see, @param, ...) are highlighted as specials
     and the argument (for @see, @param, @exception) as Function.
To turn this feature off add the following line to your startup file: >
	:let java_ignore_javadoc=1

If you use the special javadoc comment highlighting described above you
can also turn on special highlighting for javascript, visual basic
scripts and embedded CSS (stylesheets). This makes only sense if you
actually have javadoc comments that include either javascript or embedded
CSS. The options to use are >
	:let java_javascript=1
	:let java_css=1
	:let java_vb=1

In order to highlight nested parens with different colors define colors
for javaParen, javaParen1 and javaParen2, for example with >
	:hi link javaParen Comment
or >
	:hi javaParen ctermfg=blue guifg=#0000ff

If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "java_minlines" internal variable
to a larger number: >
	:let java_minlines = 50
This will make the syntax synchronization start 50 lines before the first
displayed line.  The default value is 10.  The disadvantage of using a larger
number is that redrawing can become slow.


LACE						*lace.vim* *lace-syntax*

Lace (Language for Assembly of Classes in Eiffel)は大文字・小文字を無視する。
しかしスタイルガイドラインはそうでない。大文字・小文字を区別して強調させたいな
ら、vim変数'lace_case_insensitive'を初期化ファイル中で定義すればよい: >
	:let lace_case_insensitive=1


LEX						*lex.vim* *lex-syntax*

"^%%$"セクションデリミタが、その後にどんなセクションが続くかの手がかりを与えな
いため、Lexはブルートフォースなシンクロナイズを行う。それゆえ(巨大なlexファイ
ルなどで)同期の問題が起こる場合には: >
	:syn sync minlines=300
の値を変更するとよいかもしれない。


LITE						*lite.vim* *lite-syntax*

lite構文強調には2つのオプションがある。

文字列中でSQL構文強調を行ってほしいならこうする: >

	:let lite_sql_query = 1

シンクロナイズの最小行数はデフォルトで100になっている。他の値に変えたいなら
"lite_minlines"をセットすればよい。例: >

	:let lite_minlines = 200


LPC						*lpc.vim* *lpc-syntax*

LPCはシンプルでメモリ効率的な言語、Lars Pensj| Cの略である。LPCのファイル名は
通常*.cである。これらのファイルをLPCと認識するとCプログラムのみを書くユーザの
迷惑になる。LPC構文を使用したいなら、.vimrcでこの変数をセットすること: >

	:let lpc_syntax_for_c = 1

これでも適切に動作しないCまたはLPCのファイルに対してはモードラインを使うこと。
LPCファイルには:

	// vim:set ft=lpc:

LPCと認識されてしまうCファイルには:

	// vim:set ft=c:

変数をセットしたくないなら全てのLPCファイルでモードラインを使うこと。

LPCには複数の実装がある。我々はもっとも広く使われているものをサポートしたいと
思っている。デフォルトのLPC文法はMudOSシリーズ用である。MudOS v22以前を使って
いるなら、次をセットすることによりsensible モディファイヤをオフにし、v22以降の
新しいefunを無効にするとよい。MudOSの最新版を使っているときはこの変数をセット
しないこと: >

	:let lpc_pre_v22 = 1

LPCのLpMud 3.2シリーズには: >

	:let lpc_compat_32 = 1

LPCのLPC4シリーズには: >

	:let lpc_use_lpc4_syntax = 1

LPCのuLPCシリーズには:
uLPCはPike用に開発されている。なのでPike構文を代わりに使い、ソースファイルの名
前を.pikeとすること。


LUA						*lua.vim* *lua-syntax*

この構文ファイルはLua 4.0とLua 5.0(デフォルト)用に使える。Lua 4.0でプログラミ
ングしているなら、こうする: >

	:let lua_version = 4

変数lua_versionが存在しない場合には5にセットされる。


MAIL								*mail.vim*

Vimはemailの標準的な要素(ヘッダ、シグネチャ、引用文、URL / emailアドレス)の全
てを強調する。標準的な慣習に従い、シグネチャは、"--"とそれに続く任意個の空白、そ
して改行のみからなる行で始まる。

Vimは']', '}', '|', '>'で始まる行または'>'が続く単語を引用文とみなす。
引用文中のヘッダとシグネチャについては、テキストが'>'(1個のスペースが続いても
よい)で引用された場合のみ強調する。

デフォルトではmail.vimは先頭表示行の100行前までの構文をシンクロナイズさせる。
遅いマシンを使っていて、一般的に短いヘッダのemailを扱っているなら、これをより
小さい値に変えることが出来る: >

    :let mail_minlines = 30


MAKE						*make.vim* *make-syntax*

Makefileでは通常エラーを見つけやすくするためにコマンドが強調される。しかし、こ
れは色が多すぎるかもしれない。この機能をオフにするにはこうする: >

	:let make_no_commands = 1


MAPLE						*maple.vim* *maple-syntax*

Waterloo Maple IncによるMaple Vは記号代数をサポートしている。その言語はユーザ
によって選択的にロードされる関数のパッケージをたくさんサポートしている。Maple
V release 4で供給される標準的なパッケージセットの関数がユーザの判断によって強
調される。ユーザは.vimrcに以下を書くと、全てのパッケージ関数が強調される: >

	:let mvpkg_all= 1

あるいは以下の表から任意のサブセット変数／パッケージを選んで.vimrcファイル中で
その変数を1にセットしてもよい($VIMRUNTIME/syntax/syntax.vimを読み込む前に行う
必要がある)。

	Maple V パッケージ関数選択肢の表 >
  mv_DEtools	 mv_genfunc	mv_networks	mv_process
  mv_Galois	 mv_geometry	mv_numapprox	mv_simplex
  mv_GaussInt	 mv_grobner	mv_numtheory	mv_stats
  mv_LREtools	 mv_group	mv_orthopoly	mv_student
  mv_combinat	 mv_inttrans	mv_padic	mv_sumtools
  mv_combstruct mv_liesymm	mv_plots	mv_tensor
  mv_difforms	 mv_linalg	mv_plottools	mv_totorder
  mv_finance	 mv_logic	mv_powseries


MOO						*moo.vim* *moo-syntax*

式の中でCスタイルのコメントを使っていて、それが強調を乱している場合は、Cスタイ
ル用の拡張マッチ(これは遅い!)を使うことが出来る: >

	:let moo_extended_cstyle_comments = 1

文字列中の代名詞置換パターンの強調を無効化したいなら: >

	:let moo_no_pronoun_sub = 1

正規表現演算子'%l'の強調と文字列中の'%('と'%)'のマッチを無効化したいなら: >

	:let moo_no_regexp = 1

対応していないダブルクォートを認識してエラーとして強調することが出来る: >

	:let moo_unmatched_quotes = 1

組み込みプロパティ(.name, .location, .programmerなど)を強調するには :>

	:let moo_builtin_properties = 1

未知の組み込み関数を認識してエラーとして強調することが出来る。このオプションを
使うなら、mooKnownBuiltinFunctionグループに自分自身の拡張を加えること。このオ
プションを有効化するには: >

	:let moo_unknown_builtin_functions = 1

既知の組み込み関数のリストにsprintf()を加える例: >

	:syn keyword mooKnownBuiltinFunction sprintf contained


MSQL						*msql.vim* *msql-syntax*

msql構文強調には2つのオプションがある。

文字列中でSQL構文強調をさせたいならこうする: >

	:let msql_sql_query = 1

シンクロナイズは、minlinesはデフォルトで100になっている。他の値にしたいなら
"msql_minlines"の望む値にすればよい。例: >

	:let msql_minlines = 200


NCF						*ncf.vim* *ncf-syntax*

NCF構文強調には1つのオプションがある。

ncf.vimによって認識されない文をエラーとして強調させたいならこうする: >

	:let ncf_highlight_unknowns = 1

これらをエラーとして強調させたくないなら、この変数をセットしないでおく。


NROFF						*nroff.vim* *nroff-syntax*

nroff構文ファイルはそのままでAT&T n/troffに対応している。構文ファイルに含まれ
ているGNU groff拡張機能を使うには、それを有効化する必要がある。

例えば、LinuxとBSDディストリビューションは、デフォルトではテキスト処理パッケー
ジとしてgroffを使う。groff用の拡張構文強調機能を有効化するには、次のオプション
を初期化ファイルに加える: >

  :let b:nroff_is_groff = 1

groffは、Solarisでまだ使われているかもしれない古いAT&T n/troffとは異なる。
groffのマクロとリクエスト名は2文字以上の長さであってもよく、言語プリミティブに
拡張がされている。例えば、AT&T troffではリクエスト\(yrを使い、2桁の数で年にア
クセスする。groffでは互換性のために同じリクエストを使うことも出来るし、または
groffネイティブの構文,\[yr]を使うことも出来る。さらに、\[year]として4桁の年を
直接使うことも出来る。マクロリクエストは2文字以上の長さであってもよい。例えば
、GNU mmはverbatim環境を作るのに".VERBON"と".VERBOFF"というリクエストを受けつ
ける。

g/troffによって得られる最良の整形された出力を得るには、スペースと句読点に関す
るいくつかの単純なルールに従うべきである。

1. 行の末尾に空のスペースを置かないこと

2. 文末のピリオド、エクスクラメーションマークなどの後にはちょうど1個のスペース
   を置くこと。

3. 後述の理由により、全てのピリオドの後に改行(carriage return)を置くとよい。

これらの妙なtipsの理由は、g/n/troffが改行に、これらのルールに従わないとすぐに
混乱してしまうアルゴリズムを使っているためである。


troffはTeXと違い、段落ごとでなく行ごとにテキストを書き込む。さらに、glueや
stretchの概念を持たず、入力に水平、垂直の空白があると全てそのまま出力される。

それゆえ、最終的なドキュメントで意図する以上の空白を文と文の間にはさまないよう
に注意すること。この理由のため、全ての句読点記号の後すぐに改行を入れるという習
慣がある。最終的に処理された出力が「一様な」テキストになってほしければ、入力の
テキストで正しくスペースを置いておく必要がある。行末の空白と句読点の後の2個以
上の空白をエラーとして強調したいならこうする: >

  :let nroff_space_errors = 1

正しい活字組みと干渉するかもしれないが、余分な空白や他のエラーを検出するもう1
つの方法は、設定ファイル中で構文グループ"nroffDefinition"と"nroffDefSpecial"に
目立つ強調定義を定義することである。例: >

  hi def nroffDefinition term=italic cterm=italic gui=reverse
  hi def nroffDefSpecial term=italic,bold cterm=italic,bold
			 \ gui=reverse,bold

ソースファイル中のプリプロセッサのエントリをセクションマーカーと同じくらい容易
に表示させたいなら、.vimrc中で次のオプションを有効化する: >

	let b:preprocs_as_sections = 1

同様に、構文ファイルはmsパッケージ中の拡張段落マクロ(.XP)用の余分な段落マーカー
も含んでいる。

最後に、構文ファイル|groff.vim|が存在する。これはデフォルトでfile basisとグロ
ーバルの両方でgroff構文強調することができる。


OCAML						*ocaml.vim* *ocaml-syntax*

OCaml構文ファイルは以下の拡張子を持つファイルに対応している: .ml, .mli, .mll
.mly。以下の変数をセットすると、標準的OCaml構文からcamlp4プリプロセッサでサポ
ートされている修正構文に切り替えることが出来る: >

	:let ocaml_revised = 1

以下の変数をセットすると"end"をエラーとして強調するのをやめることが出来る。こ
れはVimがシンクロナイズできないほど長い構造を含むソースのとき便利である: >

	:let ocaml_noend_error = 1


PAPP						*papp.vim* *papp-syntax*

PApp構文ファイルは.pappファイルと、その小さな拡張、トップレベルのファイルフォ
ーマットとしてxmlを用いたperl/xml/html/その他の混合である.pxml, .pxslファイル
を扱う。デフォルトでは、phtmlやpxmlセクションの内側の全ては埋め込みプリプロセ
ッサコマンドつきの文字列として扱われる。次の変数を初期化ファイルで設定すると
phtmlセクションの内側のhtmlコードを構文強調しようとする: >

	:let papp_include_html=1

しかしこれは比較的遅く、実用的に編集するにはカラフルすぎる。

構文ファイルpapp.vimの最新版は、通常以下で得られる。
http://papp.plan9.de


PASCAL						*pascal.vim* *pascal-syntax*

"*.p"にマッチするファイルのタイプはProgressかPascalである。自動判別が機能しな
いなら、またはProgressファイルを一切編集しないとわかっているなら、これをvimrc
ファイルに書くといい: >

   :let filetype_p = "pascal"

Pascal構文ファイルはTurbo Pascal, Free Pascal CompilerとGNU Pascal Compiler
で提供される拡張に対応するための拡張が施されてきた。Delphiのキーワードもサポー
トされている。デフォルトではTurbo Pascal 7.0の機能が有効化されている。標準的な
Pascalのキーワードだけを使いたいなら、次の行を初期化ファイルに加えること: >

   :let pascal_traditional=1

Delphi固有の構文(1行コメント、キーワード等)を有効化したいなら: >

   :let pascal_delphi=1


オプションpascal_symbol_operatorは+, *などのような演算子記号がOperatorの色を使
って表示されるかどうかをコントロールする。演算子記号を色づけするなら、次の行を
初期化ファイルに加えること: >

   :let pascal_symbol_operator=1

いくつかの関数はデフォルトで強調される。これをオフにするには: >

   :let pascal_no_functions=1

さらに、いくつかのコンパイラ用に個別の変数がある。pascal_delphi,
pascal_gpc, pascal_fpcがある。デフォルトの拡張はTurbo Pascalに合うようになって
いる。 >

   :let pascal_gpc=1

または >

   :let pascal_fpc=1

文字列が1行で定義されるものとするなら、変数pascal_one_line_string variableを定
義するとよい。 >

   :let pascal_one_line_string=1

タブ文字が好きでないなら、変数pascal_no_tabsをセットするとよい。するとタブがエ
ラーとして強調される。 >

   :let pascal_no_tabs=1


PERL						*perl.vim* *perl-syntax*

perl用の構文強調にはたくさんのオプションがある。

PODファイルやPODセグメントを使っているなら、こうするとよいかもしれない: >

	:let perl_include_pod = 1

変数名と関数名中のパッケージ参照('$PkgName::VarName'中の'PkgName::'のような)を
他の名前と区別したいなら: >

	:let perl_want_scope_in_variables = 1

'@{${"foo"}}'のように複雑なものをパースさせたいなら: >

	:let perl_extended_vars = 1

文字列の色づけは変更できる。デフォルトでは文字列とqq friendsは第1行と同じよう
に強調される。変数perl_string_as_statementをセットすると第2行のように強調され
る。

   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N	  (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN	  (let perl_string_as_statement)

(^ = perlString, S = perlStatement, N = None at all)

シンクロナイズには3つのオプションがある。最初の2つは、シンクロナイズのトリガー
の一部をオフにするもので、強調が適切に機能しないときのみ必要になる。スクロール
中に突然スクリーン全体の色がすっかり変わってしまったらこれらのうち1つをオフに
してみること。その誤りを引き起こした行を特定できるなら、それを知らせてくださ
い。

1つのトリガーは"^\s*sub\s*"に関するもので、もう1つはほぼ"^[$@%]"に関するもので
ある。 >

	:let perl_no_sync_on_sub
	:let perl_no_sync_on_global_var

以下のようにして、どこから構文強調を始めるかの最大距離を設定できる: >

	:let perl_sync_dist = 100

perlで折りたたみを使いたいならperl_foldをセットすること: >

       :let perl_fold = 1


PHP3 and PHP4		*php.vim* *php3.vim* *php-syntax* *php3-syntax*

[注意: これは以前は"php3"と呼ばれていた。しかし現在はphp4もサポートしているの
で"php"と名前が変更された]

php用の構文強調には以下のオプションがある。

文字列中でSQL構文強調を行いたいなら: >

  let php_sql_query = 1

Baselibメソッドの強調を行いたいなら: >

  let php_baselib = 1

文字列中でHTML構文強調を行いたいなら: >

  let php_htmlInStrings = 1

古いカラースタイルを使いたいなら: >

  let php_oldStyle = 1

ASPスタイルのショートタグを有効化したいなら: >

  let php_asp_tags = 1

ショートタグを無効化したいなら: >

  let php_noShortTags = 1

] や ) の対応エラーを強調したいなら: >

  let php_parent_error_close = 1

対応する閉じ括弧がない開き括弧( や [が存在する場合、php終了タグをスキップさせ
たいなら: >

  let php_parent_error_open = 1

クラスや関数の折り畳みを有効化するには: >

  let php_folding = 1

シンクロナイズ方法を選ぶには: >

  let php_sync_method = x

x = -1 で検索によるシンクロナイズ(デフォルト)
x > 0 少なくともx行上までシンクロナイズ
x = 0 最初からシンクロナイズ


PPWIZARD					*ppwiz.vim* *ppwiz-syntax*

PPWizardはHTMLとOS/2 INFファイル用のプリプロセッサである。

構文ファイルは以下のオプションを持つ:

- ppwiz_highlight_defs : PPWizardの定義についての強調モードを決める。とりうる
  値は

  ppwiz_highlight_defs = 1 : #define 文においてその内容の色を保つ(例. PPWizard
  マクロと変数)

  ppwiz_highlight_defs = 2 : 行継続記号を除き、#defineと#evaluate文が単一の色
  で表示される。

  ppwiz_highlight_defsのデフォルトは1である。

- ppwiz_with_html : この値が1(デフォルト)なら、HTMLコードを強調する。0なら
  HTMLコードを通常のテキストのように扱う。


PHTML						*phtml.vim* *phtml-syntax*

phtml用の構文強調には2つのオプションがある。

文字列中でSQL構文強調をさせたいならこうする: >

	:let phtml_sql_query = 1

シンクロナイズについては、minlinesのデフォルトは100になっている。他の値にした
いなら"phtml_minlines"を望む値にセットすればよい。例: >

	:let phtml_minlines = 200


POSTSCRIPT					*postscr.vim* *postscr-syntax*

PostScript用の構文強調にはいくつかのオプションがある。

第一はどのバージョンのPostScript言語を強調するかである。現在のところ、3つの言
語バージョンあるいはレベルが定義されている。レベル1はオリジナルの基本バージョ
ンで、レベル2のリリース以前のすべての拡張を含んでいる。レベル2はもっとも一般的
なバージョンで、レベル3リリース以前のすべての拡張を含んでいる。レベル3は現在の
ところサポートされている中でもっともレベルが高い。次のように変数postscr_level
を定義することによって、PostScript言語のどのレベルを強調するか選ぶことができる
: >

	:let postscr_level=2

この変数が定義されていないときはデフォルトの2(レベル2)になる。これが現在のとこ
ろもっとも普及しているためである。

すべてのPSインタープリタがその言語レベルのすべての言語機能をサポートしているわ
けではないことに注意。とくに、PSファイルの先頭の%!PS-Adobe-3.0は現在の
PostScriptがレベル3であることを示すわけではない!

以下のように変数postscr_displayを定義すればDisplay PostScriptの言語機能も強調
させることができる: >

	:let postscr_display=1

以下のように変数postscr_ghostscriptを定義すればGhostscript固有の言語機能も強調
させることができる: >

	:let postscr_ghostscript=1

PostScriptはたくさんの定義済み要素を持つ巨大な言語である。これらの要素すべてを
強調するのは便利であるが、そうすると遅いマシンではVimの動作が遅くなってしまう
。マシンフレンドリーにするために、デフォルトではフォント名と文字エンコーディン
グは強調されない、これらを強調させたいなら、以下の変数のどちらかまたは両方をセ
ットすること: >

	:let postscr_fonts=1
	:let postscr_encodings=1

スタイル上のオプションが存在する。PostScriptではこれらの演算子の機能はそれらの
オペランドの型に依存する。オペランドが両方ブール型ならそれらは論理演算子となり
、それらが両方整数型なら2項演算子となる。2項演算子と論理演算子を区別して強調す
ることができるので、それらはどちらにしても強調されなければならない。変数
postscr_andornot_binaryを定義すると、それらは2項演算子として強調される: >

	:let postscr_andornot_binary=1
<

			*ptcap.vim*
PRINTCAP + TERMCAP	*ptcap-syntax* *termcap-syntax* *printcap-syntax*

この構文ファイルはprintcapとtermcapデータベースに適用される。

パターン*printcap*や*termcap*にマッチしないprintcap/termcapファイルを認識する
ためには、ファイル|myfiletypefile|において、あなたのシステムに合ったパターンを
追加しなければならない。これらのパターンには、変数"b:ptcap_type"を"print"か
"term"のどちらかにセットしなければならない。するとオプション'filetype'の値が
ptcapになる。

例えば、/etc/termcaps/以下の全てのファイルをtermcapファイルと識別させるように
するには次を書き加える: >

   :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |
				       \ set filetype=ptcap

上にスクロールしているときに強調間違いが出て、それがCTRL-Lで再描画すると直るよ
うなら、変数"ptcap_minlines"の値を大きくしてみるとよい: >

   :let ptcap_minlines = 50

(デフォルトは20行)


PROGRESS				*progress.vim* *progress-syntax*

"*.w"にマッチするファイルのタイプはProgressかCWEBである。自動判別がうまく機能
しないなら、またはcwebファイルを一切編集しないとわかっているなら、次をvimrcに
加えるとよい: >
   :let filetype_w = "progress"
同じことが"*.i"(アセンブリでもありうる)と"*.p"(Pascalでもありうる)にもいえる。
アセンブリとPascalを使わないとわかっているならこれを使うこと: >
   :let filetype_i = "progress"
   :let filetype_p = "progress"



PYTHON						*python.vim* *python-syntax*

Python構文強調をコントロールするオプションは4つある。

数字の強調: >
	:let python_highlight_numbers = 1

組み込み関数の強調: >
	:let python_highlight_builtins = 1

標準例外の強調: >
	:let python_highlight_exceptions = 1

行末の空白と、スペースとタブの混在を強調: >
	:let python_highlight_space_errors = 1

全ての強調を有効化したければ(これは上の3つのオプションをセットするのと同じ): >
	:let python_highlight_all = 1


QUAKE						*quake.vim* *quake-syntax*

Quake構文定義はQuakeエンジンのどれかに基づくほとんど全てのFPS(First Person
Shooter)用に対応するはずである。しかし3つのゲーム(Quake, Quake 2, Quake 3
Arena)間でコマンド名が少々異なる。そのため、どのコマンドが有効化を指定できるよ
うに構文定義は3つのグローバル変数の存在をチェックする。3つの変数には次のような
効果がある:

Quakeでのみ利用可能なコマンドを強調するように設定: >
	:let quake_is_quake1 = 1

Quake 2でのみ利用可能なコマンドを強調するように設定: >
	:let quake_is_quake2 = 1

Quake 3 Arenaでのみ利用可能なコマンドを強調するように設定: >
	:let quake_is_quake3 = 1

これら3つのコマンドを自由に組み合わせることが出来る。しかしゲームで利用できな
いコマンドも強調してしまうかもしれない。


READLINE				*readline.vim* *readline-syntax*

readlineライブラリは主としてBASHシェルで使われ、BASHはかなりの数のコマンドとオ
プションを追加している。これらの項目を同様に強調するには次を|vimrc|に加えるか
、readline構文ファイルを読み込む前にこれをタイプすればよい: >
	let readline_has_bash = 1

こうするとBASH(バージョン2.05a以降。一部それ以前)が追加するコマンドも強調する
ようになる。


REXX						*rexx.vim* *rexx-syntax*

上にスクロールしているときに強調間違いが出て、それがCTRL-Lで再描画すると直るよ
うなら、変数"rexx_minlines"の値を大きくしてみるとよい: >
	:let rexx_minlines = 50
こうすると構文シンクロナイズが画面最上行の50行前から始まるようになる。値を大き
くすることの欠点は、再描画が遅くなることである。


RUBY						*ruby.vim* *ruby-syntax*

Ruby構文強調にはいくつかのオプションがある。

デフォルトではキーワード"end"はそれに対応するブロック開始文にしたがって色づけ
される。この機能は便利だが、コストがかかる: 再描画が遅くなったら(または色機能
の貧弱なターミナルを使っているなら)変数"ruby_no_expensive"を定義することによっ
てこの機能をオフにできる: >
	:let ruby_no_expensive = 1
この場合すべての制御キーワードに同じ色が使われる。

この機能を有効化したいが、
上にスクロールしているときに強調間違いが出て、それがCTRL-Lで再描画すると直るよ
うなら、変数"ruby_minlines"を50以上の値にセットしてみるとよい: >
	:let ruby_minlines = 100
理想的にはこの値はファイル中の最も大きいクラスやモジュールの長さよりも大きくし
ておくとよい。

最後に、色をつける単語をもっと少なくしたいなら"ruby_no_identifiers"を定義する
ことが出来る: >
	:let ruby_no_identifiers = 1
こうすると"ConstantName", "$global_var", "@instance_var", "| iterator |",
":symbol".のような特別な識別子の強調をやめる。


SDL						*sdl.vim* *sdl-syntax*

SDL用の強調にはいくつかのキーワードが抜けているかもしれない。しかしSDLにはたく
さんのキーワードがあるので、すべてに対応することはほとんど不可能である。

新しい標準SDL-2000ではすべての識別子の大文字・小文字が区別される(以前はそうで
はなかった)。また、すべてのキーワードが全部大文字または全部小文字であってもよ
い。構文強調にこれを反映させるには次の変数をセットすればよい: >
	:let sdl_2000=1

これはたくさんの新しいキーワードもセットする。古いキーワードを無効にするには(
これはよい考えである)こうする: >
	:let SDL_no_96=1

インデントもおそらく不完全であるが、今のところ私はこれでとても満足している。


SED						*sed.vim* *sed-syntax*

タブをTodoと同じようにハイライトさせ、通常の空白から目立つようにさせるには
次の行をvimrcに書き、"highlight_sedtabs"を定義する >

	:let highlight_sedtabs = 1

(この特別な強調は検索パターン中、置換テキスト、アドレス、Append/Change/Insert
コマンドに含まれるテキスト内のタブにだけ適用される)。このオプションを有効化す
るなら、タブ幅を1文字にするとよい; そうすると文字列中のタブの数を数えやすくな
る。

バグ:

  変換コマンド(y)は置換コマンドとまったく同様に扱われる。つまり、この構文ファ
  イルにおいては、変換は置換と同じフラグを受け取ると判断される。これは間違いで
  ある(変換は一切フラグを受け取らない)。これに関係したコマンドは非常に複雑な処
  理を要求するため(95パターン、もっともらしいパターンデリミタごとに1つ)、私は
  このバグを容認している。


SGML						*sgml.vim* *sgml-syntax*

SGMLファイル中のタグを強調する方法は以下のように動作する。

開きタグ<>と閉じタグ</>は異なる色がつけられる。これは意図されたものである。開
きタグには'Function'の色が使われ、閉じタグには'Type'の色が使われる(これらがど
う定義されているかを確かめたいならsyntax.vimを見ること)。

登録されているタグ名はCの文と同じ方法で色づけされる。エラーを見つけやすくする
ため、登録されていないタグ名は色づけされない。

引数名(や属性名)も同様である。登録されている属性名は登録されていない属性名と異
なる色がつけられる。

いくつかのSGMLタグはテキストの外見を変更するのに使われる。以下のタグは構文ファ
イルsgml.vimによって認識され、通常のテキストの表示法を変更する:
 <varname> <emphasis> <command> <function> <literal> <replaceable> <ulink>
 <link>。

そのテキストの表示法を変えたいなら以下の構文グループを再定義しなければならない
: 
    - sgmlBold
    - sgmlBoldItalic
    - sgmlUnderline
    - sgmlItalic
    - sgmlLink for links

この再定義を機能させるにはこれらすべてを再定義し、以下の変数をvimrc中で定義し
なければならない(初期化の際にファイルが読み込まれる順序のため) >
   let sgml_my_rendering=1

この表示法を無効にしたければ次の行をvimrcに加える: >
   let sgml_no_rendering=1

(Claudio Fleiner <claudio@fleiner.com>によるhtml.vimのヘルプテキストから一部借
用した)


SH						*sh.vim* *sh-syntax*

これは「普通の」Unix (Bourne) sh、bashそしてKornシェルをカバーしている。

Vimは様々なファイル名がどのタイプであるかを指定することによって、どのシェルが
使われているかを決定しようとする: >

    ksh : .kshrc* *.ksh
    bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash
<
これらのうちどれにも当てはまらなければ、ファイルの第一行によって判断される(例.
/bin/sh /bin/ksh /bin/bash)。第一行でシェルを指定されていれば、そのシェルが使
用される。しかしいくつかのファイル(例. .profile)はシェルファイルであることはわ
かっていても、どのタイプか明らかではない。さらに、多くのシステムでshは
"bash"(linux)や"ksh"(posix)へのシンボリックリンクになっている。

以下の3つの変数のどれかを.vimrcで定義することにより、デフォルトを設定すること
が出来る:

    ksh: >
	let is_kornshell = 1
<   bash: >
	let is_bash	 = 1
<   sh: >
	let is_sh	 = 1

.vimrcで以下のように設定すると >
	let g:sh_fold_enabled= 1

様々な構文要素(ヒアドキュメントと関数の中身)がsyntaxメソッドによって折り畳み可
能になる(|:syn-fold|)。

上にスクロールしているときに強調間違いが出て、それがCTRL-Lで再描画すると直るよ
うなら、変数"sh_minlines"の値を大きくしてみるとよい。例: >

	let sh_minlines = 500

こうすると構文シンクロナイズが画面最上行の500行前から始まるようになる。デフォ
ルトの値は200である。大きい値を使うことの欠点は、動作が遅くなるかもしれないこ
とである。

シンクロナイズさせるものがあまりないときは表示がとても遅くなるかもしれない。こ
れを減らすために、変数"sh_maxlines"をセットすることができる。例: >

	let sh_maxlines = 100
<
デフォルトはsh_minlinesの2倍の値が使われる。表示を高速化するにはこれをもっと小
さい値にすること。欠点は強調間違いが出るかもしれないことである。


SPEEDUP (AspenTech plant simulator)		*spup.vim* *spup-syntax*

Speedup構文ファイルにはいくつかのオプションがある:

- strict_subsections : この変数が定義されていると、セクションとサブセクション
  用のキーワードだけが文として強調され、他のキーワードにはされなくなる
  (OPERATIONセクションのWITHINと同様)。

- highlight_types : この変数が定義されていると、温度や圧力のようなストリーム
  型が単純な識別子でなくTypeとして強調される。Includedは通常DECLAREセクション
  中に現れる型である;ユーザが自分用の型を定義しているならそれらを構文ファイル
  に含めなければならない。

- oneline_comments : この値は1から3までの間になり、#スタイルのコメントの強調を
  決定する。

  oneline_comments = 1 : 偶数個の#の後にも通常のSpeedupコードが現れることを許す

  oneline_comments = 2 : 2番目の#で始まるコードをエラーとして表示する。これが
  デフォルトの設定である。

  oneline_comments = 3 : 1個以上の#を含む行全体をエラーとして強調する。

変数をPRESETするため、OPERATIONセクションはとても大きくなりがちであり、それゆ
えシンクロナイズがぎりぎりになりかもしれない。あなたのコンピュータが十分はない
なら構文ファイルの最後近くminlinesとmaxlinesの値を大きくするとよいかもしれな
い。


TCSH						*tcsh.vim* *tcsh-syntax*

これは"tcsh"という名前のシェルをカバーしている。これはcshのスーパーセットであ
る。ファイル形式がどのように判定されるかは|csh.vim|を参照。

tcshはシェル変数"backslash_quote"をセットしていない限り文字列中に\"が現れるこ
とを許さない。Vimにバックスラッシュクォート構文が存在しないと判断させたいな
ら、次の行を.vimrcに加えること: >

	:let tcsh_backslash_quote = 0

は上にスクロールしているときに強調間違いが出て、それがCTRL-Lで再描画すると直る
ようなら、変数"tcsh_minlines"の値を大きくしてみるとよい: >

	:let tcsh_minlines = 100

こうすると構文シンクロナイズが画面最上行の100行前から始まるようになる。大きな
値にすることの欠点は、再描画が遅くなることである。


TEX						*tex.vim* *tex-syntax*

追い込みコメント/Math? ~

tex用の構文強調はTeX, LaTeX, AmsTeXをサポートしている。normal, texZone,
texMathZoneの3つの主な区間がサポートされている。これらの区域を適切に区切るよう
かなりの努力がされたが、$..$と$$..$$で線引きされる区間は開始・終了のパターンと
まったく同じにシンクロナイズさせることは出来ない。その結果、特別な"TeX
comment"が提供されている >
	%stopzone
このコメントがあるとここで強制的にtexZoneまたはtexMathZoneの強調を終わらせる。

構文強調が遅い? ~

遅いコンピュータを使っているなら、これらの値を減らすとよいかもしれない >
	:syn sync maxlines=200
	:syn sync minlines=50
(特に後者を)。速いコンピュータを使っているならこれらの値を増やしてもよい。これ
らは第一にシンクロナイズ(つまり、画面最上行のテキストがどのグループに入るか)に
影響を与える。

過度なエラー強調? ~

<tex.vim>は様々な種類のレキシカルエラーチェックをサポートしている。すなわち、
エラーチェックは暇なときにはとても便利だが、実際にはエラーでない箇所もエラーと
示すかもしれない。それが嫌なら、次の行を<.vimrc>に置くとよい: >
	let tex_no_error=1
すると<tex.vim>によるすべてのエラーチェックが停止される。

新しいMathグループが必要? ~

新しいmathグループをLaTeXに含めたいなら、以下のコードがそうする例である: >

    syn cluster texMathZones add=texMathZoneLOCAL
    syn region texMathZoneLOCAL start="\\begin\s*{\s*LOCALMATH\s*}"
       \ end="\\end\s*{\s*LOCALMATH\s*}" keepend
       \ contains=@texMathZoneGroup
    if !exists("tex_no_math")
     syn sync match texSyncMathZoneLOCAL grouphere texMathZoneLOCAL
       \ "\\begin\s*{\s*LOCALMATH\*\s*}"
     syn sync match texSyncMathZoneLOCAL groupthere NONE
       \ "\\end\s*{\s*LOCALMATH\*\s*}"
    endif
    hi link texMathZoneLOCAL texMath
<
LOCALMATHをあなたが決めた新しいmathグループに書き換える必要がある。そしてこれ
を.vim/after/syntax/tex.vimに加えること。

新しいスタイルを始める? ~

*.texファイルで"\makeatletter"を使う人がいるかもしれないので、コマンド中で"@"
が使えるようになっている。しかし*.texファイルは次の拡張子: sty cls clo dtx ltx
を持たないので@をエラーと判断して強調する。これを解決するにはこうする: >

	:let b:tex_stylish = 1
	:set ft=tex

"let g:tex_stylish=1"を<.vimrc>に書くと<syntax/tex.vim>は常にこのような@の使用
法を受け入れるようになる。


TF						*tf.vim* *tf-syntax*

tfの構文強調には1つのオプションがある。

シンクロナイズについて、minlinesのデフォルトは100になっている。他の値にしたい
なら、"tf_minlines"を望む値にセットすればよい。例: >

	:let tf_minlines = your choice


VIM						*vim.vim* *vim-syntax*

より正確な構文強調と画面更新速度にはトレードオフがある。正確さを向上させるには
、変数g:vim_minlinesの値を大きくすればよい。変数g:vim_maxlinesは画面更新速度を
改善するのに使える(これについては|:syn-sync|を参照)。

	g:vim_minlines : シンクロナイズの最小行数をセットするのに使う
	g:vim_maxlines : シンクロナイズの最大行数をセットするのに使う 

g:vimembedscriptオプションは外部スクリプト言語(現在のところperl, python, ruby,
tcl)のサポートを犠牲にする代わりに、vimスクリプト用の構文強調の読み込みをいく
らか速くすることができる。

	g:vimembedscript == 1 (デフォルト)	 <vim.vim>埋め込みスクリプト言
	g:vimembedscript が存在しない		 語: perl, python, ruby, tclの
						 強調を有効化する。

	g:vimembedscript == 0			 埋め込みスクリプト言語用の構
						 文強調を読み込まない。


XF86CONFIG				*xf86conf.vim* *xf86conf-syntax*

XF86Configファイルの構文はXFree86 v3.xとv4.xで異なっている。両方のバージョンが
サポートされている。自動的に判定がされるが、完全からはほど遠い。手動でバージョ
ンを設定する必要があるかもしれない。使用しているXFree86に応じて、.vimrc中で変
数xf86conf_xfree86_versionを3または4にセットすること。例: >
	:let xf86conf_xfree86_version=3
複数のバージョンが混在しているときには
変数b:xf86conf_xfree86_versionをセットすること。

オプション名中のスペースとアンダースコアはサポートされていない。オプション名を
ハイライトさせたいなら"__s yn con gr_e_e_n"でなく"SyncOnGreen"と書くこと。


XML						*xml.vim* *xml-syntax*

Xml名前空間がデフォルトで強調される。次のグローバル変数をセットするとそれが無
効化される: >

	:let g:xml_namespace_transparent=1
<
							*xml-folding*
xml構文ファイルを使うと、開始タグと終了タグの間を折りたたむ|folding|ことができ
る(|:syn-fold|を参照)。これをオンにするには >

	:let g:xml_syntax_folding = 1
	:set foldmethod=syntax

とする。
構文による折り畳みは、構文強調を著しく遅くする可能性がある。特に巨大なファイル
ではそうである。


X Pixmaps (XPM)					*xpm.vim* *xpm-syntax*

xpm.vimは編集中のXPMファイルの内容から、動的に構文要素を生成する。そのため、色
設定文字列などを変更したときは":set syn=xpm"などとしてxpm.vimを読み直さなけれ
ばならない。

色つきのピクセルをコピーするには"yl"で"pixel"をヤンクし、どこかで"P"としてそれ
を挿入する。

マウスで図を描きたければ次のようにしてみるとよい: >
   :function! GetPixel()
   :   let c = getline(line("."))[col(".") - 1]
   :   echo c
   :   exe "noremap <LeftMouse> <LeftMouse>r".c
   :   exe "noremap <LeftDrag>	<LeftMouse>r".c
   :endfunction
   :noremap <RightMouse> <LeftMouse>:call GetPixel()<CR>
   :set guicursor=n:hor20	   " to see the color beneath the cursor
これを行うと、右ボタンがピペットになり、左ボタンがペンになる。これは1ピクセル
につき1文字だけとなっているXPMファイルでうまく機能する。ピクセル文字列の外をク
リックしてはならない。これを自由に改良してください。

セルサイズが正方形のフォントを使うと見栄えがよくなる。Xの例: >
	:set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*


==============================================================================
5. 構文を定義する					*:syn-define* *E410*

構文要素には3つのタイプがある。

1. キーワード
   これはオプション'iskeyword'で定義されるキーワード文字だけからなる。他の構文
   要素を含むことはできない。完全な単語(マッチの前後にキーワード文字が存在しな
   い)にのみマッチする。キーワード"if"は"if(a=b)"にはマッチするが、"ifdef x"に
   はマッチしない。"("はキーワード文字でなく、"d"はキーワード文字だから。

2. マッチ
   単一の正規表現パターンにマッチする。

3. リージョン
   正規表現パターン"start"のマッチ位置から始まり、正規表現パターン"end"のマッ
   チで終わる。その間にどんなテキストがあってもよい。正規表現パターン"skip"を
   使うとパターン"end"にマッチするのを避けることができる。

複数の構文要素を1つの構文グループに入れることができる。構文グループには強調属
性を与えることができる。例えば、"/* .. */"のコメントを定義する要素と"// .."の
コメントを定義する要素を作り、それらを"Comment"グループに入れることができる。
そして"Comment"が青のボールドフォントになるように指定することができる。1つの構
文要素に対し1つの構文グループを作ったり、すべての要素を1つのグループに入れても
よい。それは強調属性をどう指定したいかによる。各要素をそれ自身のグループに入れ
るとたくさんのグループに対して強調法を指定しなければならなくなる。

構文グループと強調グループは似ていることに注意。強調グループに対しては強調属性
を与えることになる。それらの属性は同名の構文グループに対して使われる。

同じ箇所に対して1個以上の要素がマッチする場合には、最後に定義されたものが使わ
れる。よって同じテキストにマッチする要素を使って、以前に定義された構文要素を上
書きすることができる。大文字・小文字の違いも含めてマッチするキーワードがあれば
そうでないものより優先される。


優先順位						*:syn-priority*

複数の構文要素がマッチするときはこれらのルールが適用される:

1. 複数のマッチまたはリージョン要素が同じ場所で始まるときは、後に定義されたも
   のが優先される。
2. マッチとリージョンよりキーワードが優先される。
3. より前の位置から始まる要素が優先される。


大文字・小文字の区別					*:syn-case* *E390*

:sy[ntax] case [match|ignore]
	これ以降の":syntax"コマンドが大文字・小文字を区別するかどうかを定義す
	る。"match"を使うと区別し、"ignore"を使うと区別しなくなる。これ以前の
	要素には影響せず、次の":syntax case"コマンドまでのすべての要素に影響
	する。


キーワードの定義 					*:syn-keyword*

:sy[ntax] keyword {group-name} [{options}] {keyword} .. [{options}]

	キーワードを定義する。

	{group-name}	"Comment"のような構文グループ名。
	[{options}]	後述の|:syn-arguments|を参照。
	{keyword} ..	このグループに含めるキーワードのリスト。

	例: >
  :syntax keyword   Type   int long char
<
	{options}は行のどこに置いてもよい。それらは与えられたキーワード全てに
	適用される。オプションがキーワードの後にあっても同じ。以下の例はまった
	く同じことをする: >
  :syntax keyword   Type   contained int long char
  :syntax keyword   Type   int long contained char
  :syntax keyword   Type   int long char contained
<
	VimのExコマンドのようにキーワードに短縮形があるとき、省略可能な部分を
	[]のでくくることによって受け入れるキーワードをいっぺんに定義することが
	できる: >
  :syntax keyword   vimCommand	 ab[breviate] n[ext]
<
	キーワードは文字全てがオプション'iskeyword'に含まれていないと認識され
	ないことに注意。1文字でも含まれていないと、そのキーワードは認識されな
	い。
	マルチバイト文字を使うこともできる。それらは'iskeyword'に含まれている
	必要はない。

	キーワードは常にマッチやリージョンより優先される。キーワードは一要素以
	上マッチしたとき使われる。キーワードは入れ子にならなく、それ以外のもの
	を含むこともできない。

	オプションと同じキーワードについては、それがその位置で利用できないもの
	であったとしても、定義することはできない。マッチで代用すること。

	キーワードの長さは最大80文字である。

	containmentが異なれば、同じキーワードを複数回定義することができる。例
	えば、まずキーワードをcontainedでなく定義して1つの強調グループを設定
	し、次にcontainedとして定義して別の強調グループを設定することができ
	る。例: >
  :syn keyword vimCommand tag
  :syn keyword vimSetting contained tag
<	構文要素の外側に"tag"があったときは強調グループ"vimCommand"が適用され
	る。"vimSetting"を含む構文要素の中に"tag"があったときは"vimSetting"グ
	ループが適用される。


マッチの定義    					*:syn-match*

:sy[ntax] match {group-name} [{options}] [excludenl] {pattern} [{options}]

	これはマッチを定義する。

	{group-name}		"Comment"のような構文グループ名。
	[{options}]		以下の|:syn-arguments|を参照。
	[excludenl]		行末の"$"を含んでいるパターンに対して、行末以
				降までマッチやリージョンを拡張しないようにす
				る。パターンの前に置かなければならない。
				|:syn-excludenl|
	{pattern}		マッチを定義する検索パターン。|:syn-pattern|を
				後述の参照。
				パターンは複数行にもマッチする。よって検
				索を開始する場所によってマッチが変わってくる可
				能性がある。シンクロナイズが関係してくることに
				注意。

	例 (文字定数にマッチする): >
  :syntax match Character /'.'/hs=s+1,he=e-1
< 

リージョンの定義	*:syn-region* *:syn-start* *:syn-skip* *:syn-end*
							*E398* *E399*

:sy[ntax] region {group-name} [{options}]
		[matchgroup={group-name}]
		[keepend]
		[extend]
		[excludenl]
		start={start_pattern} ..
		[skip={skip_pattern}]
		end={end_pattern} ..
		[{options}]
	
	これはリージョンを定義する。複数行にわたってもよい。

	{group-name}		"Comment"のような構文グループ名。
	[{options}]		後述の|:syn-arguments|を参照。
	[matchgroup={group-name}]  以下の開始パターンと終了パターンのマッチに
				のみ使われる構文グループ。マッチの開始パターン
				と終了パターンには使われない。開始パターンと終
				了パターン用に異なるグループを使わないようにリ
				セットするにはNONEを使う。
				|:syn-matchgroup|を参照。
	keepend			内包されたマッチが終了パターンを越えないように
				する。
				|:syn-keepend|を参照。
	extend			このリージョンを含むアイテムの"keepend"を上書
				きする。|:syn-extend|を参照。
	excludenl		行末の"$"を含んでいるパターンに対して、行末以
				降までマッチやアイテムを拡張しないようにする。
				終了パターンに対してのみ使い道がある。適用する
				パターンの前に置かねばならない。
				|:syn-excludenl|
	start={start_pattern}	リージョンの開始を定義する検索パターン。後述の
				|:syn-pattern|を参照。
	skip={skip_pattern}	その中ではリージョンの終了を探さないテキストを
				定義する検索パターン。|:syn-pattern|を参照。
	end={end_pattern}	リージョンの終了を定義する検索パターン。
				後述の|:syn-pattern|を参照。

	例: >
  :syntax region String   start=+"+  skip=+\\"+  end=+"+
<
	start/skip/endパターンとオプションはどんな順序で置かれてもよい。skip
	パターンは0個か1個許される。startとendパターンは1個以上なければならな
	い。つまりskipパターンは省略できるが、少なくとも1つのstartとendパター
	ンを書かなければならない。等号記号の前後にはホワイトスペースがあっても
	よい(たいていはホワイトスペースがないほうが見やすいが)。

	2個以上のstartパターンが与えられたときは、それらの1つがマッチすれば十
	分である。つまりstartパターンらの間にはOR関係があることになる。最後に
	マッチしたものが使われる。endパターンについても同じである。

	endパターンの検索はstartパターンの直後から行われる。これはendパターン
	のマッチとstartパターンは決して重ならないことを意味する。

	skipとendパターンは改行をまたいでマッチしてもよい。しかしパターンの検
	索はどの行からも始まりうるので、望みどおりにならないこともある。
	skipパターンは次の行のendパターンのマッチを回避しない。問題を避けるには
	単一行のパターンを使うこと。

	注意: リージョンの開始は、startパターンのマッチによってのみ決まる。
	endパターンの照合のチェックはされない。次のは機能しない: >
		:syn region First  start="("  end=":"
		:syn region Second start="("  end=";"
<	2番目のは常にFirstより前にマッチする(最後に定義されたパターンが優先され
	る)。こうすると、その前に':'があるかどうかに関わらず、2番目のリージョ
	ンが次の';'まで続く。マッチを使うとうまくいく: >
		:syn match First  "(\_.\{-}:"
		:syn match Second "(\_.\{-};"
<	このパターンは"\_."によって任意の文字と改行にマッチし、"\{-}"によって
	繰り返しにマッチする(最小限の個数の繰り返し)。

							*:syn-keepend*
	デフォルトでは内包されたマッチはendパターンのマッチを隠す。これはネス
	ト用に便利である。例えば、"{"で始まり"}"で終わるリージョンがもう1つの
	リージョンを含むことができる。"}"に出会うと内包されたリージョンが終わ
	り、外側のリージョンは終了しない:
	    {		外側の"{}"リージョンの開始
		{	内包された"{}"リージョンの開始
		}	内包された"{}"リージョンの終了
	    }		外側の"{}"リージョンの終了
	この挙動が望みでないなら、引数"keepend"をつければ、外側のリージョンの
	endパターンのマッチによって内包されたアイテムも終了させることができる
	。そうすると同一リージョンのネストが不可能になるが、内包されたアイテム
	でendパターンをスキップさせることなく、endパターンの一部を強調すること
	ができる。例: >
  :syn match  vimComment +"[^"]\+$+
  :syn region vimCommand start="set" end="$" contains=vimComment keepend
<	"keepend"によってvimCommandが常に行末で終わるようにしている。たとえ内
	包されたvimCommentが<EOL>とのマッチを含んでいてもそのようになる。

	"keepend"が使われないときは、内包されたマッチの後でendパターンのマッチ
	が検索される。"keepend"が含まれているときは最初にendパターンにマッチし
	たところで終了し、内包されたマッチもすべてそこで終了になる。

							*:syn-extend*
	引数"extend"を使うと"keepend"の挙動が変わる。"keepend"付きのアイテム中
	に"extend"付きのアイテムが内包されていると、"keepend"が無視され、外側
	のリージョンが拡張される。これによっていくつかのアイテムに対して例外的
	にリージョンを拡張させるようにできる。例: >

   :syn region htmlRef start=+<a>+ end=+</a>+ keepend contains=htmlItem,htmlScript
   :syn match htmlItem +<[^>]*>+ contained
   :syn region htmlScript start=+<script+ end=+</script[^>]*>+ contained extend

<
	この例では、htmlItemの位置でhtmlRefが終了する。htmlItemは<>要素を強調
	するためだけに使われる。htmlScriptアイテムはhtmlRefアイテムを拡張する。

	もう1つの例: >
   :syn region xmlFold start="<a>" end="</a>" fold transparent keepend extend
<	"</a>"を別の色で強調したいときなどのために、"keepend"つきでリージョン
	を定義し、内包するアイテムによって終端が変更されないようにしている。
	ただしxmlFoldがネストしたとき(それ自身を含んだとき)、"extend"が適用さ
	れ、内側の"</a>"はそのリージョン自身だけを終了させ、それを含んでいるリ
	ージョンは終了しない。

							*:syn-excludenl*
	マッチ用のパターンやリージョンの終了パターンが行末にマッチさせるために
	'$'を含んでいると、それを含むリージョンアイテムが次の行まで継続するよ
	うになる。例えば、"\\$"(行末のバックスラッシュ)とのマッチを使うと、通
	常は行末で終了するはずのリージョンを継続させることができる。これはデフ
	ォルトの挙動である。これが望みどおりでないなら、これをされる2つの方法
	がある:
	1. 外側のアイテムに"keepend"を使う。こうすると含んでいるアイテム全てに
	   対して拡張しないようにする。含んでいるアイテム全てが外側のアイテム
	   を拡張してはならないときに使える。
	2. 内側のアイテムに"excludenl"を使う。こうするとそのマッチに対して、そ
	   れを含んでいるマッチやリージョンを拡張しないようにする。これはいく
	   つかのアイテムだけが外側のアイテムを拡張してはならないときに使える。
	   "excludenl"はそれを適用するパターンの前に置かねばならない。

							*:syn-matchgroup*
	"matchgroup"は、リージョンの本体とその開始・終了パターンに対して異なる
	強調をしたいときに使える。例: >
  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+	end=+"+
<	こうすると引用符を"Quote"グループで強調し、その間にあるテキストを
	"String"グループで強調することができる。
	"matchgroup"はそれが従うすべての開始・終了パターンに対して使われる。
	matchgroupを使わないように戻すには"matchgroup=NONE"を使う。

	開始・終了パターンが"matchgroup"で強調されるとき、そのリージョンに含ま
	れているアイテムは無視される。これによって含まれているアイテムが開始・
	終了パターンにマッチするのを避けることができる。"transparent"を使って
	いる場合、これは"matchgroup"で強調される開始・終了パターンのマッチ部分
	には適用されない。

	次の例は、3段階の括弧を異なる色で強調する例である: >
   :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2
   :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained
   :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained
   :hi par1 ctermfg=red guifg=red
   :hi par2 ctermfg=blue guifg=blue
   :hi par3 ctermfg=darkgreen guifg=darkgreen

==============================================================================
6. :syntaxの引数					*:syn-arguments*

構文アイテムを定義する:syntaxコマンドはたくさんの引数をとる。
ここでは共通のものを説明する。引数はどんな順序でもよく、パターンと混ざっていて
もよい。

全てのコマンドが全ての引数を受けいれるわけではない。次の表はどの引数がどのコマ
ンドに対して利用可能かを示している:
							*E395* *E396*
		    contains  oneline	fold  display  extend ~
:syntax keyword		 -	 -	 -	 -	 -
:syntax match		yes	 -	yes	yes	yes
:syntax region		yes	yes	yes	yes	yes

以下の引数は3つのコマンド全てに対して使える:
	contained
	containedin
	nextgroup
	transparent
	skipwhite
	skipnl
	skipempty


contained						*:syn-contained*

引数"contained"が与えられると、そのアイテムはトップレベルでは認識されず、他の
マッチの"contains"フィールドで指定されたときのみ認識される。例: >
   :syntax keyword Todo    TODO    contained
   :syntax match   Comment "//.*"  contains=Todo


display							*:syn-display*

引数"display"が与えられると、そのアイテムは検出された強調が表示されない時には
スキップされる。こうすることでアイテムがスキップされ、表示されるべきテキストの
構文状態だけが検索対象となり、強調がスピードアップされる。

通常は、以下の条件に合うときマッチとリージョンに"display"を使うとよい:
- アイテムが行末を越えて継続しない。Cの例: "/*"コメント用のリージョンは
  "display"を含んではならない。なぜなら次の行に継続するからである。
- アイテムが、行を越えて継続したり、そのコンテナを次行まで継続させる効果を持つ
  子アイテムを含んでいない。
- それを含むどんなアイテムのサイズも変更しない。Cの例: プリプロセッサマッチ中
  の"\\$"とのマッチは"display"を含んではならない。なぜならこれによってプリプロ
  セッサマッチが短くなるかもしれないからである。
- 他のアイテムがマッチすることを許さず、そうでなければマッチせず、加えてマッチ
  自体が非常に長くなるようなアイテム。
  Cの例: "//"コメント用のマッチは"display"を使ってはならない。なぜならそのコメ
  ントの内側の"/*"がマッチするかも知れず、そうなると行末をまたぐコメントが始ま
  るからである。

例としてC言語では次のとき"display"が使える:
- 数字とのマッチ
- ラベルとのマッチ


transparent						*:syn-transparent*

引数"transparent"が与えられると、そのアイテムはそれ自身では強調されず、それを
含むアイテムの強調を受け取る。これは強調はせず、テキストの一部をスキップするた
めだけに使われる構文アイテムに対して有効である。

transparentなアイテム自身に引数"contains"が与えられていない場合、引数
"contains="も同様にそれを含むアイテムを受け継ぐ。望まないアイテムが含まれるの
を避けるには"contains=NONE"とすること。文字列中の単語を強調するが、"vim"だけは
例外とする例: >
	:syn match myString /'[^']*'/ contains=myWord,myVim
	:syn match myWord   /\<[a-z]*\>/ contained
	:syn match myVim    /\<vim\>/ transparent contained contains=NONE
	:hi link myString String
	:hi link myWord   Comment
マッチ"myVim"が"myWord"の後に来ているので、そちらが優先される(同じ場所中では最
後のマッチがそれ以前のものを上書きする)。引数"transparent"により、"myVim"のマ
ッチは"myString"と同じ強調が使われるようになる。しかしそれは何も含まない。もし
引数"contains=NONE"が除かれると、"myVim"はmyStringから引数containsを受け継ぎ、
"myWord"が含まれるのを許すようになり、それがConstantとして強調される。これは、
内包されたマッチは同じ位置でそれ自身の内側でマッチしないためこうなる。つまり、
ここではマッチ"myVim"は"マッチmyWord"を上書きしない。

色づけされたテキストは、内包されたアイテムの層のように見える。内包されたアイテ
ムはそれを含むアイテムの上にあり、よって内包されたアイテムを見ることができる。
内包されたアイテムがtransparentなとき、それを透過して見ることができ、よってそ
れを含んでいるアイテムが見える。図にすると:

		ここから見る

	    |	|   |	|   |	|
	    V	V   V	V   V	V

	       xxxx	  yyy		さらに内包されたアイテム達
	    ....................	内包されたアイテム (transparent)
	=============================	最初のアイテム

'x', 'y', '='は強調された構文アイテムを表す。'.'はtransparentなグループを表し
ている。

このとき次のように見える:

	=======xxxx=======yyy========

つまりtransparentな"...."は透過して見える。


oneline							*:syn-oneline*

引数"oneline"をつけると、そのリージョンは行をまたがないという意味になる。つま
り現在行内で完全にマッチしなければならない。しかし、そのリージョンが行をまたぐ
アイテムを内包しているときは次の行に継続する。内包されたアイテムによって行継続
パターンが認識される。しかしその場合でも"end"パターンは最初の行内でマッチしな
ければならない。そうでないとリージョンは開始すらしない。

startパターンが行末にマッチする"\n"を含んでいるときは、startパターンの終了位置
と同じ行にendパターンがなければならない。endパターンも行末を含むことができる。
つまり引数"oneline"は、startパターンの終了位置とendパターンの開始位置が同一行
にあることを意味する。改行にマッチするskipパターンを使ってもこの規則を変えるこ
とはできない。

fold							*:syn-fold*

引数"fold"はこのアイテムに対して折り畳みレベルを1増加させる。例: >
   :syn region myFold start="{" end="}" transparent fold
   :syn sync fromstart
   :set foldmethod=syntax
これは{}ブロックごとに1つの折り畳みを作らせる。

折り畳みはそのアイテムの開始位置から始まり、アイテムの終了位置で終わる。開始位
置と終了位置が同一行にある場合、折り畳みは作られない。
オプション'foldnestmax'によって構文折り畳みのネストを制限できる。
{|+folding|機能なしでコンパイルされた場合は利用できない}


			*:syn-contains* *E405* *E406* *E407* *E408* *E409*
contains={groupname},..

引数"contains"の後には構文グループ名のリストを続ける。これによって指定されたグ
ループがそのアイテムの内側で始まることを許可する(内包するグループによって外側
のアイテムの範囲が拡張されることもある)。マッチとリージョンの再帰的なネストが
あってもよい。引数"contains"が与えられない場合、このアイテムはどんなグループも
内包しない。グループ名をここより前で定義する必要はない。

contains=ALL
		containsリストが"ALL"だけのとき、全てのグループがこのアイテム
		の内側で許可される。

contains=ALLBUT,{group-name},..

		containsリストの最初の要素が"ALLBUT"のとき、ここでリストされて
		いるグループを除く全てのグループがこのアイテムの内側で許可され
		る。例: >
  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function

contains=TOP
		containsリストの最初の要素が"TOP"のとき、引数"contained"を持た
		ないグループ全てが許可される。
contains=TOP,{group-name},..
		"TOP"と同様だが、リストされたグループは除かれる。

contains=CONTAINED
		containsリストの最初の要素が"CONTAINED"のとき、引数
		"contained"を持つグループ全てが許可される。
contains=CONTAINED,{group-name},..
		"CONTAINED"と同様だが、リストされたグループは除かれる。
		

"contains"リスト内の{group-name}はパターンであってもよい。そのパターンにマッチ
するグループ名全てが含まれる("ALLBUT"が使われたときはそれが除かれる)。パターン
はホワイトスペースや','を含んではならない。例: >
   ... contains=Comment.*,Keyw[0-3]
パターンの照合はそのsyntaxコマンドが実行されたときに行われる。それ以降に定義さ
れたグループは照合されない。また、現在のsyntaxコマンドが新しいグループを定義し
ている場合、そのグループは照合されない。ファイル内にsyntaxコマンドを書く場合、
定義されていないグループを当てにすることはできないことに注意。これは、そのファ
イルは以前に読み込まれているかもしれず、":syn clear"はグループ名を削除しないた
めである。

内包されたグループはリージョンのstartとendパターン内にもマッチする。これが望み
の挙動でないなら、引数"matchgroup"を使うとよい|:syn-matchgroup|。オフセット
"ms="と"me="によって内包されたアイテムがマッチする領域を変更することができる。
これは強調される範囲も制限することに注意。


containedin={groupname}...				*:syn-containedin*

引数"containedin"の後には構文グループ名のリストを続ける。するとこのアイテムが
それらのグループの内側で始まることが許可される。これは外側のアイテムが引数
"contains="でこのアイテムを指定したのと同じように動作する。

{group-name}...の指定の仕方は前述の"contains"と同様である。

これは構文アイテムを後から追加するときに便利である。既に定義されているアイテム
の定義を変更することなく、その内側にアイテムを含めることができる。例えば、Cの
構文を読み込んだ後で、Cコメント中の単語を強調したいときは: >
	:syn keyword myword HELP containedin=cComment contained
このアイテムがトップレベルではマッチしないように"contained"を使っている。

"containedin"の照合は、このアイテムが現れる場所に追加される。引数"contains"も
通常通り追加される。注意: キーワードは他のアイテムを含むことができないため、
"containedin"の先にキーワードを指定することは無意味である。


nextgroup={groupname},..				*:syn-nextgroup*

引数"nextgroup"の後には構文グループ名のリストをカンマ区切りで続ける
("contains"と同様。パターンを使うこともできる)。

引数"nextgroup"が与えられると、マッチやリージョンの終了位置の後ろで、指定され
た構文グループにマッチする部分が探される。どのグループもマッチしなければ、強調
は通常通り続けられる。マッチが見つかった場合はそのグループが使われる。現在のグ
ループの引数"contains"でそのグループが指定されていなくてもそうなる。つまり、こ
れは指定されたグループの優先度を最大にするイことと同じである。例: >
   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo
   :syntax match  ccFoo     "Foo"	    contained nextgroup=ccFiller
   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained

これは"Foo"の後に"Bar"が現れたときのみ、"Foo"と"Bar"に異なる強調をする。以下の
テキストにおいて、"f"と書いたところはccFooで強調され、"bbb"と書いたところは
ccBarで強調される。 >

   Foo asdfasd Bar asdf Foo asdf Bar asdf
   fff	       bbb	fff	 bbb

".\{-}"を使い、次のBarまでのスキップが最小になるようにしている。もし".*"を使う
と、最初の"Foo"と最後の"Bar"がccFooBarのマッチ部分に含まれるため、"Bar"と"Foo"
の間の"asdf"が"ccFoobar"グループとして強調されることになる(|pattern|を参照)。


skipwhite						*:syn-skipwhite*
skipnl							*:syn-skipnl*
skipempty						*:syn-skipempty*

これらの引数は"nextgroup"と組み合わせたときのみ意味を持つ。これらを使うと、次
のグループがあるテキストをスキップした後でマッチするのを許可する:
	skipwhite	スペースとタブ文字をスキップする
	skipnl		行末をスキップする
	skipempty	空行をスキップする(自動的に"skipnl"も含むことになる)

"skilwhite"が与えられると、どの次のグループもホワイトスペースにマッチしないな
らば、ホワイトスペースがスキップされる。

"skipnl"が与えらると、nextgroupの照合が次の行からも探される。これは現在のアイ
テムが現在行の行末で終わったときのみ有効であることに注意。"skipnl"が指定されな
い場合、nextgroupは同一行のそのアイテム以降から照合される。

次のグループまでスキップされたテキストの中では他のグループの照合は無視される。
次のグループの照合が見つからなかったとき、再び他のグループの照合が検索される。
つまり、次のグループの照合と、ホワイトスペースと<EOL>のスキップは他のアイテム
より優先される。

例: >
  :syn match ifstart "\<if.*"	  nextgroup=ifline skipwhite skipempty
  :syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained
  :syn match ifline  "endif"	contained
マッチ"[^ \t].*"はホワイトスペース以外の全てのテキストにマッチする。よって
"endif"にもマッチする。そのためマッチ"endif"を最後に置き、優先順位を与えている
。
この例はネストした"if"には機能しないことに注意。ネストに対応されるには引数
"contains"を指定する必要がある(この例では簡単のため省略した)。

==============================================================================
7. syntaxのパターン				*:syn-pattern* *E401* *E402*

syntaxコマンドでは、パターンの前後を同じ文字で囲まなければならない。これは
":s"コマンドと同様である。もっともよく使われるのはダブルクォートである。しかし
パターンがダブルクォートを含んでいる場合は、そのパターンが含んでいない他の文字
を使ったほうがよい。例: >
  :syntax region Comment  start="/\*"  end="\*/"
  :syntax region String   start=+"+    end=+"+	 skip=+\\"+

パターンの説明については|pattern|を参照。構文パターンは常に'magic'オプションが
セットされているのと同じように解釈される(実際の'magic'オプションの値とは無関係)
。また、'cpoptions'に'l' フラグが含まれていない場合と同じように解釈される。こ
れは構文ファイルの可搬性を高め、'compatible'と'magic'の設定と無関係にするため
である。

"[a-z]*"など空文字列にマッチするパターンは避けること。これは全ての位置にマッチ
するため、強調がとても遅くなる。

						*:syn-pattern-offset*
パターンに文字数のオフセットを指定することができる。これによって強調される部分
を変更したり、マッチやリージョンに含まれるテキスト領域(これは他のアイテムを照
合するときにだけ関係する)を変更することができる。どちらもマッチしたパターンに
相対的である。skipパターンに対して文字数のオフセットを指定すると、endパターン
の検索が始まる位置を決めることができる。

オフセットは"{what}={offset}"の形で指定する。
{what}は次の7個の文字列のどれかである:

ms	Match Start	マッチしたテキストの開始位置のオフセット
me	Match End	マッチしたテキストの終了位置のオフセット
hs	Highlight Start	強調が始まる位置のオフセット
he	Highlight End	強調が終わる位置のオフセット
rs	Region Start	リージョンの本体が始まる位置のオフセット
re	Region End	リージョンが終わる位置のオフセット
lc	Leading Context	パターンの"leading context"を過ぎた後のオフセット

{offset}は次のうちのどれか:

s	パターンのマッチ部分の先頭
s+{nr}	パターンのマッチ部分の先頭から右へ{nr}文字目
s-{nr}	パターンのマッチ部分の先頭から左へ{nr}文字目
e	パターンのマッチ部分の末尾
e+{nr}	パターンのマッチ部分の末尾から右へ{nr}文字目
e-{nr}	パターンのマッチ部分の末尾から左へ{nr}文字目
{nr}	("lc"専用): ら左へ{nr}文字目

例: "ms=s+1", "hs=e-2", "lc=3".

どのパターンの後にどのオフセットを指定してもよいが、それが意味を持たない場合も
ある。次の表はどのオフセットが実際に使われるかを示している:

		    ms	 me   hs   he	rs   re	  lc ~
match item	    yes  yes  yes  yes	-    -	  yes
region item start   yes  -    yes  -	yes  -	  yes
region item skip    -	 yes  -    -	-    -	  yes
region item end     -	 yes  -    yes	-    yes  yes

複数のオフセットの間に','を入れて連結することができる。例: >
  :syn match String  /"[^"]*"/hs=s+1,he=e-1
< 
    some "string" text
	  ^^^^^^		ここが強調される

注意:
- パターンとオフセットの間にホワイトスペースを挟んではならない。
- 強調される領域がマッチしたテキストの外側にはみ出してはならない。
- endパターンに対する負のオフセットは機能しない場合がある。これは強調が既に終
  わっているべきとき、endパターンは検出されない可能性があるからである。
- マッチの開始位置が、パターンがマッチした位置と別の行になってはならない。つま
  り"a\nb"ms=eというのは正常に機能しない。強調の開始位置は別の行にあってもかま
  わない。"a\nb"hs=eというのは正常に機能する。

例(コメントにマッチするが /* と */ は強調しない): >
  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1
<
	/* this is a comment */
	  ^^^^^^^^^^^^^^^^^^^	  ここが強調される

より複雑な例: >
  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1
<
	 abcfoostringbarabc
	    mmmmmmmmmmm	    マッチ部分
	      ssrrrreee	    start/region/endとして強調される部分 ("Foo", "Exa", "Bar")

Leading context			*:syn-lc* *:syn-leading* *:syn-context*

注意:これは古い機能であり、以前のバージョンとの後方互換性のためだけに残されて
いる。現在はパターン中の|/\@<=|コンストラクトを使うことが推奨されている。

"lc"オフセットはリーディングコンテキストを指定する。これはパターンの一部になけ
ればならないが、マッチ部分の一部とは見なされないものである。"lc=n"のオフセット
を使うとパターンの照合を試みる前にn桁戻るようになる。リーディングコンテキスト
内に他のパターンにマッチしている文字が現れてもよい。これはマッチの前方にあって
はならない「エスケープ」文字を指定する場合などに使える: >

  :syn match ZNoBackslash "[^\\]z"ms=s+1
  :syn match WNoBackslash "[^\\]w"lc=1
  :syn match Underline "_\+"
<
	  ___zzzz ___wwww
	  ^^^	  ^^^	  Underlineにマッチする
	      ^ ^	  ZNoBackslashにマッチする
		     ^^^^ WNoBackslashにマッチする

"ms"を指定しないと自動的に"lc"と同じ値にセットされる。


Multi-line patterns					*:syn-multi-line*

パターンが"\n"を含むと改行にマッチするようになる。たいていの場合これは期待通り
に動作するが、少しだけ例外がある。

startパターンにオフセットをつけるとき、マッチ部分の開始位置が次の行の先頭であ
ってはならない。強調は次の行で始まってもよい。

skipパターンも"\n"を含んでよい。ただし次の行の最初の文字がskipパターンにマッチ
していても、そこからendパターンの検索が続けられる。これは、再描画は領域内のど
の行でも始まることができ、skipパターンが前の行から始まったかどうかはチェックさ
れないからである。例えば、skipパターンが"a\nb"で、endパターンが"b"のとき、次の
テキストの2行目でendパターンがマッチする。 >
	 x x a
	 b x x
つまり、skipパターンは"\n"以降の文字にはマッチしないことになる。


外部マッチ					*:syn-ext-match*

リージョンパターンにおいては特別にこれらの正規表現が使える:

						*/\z(* */\z(\)* *E50* *E52*
    \z(\)	一部を「external」としてマークする。これをつけると他のパターン
		からアクセスできるようになる。現在はリージョンのstartパターン
		内でのみ使用可能。

					*/\z1* */\z2* */\z3* */\z4* */\z5*
    \z1  ...  \z9			*/\z6* */\z7* */\z8* */\z9* *E66* *E67*
		startパターンにマッチしたテキスト中からマークしておいた部分を
		参照する。

リージョンのstartとendパターンで正規表現の一部を共有したい場合がある。
一般的な例としてはPerlやUnixシェルのヒアドキュメントがある。これは特別な正規表
現アイテム"\z"を使えば達成できる。これは正規表現の一部を"external"としてマーク
しておく。するとその部分を他のパターンから参照できるようになる。例えば、ヒアド
キュメントはこうすればよい: >
  :syn region hereDoc start="<<\z(\I\i*\)" end="^\z1$"

このように、\zは2つの役割を果たす。startパターンにおいては正規表現の一部
"\(\I\i*\)"をexternalとしてマークする。endパターンでは\1によってstartパターン
中の最初のマークされた部分への外部参照とする。外部参照はskipパターン中でも使え
る: >
  :syn region foo start="start \(\I\i*\)" skip="not end \z1" end="end \z1"

通常のマークとexternalなマークはまったく独立であり、別々に番号が振られる。例え
ば、文字列"aabb"に対してパターン"\z(..\)\(..\)"を適用すると、\1は"bb"を参照し
、\z1は"aa"を参照するようになる。externalなマークをした部分は、通常のマークと
違って、同一パターン内で後方参照することはできない。ある部分に対して通常のマー
ク、externalなマーク両方をつけたい場合は、"\(\z(...\)\)"のようにネストさせるこ
とができる。

一行内でマッチした部分しか参照できないことに注意。複数行にわたってマッチした部
分は参照できない。

==============================================================================
8. クラスタ						*:syn-cluster* *E400*

:sy[ntax] cluster {cluster-name} [contains={group-name}..]
				 [add={group-name}..]
				 [remove={group-name}..]

このコマンドを使うと、構文グループのリストを1つの名前のもとにまとめることがで
きる。このまとまりのことをクラスタと呼ぶ。

	contains={group-name}..
		クラスタに含まれるグループを指定する。
	add={group-name}..
		指定したグループをクラスタに加える。
	remove={group-name}..
		指定したグループをクラスタからとり除く。

定義されたクラスタはcontains=..やnextgroup=..、add=..、remove=..などで使うこと
ができる。そのとき場合は"@"をつける。また、この記法によってクラスタの中身を定
義する前にそのクラスタ名を使用することができる。

Example: >
   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers
   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2

この例からわかるように、クラスタに対する変更はさかのぼって効果がある。クラスタ
の中身は直前になってチェックされる。言ってみれば: >
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster AandB contains=A
   :syntax match Stuff "( aaa bbb )" contains=@AandB
   :syntax cluster AandB add=B	  " これによって2つのキーワードがStuff内でマ
				    ッチするようになる

これはクラスタのネスト度にも関係がある: >
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster SmallGroup contains=B
   :syntax cluster BigGroup contains=A,@SmallGroup
   :syntax match Stuff "( aaa bbb )" contains=@BigGroup
   :syntax cluster BigGroup remove=B	" BはBigGroup内にないので無意味
   :syntax cluster SmallGroup remove=B	" Stuff内でbbbがマッチしなくなる

==============================================================================
9. 構文ファイルのインクルード			*:syn-include* *E397*

構文ファイルの中で、それに関連した構文ファイルをインクルードしたい場合がある。
そうするには、構文ファイルの関係によって2種類の方法がある:

	- インクルードされるファイル内のトップレベルのアイテムをそのままトップ
	  レベルとしたいなら、単に|:runtime|コマンドを使えばよい: >

  " In cpp.vim:
  :runtime! syntax/c.vim
  :unlet b:current_syntax

<	- インクルードされるファイル内のトップレベルのアイテムをリージョンに内
	  包させたいなら、":syntax include"コマンドを使うとよい: >

:sy[ntax] include [@{grouplist-name}] {file-name}

	  インクルードされるファイル中で宣言された構文アイテム全てに
	  "contained"フラグがつけられる。さらにグループのリストを指定すると、
	  インクルードされるファイル中のトップレベルの構文アイテム全てに対して
	  そのリストがつけられる。 >

   " In perl.vim:
   :syntax include @Pod <sfile>:p:h/pod.vim
   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod
<
	  {file-name}が絶対パスである場合("/", "c:", "$VAR", "<sfile>"のどれか
	  で始まる場合)そのファイルが読み込まれる(sourceされる)。相対パスの場
	  合(例:"syntax/pod.vim")、そのファイルが'runtimepath'中から探される。
	  マッチしたファイル全てが読み込まれる。相対パスを使用することが推奨さ
	  れる。そうすればユーザが":syn include"を書き換えることなく、インクル
	  ードされるファイルを改変して別の場所におけるからである。

==============================================================================
10. 表示のシンクロナイズ 			*:syn-sync* *E403* *E404*

ドキュメント中のどの位置からでも再描画を開始できると望ましい。これを実現するに
は、再描画を開始する位置における構文の状態を知る必要がある。

:sy[ntax] sync [ccomment [group-name] | minlines={N} | ...]

シンクロナイズには4つのやり方がある:
1. 常にファイルの最初からパースする。
   |:syn-sync-first|
2. Cスタイルのコメントに基づく。VimはCコメントの挙動を理解し、現在行がコメント
   の内側から始まっているか外側から始まっているかを判定することができる。
   |:syn-sync-second|
3. 一定行さかのぼり、そこからパースを開始する。
   |:syn-sync-third|
4. テキストをさかのぼり、シンクロナイズを始める目印の正規表現を検索する。
   |:syn-sync-fourth|

				*:syn-sync-maxlines* *:syn-sync-minlines*
最後の3つの方法に関して、さかのぼる行数は"minlines"と"maxlines"で制限される。

引数"minlines={N}"が指定されると、常に少なくともその行数さかのぼってパースが開
始される。パースする行数が少なすぎて正しく強調できないかもしれないとき、または
シンクロナイズを使うのが不可能であるとき、この引数を使うとよい。

引数"maxlines={N}"が指定されると、コメントや正規表現を検索するためにさかのぼる
行数が最大N行になる。これは遅いマシンを使っていて、シンクロナイズする行数が少
ないとわかっているときに便利である。例: >
   :syntax sync ccomment maxlines=500
< 
						*:syn-sync-linebreaks*
複数行にマッチする正規表現を使っているとき、ある行に変更を施すと、前の行でマッ
チしていた正規表現がマッチしなくなってしまうことがある。つまり、変更が施された
場所より上からシンクロナイズを始めなければならないことを意味する。引数
"linebreaks"には行数を指定する。例えば、正規表現が改行を1個含んでいる場合はこ
のようにする: >
   :syntax sync linebreaks=1
こうすると、常に変更が施された行の少なくとも1行前から再描画が開始される。
"linebreaks"のデフォルト値は0。通常"minlines"の値は"linebreaks"の値より大きい。

第一の方法:          			*:syn-sync-first*
>
   :syntax sync fromstart

ファイルの最初からパースする。これを使うと構文強調が正確になるが、長いファイル
に対しては遅くなる。Vimは以前にパースされたテキストをキャッシュしておく。その
ため、遅くなるのはファイルを最初にパースするときだけである。しかし、変更を施す
と、それ以降の一部をパースし直さなければならなくなる(最悪の場合はファイルの最
後まで)。

"fromstart"を使うことは"minlines"を非常に大きな値にすることと同じ効果を持つ。


第二の方法:           			*:syn-sync-second* *:syn-sync-ccomment*

第二の方法を使うには、単に引数"ccomment"をつければよい。
例: >
   :syntax sync ccomment

画面最上行がCスタイルコメントの内側にあると判断される場合、グループ名が
"Comment"のリージョン構文アイテムが使われる。この方法を使うには"Comment"という
グループ名のリージョンがなければならないことに注意。他のグループ名を指定するこ
ともできる。例: >
   :syntax sync ccomment javaComment
こうすると、検出されたCコメントのリージョンに対して"syn region javaComment"で
指定されたアイテムのうち最後のものが使われる。ここで指定するリージョンのstart
パターンが"\/*"、endパターンが"*\/"となっていないと適切に機能しない。

引数"maxlines"を使うと検索の行数を制限できる。引数"minlines"を使うと少なくとも
その行数だけさかのぼって開始させることができる(例:2,3行だけを受け取るコンスト
ラクトがある場合。ただしその場合シンクロナイズするのが困難)

注意: "*/"を含む文字列で行をまたぐものがあると、Cコメントによるシンクロナイズ
は適切に機能しない。行をまたいで文字列を書くのは悪いプログラミング習慣である
(多くのコンパイラが警告を出す)。また、コメント中に"*/"が現れる機会はまれなので
、この制限は注意するほどのものではない。


第三の方法:          				*:syn-sync-third*

第三の方法を使うには引数"minlines={N}"を加えればよい。この方法を指定すると
、{N}行前からパースを開始する。これは{N}行余分にパースされることを意味する。そ
のためこの方法は少し遅くなる。
例: >
   :syntax sync minlines=50

"lines"は"minlines"と同じ意味である(古いバージョンで使われている)。


第四の方法:					*:syn-sync-fourth*

シンクロナイズパターンと呼ばれる特定のリージョンの末尾でシンクロナイズするもの
である。行をまたげるのはリージョンだけなので、リージョンの末尾に出会ったら、ど
の構文アイテムの中にいるのかを知ることができる。再描画が始まる行のすぐ上から検
索が始まり、ファイルの後方に向かって検索する。

これはシンクロナイズしない構文アイテムとちょうど同じように機能する。内包された
マッチ、nextgroupなどを使うことができる。ただし少しだけ違いがある。
- キーワードを使うことはできない。
- "sync"キーワード付きの構文アイテムは、完全に別の構文アイテムのグループを形成
  する。シンクロナイズするグループとしないグループを混ぜることはできない。
- 照合はバッファ内で1行ごとに逆向きに行われる(前向きではない)。
- 行継続パターンをつけることができる。これを使うと、あたかも1行であるかのよう
  に検索する一連の行を指定することができる。これは、指定したアイテムとの照合が
  継続パターンを含む一連の行の最初から始まることを意味する。
- "nextgroup"や"contains"は1行(または継続された一連の行)内でだけ有効。
- リージョンは同一行(または継続された一連の行)内で開始・終了しなければならない
  。そうでないと行末(または継続された一連の行)内で終わるものとされる。
- シンクロナイズパターンとのマッチが見つかると、その行(または継続された一連の
  行)の残りから再びマッチが探される。最後のマッチが使われる。
  これはリージョンの開始と終了が同一行内にあるとき使われる
  (例: /* this */のようなCコメントでは、最後の"*/"が使われる)。

シンクロナイズパターンとのマッチは2通りの使い方がある。
1. 再描画を始める場所(シンクロナイズパターンの検索が始まる場所でもある)から強
   調のためのパースを始める。そこで有効であると期待される構文グループを指定し
   なければならない。行をまたぐリージョンが他のリージョンを含んではならない場
   合にこれはうまく機能する。
2. 強調のためのパースはマッチの直後から継続される。マッチの直後に現れると期待
   される構文グループを指定しなければならない。
   これは前の方法がうまくいかないときに使われる。これは、より多くのテキストを
   パースする必要があるため、とても遅い。
両方のタイプを同時に使うこともできる。

シンクロナイズパターンだけでなく、他のマッチとリージョンを指定して望まないマッ
チが見つかるのを避けることができる。

[シンクロナイズパターンが別々に与えられる理由は、シンクロナイズポイントの検索
はたいていの場合、強調するところを判別するよりずっと単純だからである。パターン
の数が減るとそれだけ速くなる。]

					    *syn-sync-grouphere* *E393* *E394*
    :syntax sync match {sync-group-name} grouphere {group-name} "pattern" ..
    
	シンクロナイズ用に使うマッチを定義する。{group-name}はマッチのすぐ後に
	続く構文グループの名前である。強調のためのテキストのパースはマッチの直
	後から始まる。この{group-name}がついたリージョンが存在しなければならな
	い。最初に定義されたリージョンが使われる。マッチの後に構文グループが続
	かない場合は"NONE"を使う。

						*syn-sync-groupthere*
    :syntax sync match {sync-group-name} groupthere {group-name} "pattern" ..

	"grouphere"と同様。ただし{group-name}はシンクロナイズポイントの検索が
	始まる行の行頭で使われる構文グループの名前である。マッチとシンクロナイ
	ズパターンの検索が始まる位置との間のテキストは構文強調を変えてはならな
	い。例えばCにおいて"/*"と"*/"を後方検索することができる。"/*"が先に見
	つかったら、今はコメントの内側にいるとわかる。なので"groupthere"は
	"cComment"となる。"*/"が先に見つかったら今はコメントの中ではないとわか
	る。なので"groupthere"は"NONE"となる。(実際は、文字列の中に"/*"と"*/"
	があるかもしれないので、もう少し込み入っている。これは読者の練習問題と
	しておく...)。

    :syntax sync match ..
    :syntax sync region ..

	引数"groupthere"なしの場合。シンクロナイズポイントの検索の際にスキップ
	されるリージョンやマッチを定義する。

    :syntax sync linecont {pattern}

	{pattern}とのマッチが次の行にも継続されるとみなされる。つまりシンクロ
	ナイズポイントの検索の際、行は連結されているものと見なされる。

引数"maxlines={N}"が同時に与えられると、マッチを検索する行がN行に制限される。
これは遅いマシンを使っていて、シンクロナイズするものが少ないとわかっているとき
に便利。例: >
   :syntax sync maxlines=100

全てのシンクロナイズの設定をクリアするには: >
   :syntax sync clear

あるシンクロナイズパターンをクリアするには: >
   :syntax sync clear {sync-group-name} ..  

==============================================================================
11. 構文アイテムのリストを表示する	*:syntax* *:sy* *:syn* *:syn-list*

このコマンドは全ての構文アイテムのリストを表示する: >

    :sy[ntax] [list]

ある構文グループに属する構文アイテムを表示するには: >

    :sy[ntax] list {group-name}

あるクラスタに属する構文グループを表示するには:			*E392*
>
    :sy[ntax] list @{cluster-name}

":syntax"コマンドに対する他の引数については上を参照。

":syntax"コマンドは":sy"とも略記できる。しかし":syn"の方が見栄えがよいため、普
通はこちらが使われる。

==============================================================================
12. 強調コマンド			*:highlight* *:hi* *E28* *E411* *E415*

強調グループには3つのタイプがある:
- 特定の言語に使われるもの。名前がその言語の名前で始まる。このタイプのほとんど
  は属性を持たず、2番目のタイプのグループにリンクされる。
- 全ての構文言語に対して使われるもの。
- 'highlight'オプションに使われるもの。
							*hitest.vim*
現在有効な全てのグループを知るにはこのコマンドを使う: >
    :so $VIMRUNTIME/syntax/hitest.vim
このコマンドは新しいウィンドウを開き、そこに全ての強調グループ名を、それ自身の
色を使って表示する。

						*:colo* *:colorscheme* *E185*
:colo[rscheme] {name}	カラースキーム{name}を読み込む。これは'runtimepath'中
			から"colors/{name}.vim"というファイルを検索する。最初
			に見つかったものが読み込まれる。
			現在使われているカラースキームの名前を見るには: >
				:echo g:colors_name
<			再帰的な読み込みはされない。つまりカラースキームスクリ
			プト中で":colorscheme"を使うことはできない。

:hi[ghlight]		属性がセットされた強調グループを全て表示する。

:hi[ghlight] {group-name}
			1つの強調グループを表示する。

:hi[ghlight] clear	全ての強調をデフォルトに戻す。ユーザによって加えられた
			グループに対する強調が全て消去される。
			現在の'background'の値によってデフォルトの色が決まる。

:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
			1つの強調グループに対する強調を無効にする。デフォルト
			の色に戻すのではない。

:hi[ghlight] [default] {group-name} {key}={arg} ..
			強調グループを追加する、または既存のグループに対する強
			調を変更する。
			引数{key}={arg}については|highlight-args|を参照。
			オプショナルな引数[default]については
			|:highlight-default|を参照。

通常、強調グループはスタートアップ時に一度だけ追加される。これは強調のデフォル
ト値をセットする。その後、強調コマンドを使うことによってデフォルトでない値に変
えることができる。値"NONE"を使うとその値をオフにしたりデフォルト値に戻したりで
きる。

色を変える簡単な方法は|:colorscheme|コマンドを使うことである。これは次のような
":highlight"コマンドがいくつか書かれたファイルを読み込む: >

   :hi Comment	gui=bold

ファイルに含まれない設定は変更されないままである。指定されたフィールドだけが使
われ、設定がそれ以前のものとマージされる。なのでその結果は次のコマンド1つが実
行されるのと同じである: >
   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold
<
					*highlight-args* *E416* *E417* *E423*
強調に関しては3種類のターミナルがある:
term	通常のターミナル(vt100, xterm)
cterm	カラーターミナル(MS-DOS console, color-xterm, これらは"Co"という
	termcapエントリをもつ) 
gui	GUI

それぞれのタイプに対して強調を指定することができる。これによって同じ構文ファイ
ルを全てのターミナルに対して使用することができ、最善の強調を利用できるようにな
っている。

1. highlightコマンドの引数(通常のターミナル用)

term={attr-list}			*attr-list* *highlight-term* *E418*
	attr-listはカンマ区切りのリスト(スペースは入れない)で、要素は以下の通
	り(順序はどうでもよい):
		bold
		underline
		reverse
		inverse		reverseと同じ
		italic
		standout
		NONE		属性を使用しない(属性をリセットするために使う)

	ここで"bold"を指定してもよいし、太文字のフォントを使ってもよい。どちら
	も同じことになる。

start={term-list}				*highlight-start* *E422*
stop={term-list}				*term-list* *highlight-stop*
	これらのターミナルコードのリストを使ってターミナルについての標準的でな
	い属性を得ることができる。

	引数"start"でエスケープシーケンスを指定すると、強調するテキストの前に
	それが書き込まれる。そのテキストを強調する際にターミナルに送りたいもの
	をなんでも指定できる。引数"stop"でエスケープシーケンスを指定すると、強
	調されるテキストの後にそれが書き込まれる。"start"で行ったことを"stop"
	で元に戻すべきである。そうしないとスクリーンがごちゃごちゃになってしま
	うだろう。

	{term-list}は2つの形を持つ:

	1. エスケープシーケンス付きの文字列。
	   これは"t_"で始まるものと空文字列を除く任意の文字列である。"<Esc>"や
	   "<Space>"のような<>記法が認識される。例:
		start=<Esc>[27h;<Esc>[<Space>r;

	2. ターミナルコードのリスト。
	   ターミナルコードは"t_xx"の形を持つ。"xx"はtermcapエントリ名である。
	   ターミナルコードはカンマで区切る。ホワイトスペースは使えない。例:
		start=t_C1,t_BL
	   対応するターミナルコードが存在しなければならない。

2. highlightコマンドの引数(カラーターミナル用)

cterm={attr-list}					*highlight-cterm*
	{attr-list}の説明は上を参照|attr-list|。
	色を使う場合、引数"cterm"は"term"と異なる結果になる。例えば、通常のタ
	ーミナルではコメントにアンダーラインを引き、カラーターミナルではコメン
	トを青色で表示することができる。
	注意:DOSコンソールなど多くのターミナルでは色づけの際にこれらの属性を混
	在させることはできない。"cterm="か"ctermfg="が"ctermbg="のどれか1つだ
	けを使うこと。

ctermfg={color-nr}				*highlight-ctermfg* *E421*
ctermbg={color-nr}				*highlight-ctermbg*
	引数{color-nr}で色番号を指定する。色番号の範囲は0からtermcapエントリ
	"Co"で与えられる数(それ自身は含まない)までである。
	この色番号で実際に表示される色はターミナルの種類とその設定に依存する。
	"cterm"の設定によって色が変わる場合もある。例えば、あるシステムでは
	"cterm=bold ctermfg=3"でそのまま3番の色を表示し、他のシステムでは異な
	る色を表示することがある。

	xtermにおいてはこれはユーザのリソースに依存し、やや予測ができない。デ
	フォルトについてはxtermのドキュメントを参照のこと。カラーxterm用の色は
	.Xdefaultsファイルで変更することができる。このため、ユーザごとに表示さ
	れる色が異なるかもしれない。カラーxtermについては|xterm-color|を参照。

	コンソールウィンドウ内のMSDOS標準色は固定されている。そのため、これら
	の色を名前に使っている。一方、X11の色名の意味は固定されている。そこで
	強調の設定に可搬性を持たせるため、X11の色設定が使われている(複雑である
	が)。以下の名前が認識され、色番号とともに使われる:

							*cterm-colors* 
	    NR-16   NR-8    COLOR NAME ~
	    0	    0	    Black
	    1	    4	    DarkBlue
	    2	    2	    DarkGreen
	    3	    6	    DarkCyan
	    4	    1	    DarkRed
	    5	    5	    DarkMagenta
	    6	    3	    Brown, DarkYellow
	    7	    7	    LightGray, LightGrey, Gray, Grey
	    8	    0*	    DarkGray, DarkGrey
	    9	    4*	    Blue, LightBlue
	    10	    2*	    Green, LightGreen
	    11	    6*	    Cyan, LightCyan
	    12	    1*	    Red, LightRed
	    13	    5*	    Magenta, LightMagenta
	    14	    3*	    Yellow, LightYellow
	    15	    7*	    White

	    "NR-16"の下の番号は16色ターミナル('t_Co'が16以上のもの)用である。
	    "NR-8"の下の番号は8色ターミナル('t_Co'が16以下のもの)用である。
	    '*'はctermfgにbold属性がセットされることを意味している。"linux"な
	    ど多くの8色ターミナルでは明るい色になる。ただし背景色には適用され
	    ない。'*'がないものはbold属性なしになる。他の方法でbold属性をつけ
	    たいなら引数"cterm="を"ctermfg="や"ctermbg="の後に書くこと。または
	    色名の代わりに番号を使うこと。

	    色名の大文字・小文字は無視される。
	    16色ansiスタイルターミナル(xtermを含む)ではNR-8の列の番号が使われ
	    ることに注意。ここで'*'は'add 8'という意味になる。つまりBlueが12
	    に、DarkGrayが8になる。

	    カラーターミナルによっては、色名を使うと間違った色で表示される場合
	    もあることに注意。

							*:hi-normal-cterm*
	Normalグループに対して"ctermfg"や"ctermbg"を設定すると、これらは強調さ
	れないテキストに対する色になる。
	例: >
		:highlight Normal ctermfg=grey ctermbg=darkblue
<	Normalグループに対して"ctermbg"を設定すると、オプション'background'が
	自動的に調整される。これによって'background'に依存する強調グループが変
	更される。そのため、まずNormalに対する色を設定し、それから他の色を設定
	するべきである。
	カラースキーム使用時に'background'を変更するとカラースキームが再読み込
	みされる。そしてNormalを含む全ての色がリセットされる。これが嫌なら最初
	に変数"colors_name"を削除すること。

	Normalグループに対して"ctermfg"や"ctermbg"を設定すると、Vim終了時にそ
	の色をリセットする必要がある。これはtermcapエントリ"op"|t_op|を使って
	なされる。これがうまくいかない場合は.vimrc中で't_op'を設定してみるこ
	と。
							*E419* *E420*
	Vimが通常の文字色と背景色を知っているなら"fg"と"bg"を色名として使え
	る。これはNormalグループの色とMS-DOSコンソールの色を設定しないと使えな
	い。例えば反転表示をするには: >
	    :highlight Visual ctermfg=bg ctermbg=fg
<	このコマンドを実行した時点で有効な色が使われることに注意。この後で
	Normalグループを変更しても"fg"と"bg"は調整されない。


3. highlightコマンドの引数(GUI用)

gui={attr-list}						*highlight-gui*
	これらはGUIモードで使われる属性を設定する。
	説明は|attr-list|を参照。
	ここで"bold"を設定しても太字のフォントを使ってもよい。どちらも同じ効果
	を持つ。
	"Normal"グループに対する属性は無視される。

font={font-name}					*highlight-font*
	font-nameはVimを実行しているシステム上で使われるフォント名である。X11
	ではこれは複雑な名前になる。例えば: >
   font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1
<
	フォント名"NONE"を使うとデフォルトのフォントに戻る。
	"Normal"グループに対してフォントを設定すると、これがデフォルトフォント
	になる(オプション'guifont'が変更されるまでは; 最後に設定したものが使わ
	れる)。
	以下のものはMotifとAthena上でのみ動作し、他のGUI上では利用できない:
	"Menu"グループに対してフォントを設定すると、メニューが変更される。
	"Tooltip"グループに対してフォントを設定するt、ツールチップが変更され
	る。
	Menu用とTooltip用を除く全てのフォントのサイズがデフォルトフォントのサ
	イズと同じでなければならない。そうでないと再描画の際に問題が発生する。

guifg={color-name}					*highlight-guifg*
guibg={color-name}					*highlight-guibg*
	guifgは文字色、guibgは背景色を指定する。いくつか特別な名前がある:
		NONE		no color (透明)
		bg		通常の背景色を使う
		background	通常の背景色を使う
		fg		通常の文字色を使う
		foreground	通常の文字色を使う
	埋め込みスペースや他の特別な文字に対して色名を使うには、色名をシングル
	クォートでくくる。それゆえシングルクォートを使うことはできない。
	例: >
	    :hi comment guifg='salmon pink'
< 
							*gui-colors*
	推奨されている色名 (これらはほとんどのシステムで利用可能である)
	    Red		LightRed	DarkRed
	    Green	LightGreen	DarkGreen	SeaGreen
	    Blue	LightBlue	DarkBlue	SlateBlue
	    Cyan	LightCyan	DarkCyan
	    Magenta	LightMagenta	DarkMagenta
	    Yellow	LightYellow	Brown		DarkYellow
	    Gray	LightGray	DarkGray
	    Black	White
	    Orange	Purple		Violet

	Win32 GUIバージョンでは他にもシステムカラーが利用できる。
	|win32-colors|を参照。

	RGB値によって色を指定することもできる。
	フォーマットは"#rrggbb"、ここで
		"rr"	Red値
		"bb"	Blue値
		"gg"	Green値
	これらの値は16進であり、範囲は"00"から"ff"。例: >
  :highlight Comment guifg=#11f0c3 guibg=#ff00ff
<
					*highlight-groups* *highlight-default*
以下はデフォルトの強調グループである。これらのグループはデフォルトでオプション
'highlight'によって使われる。ただし強調は'background'の値に依存することに注
意。":highlight"コマンドで現在の設定を知ることができる。
							*hl-Cursor*
Cursor		カーソル下の文字
							*hl-CursorIM*
CursorIM	Cursorと同じだが、IMEモードにいるとき使われる|CursorIM|。
							*hl-Directory*
Directory	ディレクトリ名(とリストにある特別な名前)
							*hl-DiffAdd*
DiffAdd		diffモード: 追加された行 |diff.txt|
							*hl-DiffChange*
DiffChange	diff モード: 変更された行 |diff.txt|
							*hl-DiffDelete*
DiffDelete	diff モード: 削除された行 |diff.txt|
							*hl-DiffText*
DiffText	diff モード: 変更された行中の変更されたテキスト |diff.txt|
							*hl-ErrorMsg*
ErrorMsg	コマンドラインに現れるエラーメッセージ
							*hl-VertSplit*
VertSplit	垂直分割したウィンドウの区切りとなる桁
							*hl-Folded*
Folded		閉じた折り畳みの行
							*hl-FoldColumn*
FoldColumn	'foldcolumn'
							*hl-SignColumn*
SignColumn	目印|signs|が表示される行。
							*hl-IncSearch*
IncSearch	'incsearch'の強調; ":s///c"で置換されたテキストにも使われる。
							*hl-LineNr*
LineNr		":number"と":#"コマンドの行番号。オプション'number'がセットさ
		れているときはそれにも使われる。
							*hl-ModeMsg*
ModeMsg		'showmode'のメッセージ (例. "-- INSERT --")
							*hl-MoreMsg*
MoreMsg		|more-prompt|
							*hl-NonText*
NonText		ウィンドウの端の'~'と'@'、'showbreak'で設定された文字など、実
		際のテキストには存在しない文字(例. 倍幅文字が行末に収まらない
		とき">"が表示される)。
							*hl-Normal*
Normal		通常のテキスト
							*hl-Question*
Question	ヒットエンタープロンプト|hit-enter|とyes/noクエスチョン
							*hl-Search*
Search		最後に検索した語の強調('hlsearch')を参照。
		quickfixウィンドウ内の現在行の強調や、それに類するものにも使わ
		れる。
							*hl-SpecialKey*
SpecialKey	":map"でリストされるメタキーと特別なキー。テキスト中の
		unprintableな文字を表示するのにも使われる。
		一般に: 実際とは異なる文字で表示されるテキスト
							*hl-StatusLine*
StatusLine	カレントウィンドウのステータスライン
							*hl-StatusLineNC*
StatusLineNC	非カレントウィンドウのステータスライン。
		Note: これが"StatusLine"に等しい場合、カレントウィンドウのステ
		ータスラインに"^^^"が使われる。
							*hl-Title*
Title		":set all"、":autocmd"などによる出力のタイトル。
							*hl-Visual*
Visual		ビジュアルモード選択
							*hl-VisualNOS*
VisualNOS	vimが"Not Owning the Selection"のときのビジュアルモード選択。
		これをサポートしているのはX11GUI|gui-x11|と|xterm-clipboard|の
		み。
							*hl-WarningMsg*
WarningMsg	警告メッセージ
							*hl-WildMenu*
WildMenu	'wildmenu'補完における現在の候補

						*hl-User1* *hl-User1..9*
'statusline'構文によってステータスラインとルーラー('rulerformat'によって)中で9
個の強調が使えるようになっている。その名前はUser1からUser9である。

GUI使用時には、これらのグループを使ってメニューやスクロールバー、ツールチップ
の色を設定することができる。これらにデフォルト値はない。これはWin32では利用で
きない。ここではhighlightの引数のうちfont, guibg, guifgの3つだけが効果を持つ。

							*hl-Menu*
Menu		メニューのフォント、文字、背景。ツールバーにも使われる。
		使用可能なhighlightの引数: font, guibg, guifg.

		NOTE: MotifとAthenaでは'guifontset'が空かどうかに関わらず、常
		に引数fontで実際のフォントセットを指定する。そしてそれが現在の
		|:language|に結び付けられる。

							*hl-Scrollbar*
Scrollbar	メインウィンドウのスクロールバーの文字と背景。
		使用可能なhighlightの引数: guibg, guifg.

							*hl-Tooltip*
Tooltip		ツールチップのフォント、文字、背景。
		使用可能なhighlightの引数: font, guibg, guifg.
    
		NOTE: MotifとAthenaでは'guifontset'が空かどうかに関わらず、常
		に引数fontで実際のフォントセットを指定する。そしてそれが現在の
		|:language|に結び付けられる。

==============================================================================
13. グループのリンク		*:hi-link* *:highlight-link* *E412* *E413*

複数の構文グループに対して同じ強調をつけたいときは、それらのグループを共通の強
調グループにリンクし、そのグループに対して色属性を与えると簡単である。

リンクを作るには:

    :hi[ghlight][!] [default] link {from-group} {to-group}

リンクを削除するには:

    :hi[ghlight][!] [default] link {from-group} NONE

Notes:							*E414*
- {from-group}か{to-group}のどちらかが存在しない場合、リンクは作成されない。こ
  の場合エラーメッセージは表示されない。
- リンクされたグループに対して":highlight"を使うと、即座にリンクが削除される。
- 既に{from-group}に強調設定がされている場合、'!'をつけないとリンクは作成され
  ない。sourceされたファイル中の":highlight link"コマンドに関して、エラーメッ
  セージは表示されない。そのため既に設定を持つグループに対するリンクがスキップ
  される。

					*:hi-default* *:highlight-default*
引数[default]によってグループに対するデフォルトの強調を設定することができる。
そのグループに対して既に強調が指定されている場合、このコマンドは無視される。既
にリンクが存在する場合も同様。

[default]は特定の構文ファイルの強調を上書きするのに特に便利である。例えばC構文
ファイルは次の行を含んでいる: >
	:highlight default link cComment Comment
Cコメントに対してQuestionの強調をつけたい場合、これをvimrcファイルに加える: >
	:highlight link cComment Question
もしC構文ファイル中の"default"がないと、構文ファイルが読み込まれた時点で強調が
上書きされてしまう。

==============================================================================
14. 構文の消去    					*:syn-clear* *E391*

カレントバッファに対する構文設定を消去したいときはこのコマンドを使う: >
  :syntax clear

このコマンドは、構文強調をオフにしたいときや他の構文を適用したいときに使う。通
常、これを構文ファイル内で行う必要はない。なぜなら、構文ファイルを読み込む自動
コマンドによって構文がクリアされる。
また、このコマンドは変数"b:current_syntax"を削除する。このコマンドの実行後には
すべての構文がなくなるからである。

全てのバッファに対して構文強調を無効にしたいときは、構文ファイルを読み込む自動
コマンドを削除する必要がある: >
  :syntax off

このコマンドが実際に行うことは次のコマンドを実行するのと同じである: >
  :source $VIMRUNTIME/syntax/nosyntax.vim
詳細は"nosyntax.vim"を参照。これが正常に機能するためには$VIMRUNTIMEが正しく設
定されている必要がある。|$VIMRUNTIME|を参照。

カレントバッファに対する特定の構文グループを消去するには: >
  :syntax clear {group-name} ..
これは{group-name}に対する全てのパターンとキーワードを消去する。

カレントバッファに対する特定の構文グループリストを消去するには: >
  :syntax clear @{grouplist-name} ..
これは{grouplist-name}の中身を空リストにセットする。

						*:syntax-reset* *:syn-reset*
色を変えたため、色がごちゃごちゃになってしまったときは、次のコマンドを使うとデ
フォルトに戻る: >

  :syntax reset

これはオプション'highlight'に対する色は変更しない。

ユーザのvimrcファイル中で設定した構文色もVimのデフォルト値に戻ることに注意。
カラースキームを使っている場合、カラースキームによって定義された色は失われるこ
とに注意。

このコマンドが実際に行うことは: >

	let g:syntax_cmd = "reset"
	runtime! syntax/syncolor.vim

ここでオプション'runtimepath'が使われていることに注意。

							*syncolor*
構文強調に別の色を使いたければ、その色を設定するVimスクリプトを作ればよい。そ
のファイルを'runtimepath'中('runtimepath'は$VIMRUNTIMEを含む)のディレクトリに
置くと、その設定がデフォルトの色設定を上書きする。こうして":syntax reset"コマ
ンドを実行すると、それらの色が有効になる。

Unixでは~/.vim/after/syntax/syncolor.vimファイルを使うとよい。例: >

	if &background == "light"
	  highlight comment ctermfg=darkgreen guifg=darkgreen
	else
	  highlight comment ctermfg=green guifg=green
	endif

カラースキームを使用すると、ユーザ定義の色が使われるのか、それともカラースキー
ムで定義された色が使われるのかわからなくなる場合がある。これはカラースキーム
ファイルに依存する。|:colorscheme|を参照。

							*syntax_cmd*
syntax/syncolor.vimファイルが読み込まれると、変数"syntax_cmd"が次の3つの値のう
ちどれかにセットされる:
   "on"		":syntax on" コマンド。強調色が上書きされるがリンクはそのまま。
   "enable"	":syntax enable" コマンド。まだ強調が定義されていないグループ
	        に対して色を定義するだけ。":syntax default"を使うこと。
   "reset"	":syntax reset" コマンドまたはカラースキームを読み込む。全ての
	        色を定義する。
   "skip"	色を定義しない。'runtimepath'中で前にあるsyncolor.vimファイル
	        が既にデフォルト設定をセットしてあるとき、デフォルト設定をスキ
		ップするために使われる。

==============================================================================
15. タグの強調			 			*tag-highlight*

ファイル中の全てのタグを強調したければ、次のマッピングを使うとよい。

	<F11>	-- tags.vimファイルを生成し、タグを強調する。
	<F12>	-- 既存のtags.vimファイルをもとに強調する。
>
  :map <F11>  :sp tags<CR>:%s/^\([^	:]*:\)\=\([^	]*\).*/syntax keyword Tag \2/<CR>:wq! tags.vim<CR>/^<CR><F12>
  :map <F12>  :so tags.vim<CR>

WARNING: tagsファイルが長くなるほどこの操作は遅くなり、消費するメモリ量も多く
なる。

typedef、union、structだけを強調することもできる。そのためにはExuberant ctags
(http://ctags.sf.netで入手可能)を使わねばならない。

以下をあなたのMakefileに加える:

# 型用の強調ファイルを作成する。Exuberant ctagsとawkが必要
types: types.vim
types.vim: *.[ch]
	ctags -i=gstuS -o- *.[ch] |\
		awk 'BEGIN{printf("syntax keyword Type\t")}\
			{printf("%s ", $$1)}END{print ""}' > $@

そして以下を.vimrcに加える: >

   " load the types.vim highlighting file, if it exists
   autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'
   autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)
   autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname
   autocmd BufRead,BufNewFile *.[ch] endif

==============================================================================
16. カラーxterms				*xterm-color* *color-xterm*

ほとんどのカラーxtermは8色しか持たない。デフォルト設定で色がつかない場合は以下
を.vimrcに加えると正常に色がつくはずである: >
   :if &term =~ "xterm"
   :  if has("terminfo")
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%p1%dm
   :	set t_Sb=<Esc>[4%p1%dm
   :  else
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%dm
   :	set t_Sb=<Esc>[4%dm
   :  endif
   :endif
<	[<Esc> is a real escape, type CTRL-V <Esc>]

最初の"if"を自分のターミナル名にマッチするように変更する必要があるかもしれない
e.g. "xterm"でなく"dtterm"。

Note: これらの設定は":syntax on"の前に行うこと。そうでないと色がおかしくなって
しまう。
							*xiterm* *rxvt*
上の設定はxitermとrxvtでも動作するように注意されている。しかしrxvtで16色を使う
場合にはterminfoを設定しなければならない: >
	:set t_AB=<Esc>[%?%p1%{8}%<%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm
	:set t_AF=<Esc>[%?%p1%{8}%<%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm

							*colortest.vim*
色設定をテストするためのファイルがVimディストリビューションに入っている。これ
を使うには次のコマンドを実行する: >
   :e $VIMRUNTIME/syntax/colortest.vim
   :so %

xtermのあるバージョン(とlinuxコンソールのような他のターミナル)は、たとえ色数が
8に定義されていても、より明るい文字色を出力することができる。そのため't_Co'が
8のとき、Vimは明るい文字色に対して"cterm=bold"属性をセットする。

							*xfree-xterm*
16色以上を使うにはxtermの最新バージョンを入手すること(Xfree86 3.3以降に含まれ
ているはずである)。また、以下の場所でも最新バージョンが得られる: >
	http://invisible-island.net/xterm/xterm.html
次にそれをconfigureするよい方法を示す。これは88色を使い、termcap-query機能を有
効化する。これによってVimがxtermに何色をサポートしているか問い合わせることがで
きるようになる >
	./configure --disable-bold-color --enable-88-color --enable-tcap-query
もし8色しか使えなかったらxtermのコンパイル設定を確認すること。
(このxtermをUTF-8文字コーディングで使う場合には|UTF8-xterm|も参照)。

以下を.vimrcに加えるとこのxtermで動くはずである(16色用): >
   :if has("terminfo")
   :  set t_Co=16
   :  set t_AB=<Esc>[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm
   :  set t_AF=<Esc>[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm
   :else
   :  set t_Co=16
   :  set t_Sf=<Esc>[3%dm
   :  set t_Sb=<Esc>[4%dm
   :endif
<	[<Esc> は実際のエスケープ, CTRL-V <Esc>とタイプする]

|+terminfo|なしではVimはこれらの設定を認識し、自動的にctermの8色と上の設定を
"<Esc>[9%dm" と "<Esc>[10%dm"に変換する。16色以上も自動的に変換される。

以下の設定が256色用にうまくいくと報告されている: >

   :set t_AB=<Esc>[48;5;%dm
   :set t_AF=<Esc>[38;5;%dm

または単にTERM環境変数を"xterm-color"または"xterm-16color"にセットし、うまくい
くか試してみるとよい。

以下のX resourcesを(~/.Xdefaultsファイルで)使いたいかもしれない:
	XTerm*color0:			#000000
	XTerm*color1:			#c00000
	XTerm*color2:			#008000
	XTerm*color3:			#808000
	XTerm*color4:			#0000c0
	XTerm*color5:			#c000c0
	XTerm*color6:			#008080
	XTerm*color7:			#c0c0c0
	XTerm*color8:			#808080
	XTerm*color9:			#ff6060
	XTerm*color10:			#00ff00
	XTerm*color11:			#ffff00
	XTerm*color12:			#8080ff
	XTerm*color13:			#ff40ff
	XTerm*color14:			#00ffff
	XTerm*color15:			#ffffff
	Xterm*cursorColor:		Black

[Note: cursorColorにはバグがある。カーソルの色が最後に描画されたテキストの色に
なってしまうというものである。これはxtermの新しいバージョンを使うと解決する
が、まだ全ての人がそれを使っているわけではない。]

これらを即座に更新するには.XdefaultsファイルをXオプションデータベースマネー
ジャに再読み込みさせる(.Xdefaultsを変更したときはこれを行う必要がある): >
  xrdb -merge ~/.Xdefaults
					*xterm-blink* *xterm-blinking-cursor*
xtermでカーソルを点滅させるにはtools/blink.cを見ること。またはThomas Dickeyの
xtermのパッチレベル107以上を使い(入手場所は上を参照)、以下のリソースを設定す
る。
	XTerm*cursorBlink:	on
	XTerm*cursorOnTime:	400
	XTerm*cursorOffTime:	250
	XTerm*cursorColor:	White

							*hpterm-color*
次の設定はhptermで(大体)うまく機能する。文字色は8色だけサポートしている: >
   :if has("terminfo")
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%p1%dS
   :  set t_Sb=<Esc>[&v7S
   :else
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%dS
   :  set t_Sb=<Esc>[&v7S
   :endif
<	[<Esc> は実際のエスケープ, CTRL-V <Esc>とタイプする]

						*Eterm* *enlightened-terminal*
次の設定がEnlightenedターミナルエミュレータまたはEtermで機能すると報告されてい
る。また、明るい色を表示するのにbold属性を使うxtermライクターミナル全てで機能
すると思われる。必要なら前述のように":if"をつけること。 >
       :set t_Co=16
       :set t_AF=^[[%?%p1%{8}%<%t3%p1%d%e%p1%{22}%+%d;1%;m
       :set t_AB=^[[%?%p1%{8}%<%t4%p1%d%e%p1%{32}%+%d;1%;m
<
						*TTpro-telnet*
次の設定がTTpro telnet用にうまくいく。Tera Term ProはMS-Windows用のフリーウェ
ア/オープンソースプログラムである。 >
	set t_Co=16
	set t_AB=^[[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{32}%+5;%;%dm
	set t_AF=^[[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{22}%+1;%;%dm
また、TTproのSetup/Window/Full Colorが有効になっていることとSetup/Font/Enable
Boldが有効になっていないことを確認すること。
(この情報はJohn Love-Jensen <eljay@Adobe.COM>によって提供された)

 vim:tw=78:sw=4:ts=8:ft=help:norl:
