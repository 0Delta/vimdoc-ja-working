COMMENT: 構文強調(テキストの色つけ)
STATUS: suspend 6.1
TRANSLATOR: 村岡太郎 <koron@tka.att.ne.jp>
TRANSLATOR: nakadaira <hopper2@nanameue.jp>

*syntax.txt*    For Vim version 6.1.  Last change: 2002 Mar 24


		VIMリファレンスマニュアル    by Bram Moolenaar


構文強調			*syntax* *syntax-highlighting* *coloring*

Vimは構文強調によりテキストの一部を異なるフォントや色で表示することができるよ
うになる。強調する箇所はキーワードやテキストのパターンにより指定することができ
る。Vimはファイル全体を構文解析するわけではないから(動作を速く保つため)、この
強調方法には限界が存在する。単語(レキシカル)強調と呼ぶのがより正しいが、皆が構
文強調と呼ぶのでそう呼び続けている。

Vimは全ての端末で構文強調をサポートしている。しかし多くの普通の端末には非常に
限られた強調効果しか提供されていないので、強調の最も良い効果はGUI版のgvimで動
作する。

ユーザマニュアルにおける記述:
|usr_06.txt| 構文強調の紹介。
|usr_44.txt| 構文ファイルの記述方法の紹介。

1.  クイックスタート		|:syn-qstart|
2.  構文強調ファイル		|:syn-files|
3.  構文ファイル読込の手順	|syntax-loading|
4.  構文ファイルの覚書		|:syn-file-remarks|
5.  Defining a syntax		|:syn-define|
6.  :syntax arguments		|:syn-arguments|
7.  Syntax patterns		|:syn-pattern|
8.  Syntax clusters		|:syn-cluster|
9.  Including syntax files	|:syn-include|
10. Synchronizing		|:syn-sync|
11. Listing syntax items	|:syntax|
12. Highlight command		|:highlight|
13. Linking groups		|:highlight-link|
14. Cleaning up			|:syn-clear|
15. Highlighting tags		|tag-highlight|
16. Color xterms		|xterm-color|

{これらのコマンドはViには存在しない}

コンパイル時に|+syntax|機能を無効にした場合には構文強調は利用することはできな
い。

==============================================================================
1. クイックスタート					*:syn-qstart*

						*:syn-enable* *:syntax-enable*
次のコマンドで構文強調が有効になる: >

	:syntax enable

このコマンドにより実際には次のコマンドが実行される >
	:source $VIMRUNTIME/syntax/syntax.vim

環境変数VIMが設定されていない場合は、Vimは別の方法(|$VIMRUNTIME|参照)でパスの
検索を試みる。通常これでうまくいく。もしもうまく動作しない場合、環境変数VIMに
Vimの構成ファイルが置いてあるディレクトリの設定を試みる。例えば、構文ファイル
がディレクトリ"/usr/vim/vim50/syntax"にあるならば、$VIMRUNTIMEに
"/usr/vim/vim50"を設定する。これはVimを起動する前に、シェルで設定しておかなけ
ればならない。

							*:syn-on* *:syntax-on*
コマンド":syntax enable"は現在の色設定を保持する。これによりこのコマンドを使用
する前後にコマンド":highlight"で好みの色を設定することが可能になる。Vimにより
強制的にデフォルトの色を設定させたい場合は次のコマンドを使用する: >
	:syntax on
<
					*:hi-normal* *:highlight-normal*
GUIを使用している場合は、次のコマンドで黒地に白文字を設定できる: >
	:highlight Normal guibg=Black guifg=White
カラー端末については|:hi-normal-cterm|を参照。
独自色の構文強調を設定する方法については|syncolor|を参照。

NOTE: MS-DOSとWindowsの構文ファイルは改行コードが<CR><NL>である。UNIXでは<NR>
である。これは使用しているシステムに合ったタイプのファイルを使わなければならな
いことを意味している。しかしながらMS-DOSとWindowsではオプション'fileformats'が
空でなければ正しい形式が自動的に選択される。

NOTE: 反転表示("gvim -fg white -bg black"、訳注:黒地に白文字)を使用する際は、.
gvimrcが読込まれた後で、GUIウィンドウが開かれるまでオプション'background'のデ
フォルト値が設定されない。そのせいで誤ったデフォルト強調手法が使用されてしま
う。強調表示を有効化する前に'background'のデフォルト値を設定するには、.gvimrc
にコマンド":gui"を含める: >

   :gui		" ウィンドウを開き'background'にデフォルト値を設定する
   :syntax on	" 強調を有効化し、色を設定するのに'background'を使用する

NOTE: .gvimrcの中で":gui"を使用すると"gvim -f"によりフォアグラウンドで開始する
ことができなくなる。その際は":gui -f"を使用すること。


次のコマンドで構文強調の有・無効を切換えることができる >
   :if exists("syntax_on") | syntax off | else | syntax enable | endif

これをキーマップに設定するには、以下の設定を使うことができる: >
   :map <F7> :if exists("syntax_on") <Bar>
	\   syntax off <Bar>
	\ else <Bar>
	\   syntax enable <Bar>
	\ endif <CR>
[|<>|表記を入力する際は、文字通りそのままキー入力する]

詳細 ~
コマンド":syntax"はファイルを取り込む(訳注:source)ことで実装されている。その際
取り込まれるファイルの中身を見ることで、このコマンドがどのように動作しているの
か正確に知ることができる。
    コマンド		ファイル ~
    :syntax enable	$VIMRUNTIME/syntax/syntax.vim
    :syntax on		$VIMRUNTIME/syntax/syntax.vim
    :syntax manual	$VIMRUNTIME/syntax/manual.vim
    :syntax off		$VIMRUNTIME/syntax/nosyntax.vim
|syntax-loading|も参照。

==============================================================================
2. 構文強調ファイル					*:syn-files*

ある1つの言語用の構文と強調色定義コマンドは通常1つのファイル(以下構文ファイル)
に格納される。名前は"{name}.vim"と付ける慣習になっている。{name}はその言語の名
前か短縮名となる(DOSファイルシステムで要求される、8.3文字の形式にあわせること
が望ましい)。
例:
	c.vim		perl.vim	java.vim	html.vim
	cpp.vim		sh.vim		csh.vim

構文ファイルはvimrcファイルと同様にExコマンドを記述することができる。しかし1つ
のファイルには或る1つの言語用コマンドのみを記載するよう取り決めている。ある言
語が別の言語のスーパーセットである時には、他のファイルを内包していても良く、例
えば、ファイルcpp.vimはファイルc.vimを取り込むようになっている: >
   :so $VIMRUNTIME/syntax/c.vim

通常それら構文ファイル*.vimは自動実行コマンドにより読込まれる。例: >
   :au Syntax c	    source $VIMRUNTIME/syntax/c.vim
   :au Syntax cpp   source $VIMRUNTIME/syntax/cpp.vim
通常このようなコマンドはファイル$VIMRUNTIME/syntax/synload.vimに在る。


独自構文ファイルの作成					*mysyntaxfile*

独自の構文ファイルを作成し、そのファイルを":syntax enable"によって自動的にVim
に使わせるようにするには、以下のようにする:

1. ユーザランタイムディレクトリを作成する。通常はオプション'runtimepath'に示さ
   れる最初のディレクトリを使用する。UNIXの例では: >
	mkdir ~/.vim

2. "syntax"という名のディレクトリを作成する。UNIXでは: >
	mkdir ~/.vim/syntax

3. Vimの構文ファイルを作成する。もしくはインターネットからダウンロードする。そ
   のファイルはディレクトリsyntaxに置く。構文"mine"の例では: >
	:w ~/.vim/syntax/mine.vim

これで独自構文ファイルを手動で使うことはできるようになっている: >
	:set syntax=mine
このコマンドを実行するためにVimを再起動する必要はない。

Vimにそのファイル形式を認識させたいならば、|new-filetype|を参照。

システム管理者としてユーザ全てに独自構文ファイルを使わせる際には、各ユーザに同
じ構文ファイルをインストールさせる必要はなく、'runtimepath'に示される他の各
ユーザ共通のディレクトリにインストールすることができる。


既存の構文ファイルに設定を追加する		*mysyntaxfile-add*

既存の構文ファイルでほぼ満足だが、幾つかの設定を追加したり強調手法を変更したい
場合には、以下の手順に従う:

1. 上同様、'runtimepath'に示されるユーザディレクトリを作成する。

2. "after/syntax"というディレクトリを作成する。UNIXの例: >
	mkdir ~/.vim/after
	mkdir ~/.vim/after/syntax

3. 追加設定を行なうコマンドを含むVimスクリプトファイルを作成する。例として、C
   構文の色を変更するならば: >
	highlight cComment ctermfg=Green guifg=Green

4. その設定ファイルをディレクトリ"after/syntax"に置く。名前には構文名に".vim"を
   追加して使用する。Cの構文を拡張するならば: >
	:w ~/.vim/after/syntax/c.vim

以上。次回Cのファイルを編集する時にはコメントが異なった色で表示される。Vimを再
起動する必要はない。


既存の構文ファイルを置き換える				*mysyntaxfile-replace*

配布される構文ファイルが気に入らない場合や、新しいバージョンをダウンロードした
際には、上で述べた|mysyntaxfile|に従えば良い。ただ'runtimepath'内のより先に記
されたディレクトリに構文ファイルを置くように気を付ければ良い。Vimは適合する構
文ファイルのうち最初に見つけた1つだけを読込む。


名前付けの慣習		
							*group-name*
各ユーザが好みの色セットを使用できるように、多くの言語に共通する強調グループに
は優先名が与えられている。推奨されているグループ名は以下のとおり:

	*Comment	コメント

	*Constant	定数
	 String		文字列定数: "これは文字列です"
	 Character	文字定数: 'c', '\n'
	 Number		数値定数: 234, 0xff
	 Boolean	ブール値の定数: TRUE, false
	 Float		不動小数点数の定数: 2.3e10

	*Identifier	変数名
	 Function	関数名(クラスメソッドを含む)

	*Statement	命令文
	 Conditional	if, then, else, endif, switch, その他
	 Repeat		for, do, while, その他
	 Label		case, default, その他
	 Operator	"sizeof", "+", "*", その他
	 Keyword	その他のキーワード
	 Exception	try, catch, throw

	*PreProc	一般的なプリプロセッサ命令
	 Include	#include プリプロセッサ
	 Define		#define プリプロセッサ
	 Macro		Defineと同値
	 PreCondit	プリプロセッサの #if, #else, #endif, その他

	*Type		int, long, char, その他
	 StorageClass	static, register, volatile, その他
	 Structure	struct, union, enum, その他
	 Typedef	typedef宣言

	*Special	特殊なシンボル
	 SpecialChar	特殊な文字定数
	 Tag		この上で CTRL-] を使うことができる
	 Delimiter	注意が必要な文字
	 SpecialComment	コメント内の特記事項
	 Debug		デバッグ命令

	*Underlined	目立つ文章, HTMLリンク

	*Ignore		(見た目上)空白, 不可視

	*Error		エラーなど、なんらかの誤った構造

	*Todo		特別な注意がひつようなもの; 大抵はTODO FIXME XXXなどの
			キーワード

マーク(*)されている名前が優先グループ、その他はマイナーグループである。優先グ
ループには、"syntax.vim"によりデフォルトの強調手法が定義されている。マイナーグ
ループは優先グループにリンクされ、リンクした先と同じ強調手法になる。ファイル
"syntax.vim"が読込まれた後でコマンド":highlight"を使えば、そのデフォルトを上書
することができる。

強調グループ名には大文字小文字の区別がないことに注意。"String" と "string"はど
ちらも同じグループを意味する。

以下の名前は予約されているのでグループ名として使用することはできない:
	NONE   ALL   ALLBUT   contains   contained

==============================================================================
3. 構文ファイル読込の手順				*syntax-loading*

ここではコマンド":syntax enable"を実行した時に何が起こるかの詳細を説明する。
Vimは初期化の時に、ランタイムファイルの在り処を自動的に発見する。ここでは変数
|$VIMRUNTIME|にその場所が格納されているとする。

":syntax enable" と ":syntax on"では以下のことが起こる:

    $VIMRUNTIME/syntax/syntax.vimを読込む
    |
    +-	$VIMRUNTIME/syntax/nosyntax.vimを読込んで古い構文を削除する
    |
    +-	'runtimepath'から$VIMRUNTIME/syntax/synload.vimを読込む
    |	|
    |	+-  構文強調の色を設定する。
    |	|   色テーマが定義されている場合は":colors {name}"で再度読込む。
    |	|   そうでない場合は":runtime! syntax/syncolor.vim"が使用される。
    |	|   ":syntax on"は既存の色設定を上書設定し、":syntax enable"はまだ設定
    |	|   されていないグループのみを設定する。
    |	|
    |	+-  適切な構文ファイルをオプション'syntax'が設定される時に読込む自動実
    |	|   行コマンドを設定する。 *synload-1*
    |	|
    |	+-  ユーザによる追加ファイルを変数|mysyntaxfile|から読込む。これは
    |       Vim 5.xとの互換性のためだけに存在する。 *synload-2*
    |
    +-	":filetype on"を実行し":runtime! filetype.vim"が実行される。これは見つ
    |	けることのできる全てのfiletype.vimを読込む。$VIMRUNTIME/filetype.vimは
    |	常に読込まれ、以下のことが実行される。
    |	|
    |	+-  拡張子に基づいてオプション'filetype'を設定する自動実行コマンドをイ
    |	|   ンストールする。これにより既知のファイル形式に付いて、ファイル名と
    |	|   当該形式との関連付けが成される。 *synload-3*
    |	|
    |	+-  ユーザによる追加ファイルを変数 *myfiletypefile* から読込む。これは
    |	|   Vim 5.xとの互換性のためだけに存在する。 *synload-4*
    |	|
    |	+-  ファイル形式が検出されなかった時にscripts.vimを読込むための自動実
    |	|   行コマンドをインストールする。 *synload-5*
    |	|
    |   +-  構文メニュー設定のため$VIMRUNTIME/menu.vimを読込む。 |menu.vim|
    |
    +-	ファイル形式が検出された時にオプション'syntax'を設定するためのFileType
    |	自動実行コマンドを設定する。 *synload-6*
    |
    +-	既に読込まれているバッファに対して構文強調を行なうために、関連した自動
	実行コマンドを実行する。


ファイルを読込む時には、Vimは以下のように関連した構文ファイルを見つける:

    ファイルを読込むとBufReadPost自動実行コマンドが起動する。
    |
    +-	|synload-3|(既知ファイル形式)か|synload-4|(ユーザ定義ファイル形式)の自
    |	動実行コマンドがヒットした場合、オプション'filetype'にそのファイル形式
    |	名が設定される。
    |
    +-	|synload-5|の自動実行コマンドが実行される。まだファイル形式が決定され
    |	ていない場合は、'runtimepath'からscripts.vimが検索される。これは常に以
    |	下のことを行なう$VIMRUNTIME/scripts.vimを読込む。
    |	|
    |	+-  ユーザによる追加ファイルを変数 *myscriptsfile* から読込む。これは
    |	|   Vim 5.xとの互換性のためだけに存在する。 *synload-4*
    |	|
    |	+-  未だにファイル形式が決定できない場合、ファイルの内容を検査する。検
    |	    査は"getline(1) =~ pattern"のように認識できるファイル形式かどうか
    |	    行なわれ、認識できるならば'filetype'を設定する。
    |
    +-	ファイル形式が決定されて'filetype'が設定された時に、上記|synload-6|の
    |	FileType自動実行コマンドが実行される。決定したファイル形式名がそれによ
    |	り'syntax'へ設定される。
    |
    +-	上記でオプション'syntax'が設定されると、|synload-1|(と|synload-2|)の自
    |	動実行コマンドが実行される。これにより次のコマンドでメインとなる構文
    |	ファイルが'runtimepath'から読込まれる。
    |		runtime! syntax/<name>.vim
    |
    +-	ユーザがインストールしたその他のFileTypeおよびSyntax自動実行コマンドが
	実行される。これは特定の構文の強調を変更するのに使うことができる。

==============================================================================
4. 構文ファイルの覚書					*:syn-file-remarks*

						*b:current_syntax-variable*
Vimはロードした構文の名前を変数"b:current_syntax"に記憶している。どの構文が選
択されたかに応じて他の設定を読込みたい時にはこれを使うことができる。例: >
   :au BufReadPost * if b:current_syntax == "csh"
   :au BufReadPost *   do-some-things
   :au BufReadPost * endif


2HTML						*2html.vim* *convert-to-HTML*

これは構文ファイルではなくて、現在のウィンドウの内容をHTMLに変換するスクリプト
である。Vimは新しいウィンドウを作成しそこにHTMLファイルを構築する。

使う際にはオプション'filetype'や'syntax'に"2html"を設定してはならない!
現在のファイルをコンバートするためにはこのスクリプトを読込む: >

	:runtime! syntax/2html.vim
<
	警告: この処理には時間がかかる!

主力結果をファイルに保存すれば、あらゆるNetscapeのようなHTML Viewerでそれを観
ることができる。Vimで表示されるのと寸分たがわぬ色が再現される。

オプション'number'が設定されている場合には、各行にNumberで強調された行番号が付
加される。"html_number_lines"に非0の値を設定すればHTMLの出力へ強制的に行番号を
付加することができる: >
   :let html_number_lines = 1
値0を設定すれば行番号を強制的に省略することができる: >
   :let html_number_lines = 0
変数を削除すればデフォルトの'number'を使うように戻すことができる: >
   :unlet html_number_lines

デフォルトでは、古いブラウザ用に最適化されたHTMLが生成される。属性を表現するの
にカスケードスタイルシートを使用したい場合には次の設定を使用する(結果的にかな
り短いHTML 4に準拠したファイルが得られる): >
   :let html_use_css = 1

覚書き:
- この機能はGUIをサポートしたバージョンでしか動作しない。(X11などの)GUIが実際
  に機能していない状況でも動作はするが、良い結果は得られない(色が異なってしま
  う)。
- 古いブラウザでは背景色が表示されないことがある。
- 大半のブラウザでは(なんとカラーで)印刷することができる!

ここではUNIXのシェル上で全ての.cと.hをコンバートする方法を例として示す: >
   for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
<

ABEL							*abel.vim* *abel-syntax*

ABELの強調にはユーザが定義できるオプションが幾つかある。それらを有効化するには
それぞれの変数に何か値を設定すれば良い。例: >
	:let abel_obsolete_ok=1
無効化するには":unlet"を使用する。例: >
	:unlet abel_obsolete_ok

変数				強調 ~
abel_obsolete_ok		古いキーワードをエラーでなく命令文として扱う
abel_cpp_comments_illegal	'//'をインラインコメントリーダとして扱わない


ADA							*ada.vim* *ada-syntax*

このモードはオブジェクト指向プログラムや型保護等の機能がサポートされた、Adaの
1995年版("Ada95")を想定して作られている。Ada95で追加されたキーワードを使用して
いるAda83のコード(そのようなコードは修正をすべき)は誤った強調色で表示してしま
うものの、オリジナルのAda言語("Ada83"や"Ada87")で書かれたコードも概ね取り扱う
ことができる。Adaについての詳細はhttp://www.adapower.com/を参照。

Adaモードは多くの状況を綺麗に取り扱う。例えば、"-5"のなかの"-"は数字の一部とし
て認識するが、"A-5"という表記の中の同じ文字は演算子として認識される。通常、他
のコンパイル単位を参照する"with"や"use"節は、Cにおける"#include"と同じ強調色で
表示される。"Conditional"や"Repeat"グループを異なる強調色に設定すれば、"end
if"と"end loop"はそれぞれのグループの強調色で表示される。これらにはコマンド
"highlight"を使って異なる強調色を設定することができる。
(例:ループの色を変えるには":hi Repeat"に続けて強調色指定を続ける; 単純な端末上
ではctermfg=Whiteという指定がしばしば見やすい)

Adaモードではユーザが設定できる幾つかのオプションが存在する。有効化するには、
オプションに値を設定する。あるオプションを有効化する例は: >
   let ada_standard_types = 1
無効化するには":unlet"を使用する。例: >
   unlet ada_standard_types = 1
Adaファイルを読込む前に、コマンドラインで":"とこれらコマンドをキー入力すること
で、設定することができる。ファイルに"~/.vimrc"、コロン(":")を除いて"let"コマン
ドを追加すれば、これらのオプション設定を永続化することができる。

以下、Adaモードのオプションの一覧:

変数			 動作 ~
ada_standard_types       標準パッケージ内の型(例:"Float")を強調表示する
ada_space_errors         余分な空白文字をエラーとして強調表示する…
ada_no_trail_space_error   ただし行末の空白はエラーから除外する
ada_no_tab_space_error     ただしスペース後のタブ文字は除外する
ada_withuse_ordinary     "with"と"use"を通常のキーワードで表示する
			   (これらが他のコンパイル単位への参照として使われた場
			   合には、特別に通常の強調として表示する)。
ada_begin_preproc        beginのようなキーワードの全てをCプリプロセッサ命令同
			   様の強調色を使用して表示する。

このモードは遅いコンピュータ(90MHz)上でも高速に動作するが、もしもパフォーマン
スが受け入れられないほど低いようならば、ada_withuse_ordinaryを有効化する。


ANT						*ant.vim* *ant-syntax*

ANTの構文ファイルにはデフォルトでJavaScriptとPythonの構文強調が含まれている。
関数AntSyntaxScript()の第1引数にタグ名を、第2引数にファイル名を指定することで
その他のスクリプト言語用構文強調をインストールすることができる。例: >

	:call AntSyntaxScript('perl', 'perl.vim')

これは次のようなANTのコードにPerlの構文強調をインストールするものである >

	<script language = 'perl'><![CDATA[
	    # everything inside is highlighted as perl
	]]></script>

スクリプト言語を永続的にインストールするには|mysyntaxfile-add|を参照。


		*asm.vim* *asmh8300.vim* *nasm.vim* *masm.vim* *asm68k*
アセンブラ言語	*asm-syntax* *asmh8300-syntax* *nasm-syntax* *masm-syntax*
		*asm68k-syntax*

"*.i"にマッチする名前のファイルはProgress(訳注:ファイル形式)かアセンブラであ
る。自動検出が動作しない場合や、Progressを編集しないことが判っている場合には、
起動設定ファイルvimrcに次のコマンドを書くことができる: >
   :let filetype_i = "asm"
"asm"には使用するアセンブラ言語の種類を指定する。

ファイル名の同じ拡張子を使用しているアセンブラ言語には沢山の種類がある。従って
ユーザは自分が使用する種類を選択するか、もしくはアセンブラファイルそのものに
Vimがそれと判断できるような行を追加しなければならない。現在は以下の構文ファイ
ルが利用可能:
	asm		GNUアセンブラ(デフォルト)
	asm68k		モトローラ680x0アセンブラ
	asmh8300	日立H-8300用GNUアセンブラ
	ia64		インテルItanium 64
	masm		マイクロソフトアセンブラ(たぶん80x86用)
	nasm		ネットワイドアセンブラ(訳注:nasmのほうが認知度が高い?)
	tasm		ターボアセンブラ(80x86,Pentium,MMXの命令コードを含む)
	pic		PICアセンブラ(現在はPIC16F84用)

アセンブラファイルに次のような行を書き加えるのが一番柔軟である: >
	:asmsyntax=nasm
"nasm"は実際に使用するアセンブラ構文の名前に置き換える。このような記述はファイ
ルの先頭5行以内に書いてなければならない。

構文の種類はバッファ変数b:asmsyntaxを設定することで常にそちらが優先される: >
	:let b:asmsyntax=nasm

自動にしろ手動にしろb:asmsyntaxが設定されていないときには、グローバル変数
asmsyntaxが使用される。これによりデフォルトのアセンブラ言語を設定することがで
きる: >
	:let asmsyntax=nasm

最後の手段として、何も設定されていない場合には、"asm"構文が使用される。


ネットワイドアセンブラ(nasm.vim)の補助強調 ~

機能を有効化するには: >
	:let   {variable}=1|set syntax=nasm
無効化するには: >
	:unlet {variable}  |set syntax=nasm

変数			強調内容 ~
nasm_loose_syntax	非オフィシャルな拡張構文をエラーとしない
			  (パーザ依存; 非推奨)
nasm_ctx_outside_macro	マクロ外のコンテキストをエラーとしない
nasm_no_warn		潜在的に危険な構文をToDoとして強調しない


ASPPERLとASPVBS				*aspperl-syntax* *aspvbs-syntax*

*.aspと*.aspという名のファイルはどちらもPerlもしくはVisual Basicのスクリプトた
りえる。Vimにとってこれを判別するのは難しいので、グローバル変数を設定すること
でどちらを使用するのか宣言することができる。どちらでもPerlスクリプトを使用する
なら: >
	:let g:filetype_asa = "aspperl"
	:let g:filetype_asp = "aspperl"
Visual Basicを使用するなら次のように設定する: >
	:let g:filetype_asa = "aspvbs"
	:let g:filetype_asp = "aspvbs"


BASIC				*basic.vim* *vb.vim* *basic-syntax* *vb-syntax*

Visual Basicも「通常の」BASICも、どちらも拡張子には".bas"が使用される。どちら
が使用されているか判別するのに、Vimはファイルの先頭5行以内に"VB_Name"という文
字列が存在するかどうかを検査する。存在しなければ、ファイル形式は"basic"とな
り、そうでなければ"vb"となる。拡張子が".frm"のファイルは常にVisual Basicとして
扱われる。


C							*c.vim* *c-syntax*

Cには幾つかの補助的な強調方法がある。それらを有効化するには対応した変数に値を
設定する。例: >
A few things in C highlighting are optional.  To enable them assign any value
to the respective variable.  Example: >
	:let c_comment_strings=1
To disable them use ":unlet".  Example: >
	:unlet c_comment_strings

変数			強調内容 ~
c_gnu			GNU gcc固有の要素
c_comment_strings	コメント内の文字列と数値
c_space_errors		行末の空白文字とタブ文字前のスペース文字
c_no_trail_space_error	 ... 但し行末の空白文字は除外
c_no_tab_space_error	 ... 但しタブも自前のスペース文字は除外
c_no_bracket_error	[]の中の{}をエラーとして表示しない
c_no_ansi		ANSI標準の型と定数を強調しない
c_ansi_typedefs		 ... 但し標準ANSI型は強調する
c_ansi_constants	 ... 但し標準ANSI定数は強調する
c_no_utf		文字列中の\uと\Uを強調しない
c_syntax_for_h		ファイル*.hにC+ではなくCの構文を適用する
c_no_if0		"#if 0"のブロックをコメントとして強調しない
c_no_cformat		文字列中の"%"によるフォーマットを強調しない
c_no_c99		C99の標準要素を強調しない

バックスクロール中に強調表示のエラーが生じて、そのエラーが<CTRL-L>の再描画で解
消される場合には、内部変数"c_minlines"にもっと大きな値を設定すれば解消されるか
もしれない: >
	:let c_minlines = 100
これにより構文判定の同期位置が表示開始行の100行手前に設定される。初期設定の値
は50行(c_no_if0を使用した場合は15行)である。ただしこれには、大きな値を設定する
と再描画が遅くなるという短所がある。

"#if 0" / "#endif"のブロックをコメントとして強調している場合には、"#if 0"が
ウィンドウのトップから"c_minlines"以内にある時にしか正しく動作しないことに注意
する。長い"#if 0"のブロックを使用した場合には、それは正しく強調されない。

コメント内で追加要素にマッチを行なうには、クラスタcCommentGroupを使用する。
例: >
   :au Syntax c call MyCadd()
   :function MyCadd()
   :  syn keyword cMyItem contained Ni
   :  syn cluster cCommentGroup add=cMyItem
   :  hi link cMyItem Title
   :endfun

ANSIの定数はグループ"cConstant"で強調される。これには"NULL", "SIG_IGN"やその他
のものが含まれる。しかしANSI標準でないもの、例えば"TRUE"は含まれない。もしもこ
れが紛らわしいならば、cConstant用の強調を削除する: >
	:hi link cConstant NONE

文法上エラーではないはずの'{'と'}'がエラーとして強調されてしまう場合には、
cErrInParen及びcErrInBracketの強調をリセットする。


COBOL						*cobol.vim* *cobol-syntax*

既存のCOBOLコードに要求される強調方法と、新規に開発されるコードに要求されるそ
れには違いがある。この違いはコードのおかれている状況(保守 vs 開発)やその他の要
素によって決定する。既存コードの強調を行なうには.vimrcに次の行を書き足す: >
	:let cobol_legacy_code=1
それを再び無効にするには次のようにする: >
	:unlet cobol_legacy_code


COLD FUSION				*coldfusion.vim* *coldfusion-syntax*

ColdFusionには独自版のHTMLコメントが存在する。ColdFusionのコメント強調を有効化
するには、次の行を起動設定ファイルに書き足す: >

	:let html_wrong_comments=1

ColdFusionの構文ファイルはHTML用構文ファイルに基づいている。


CYNLIB						*cynlib.vim* *cynlib-syntax*

Cynlibファイルは、ハードウェアのモデリングとシミュレーションを行なうCynlibクラ
スライブラリを使用したC++ファイルである。通常Cynlibのファイルは.ccや.cppという
拡張子を持つので、CynlibではないC++ファイルと区別するのは非常に困難である。だ
から.ccファイルをCynlibで強調する際には、ファイル.vimrcに次の行を書き足す: >

	:let cynlib_cyntax_for_cc=1

cppファイルについても同様(この拡張子は通常Windowsだけで使用される) >

	:let cynlib_cyntax_for_cpp=1

これらを再び無効にするには次のコマンドを使用する: >

	:unlet cynlib_cyntax_for_cc
	:unlet cynlib_cyntax_for_cpp
<

CWEB						*cweb.vim* *cweb-syntax*

"*.i"にマッチする名前のファイルはProgress(訳注:ファイル形式)かCWEBである。自動
検出が動作しない場合や、Progressを編集しないことが判っている場合には、起動設定
ファイルvimrcに次のコマンドを書くことができる: >
   :let filetype_w = "cweb"


DOSバッチファイル			*dosbatch.vim* *dosbatch-syntax*

DOSバッチファイルの強調にはオプションが1つある。このオプションによりWindows
2000で導入されたコマンドインタプリタの新しい拡張機能がカバーされ、変数
dosbatch_cmdextversionによりその有/無効が制御される。Windows NTでは値1を設定
し、Windows 2000では2を設定するのが良い。次のような行で使用するバージョンを選
択できる: >

  :let dosbatch_cmdextversion = 1

変数が定義されていない際のデフォルトはWindows 2000をサポートする2となる。


DTD						*dtd.vim* *dtd-syntax*

初期状態ではDTD構文強調は大/小文字を無視しない。無視する状態にするには、起動設
定ファイルに次の行を書き足す: >

	:let dtd_ignore_case=1

DTD構文ファイルでは未知のタグをエラーとして強調する。これが煩わしいならば、構
文ファイルdtd.vimが読込まれる前に: >

	:let dtd_no_tag_errors=1

と設定することで無効化することができる。定義部内のパラメータのエンティティ名は
強調グループ'Type'、句読点と'%'は'Comment'を使用して強調される。パラメータエン
ティティの実体は強調グループ'Constant'を、区切り文字の%と;は強調グループ'Type'
を使用して強調される。以下を設定するとこれを無効化できる: >

	:let dtd_no_param_entities=1

XML内の埋め込みDTDを強調表示するために、DTDの構文ファイルはxml.vimからも参照さ
れる。


EIFFEL						*eiffel.vim* *eiffel-syntax*

Eiffelは大小文字の区別をしないけれども、スタイルガイドラインが示すように、構文
強調ではそれらが区別される。これにより大小文字が違えば違うクラス名として強調表
示することが可能になっている。大小文字の違いを無視して強調を行なうならば、起動
設定ファイルに次の行を書き足す: >

	:let eiffel_ignore_case=1

これを行なってもコメント内のクラス名とTODOの印には大小文字の区別がなされる。

逆に、もっと厳密に検査するには、次の行のいずれかを書き足す: >

	:let eiffel_strict=1
	:let eiffel_pedantic=1

eiffel_strictを設定すると"Current", "Void", "Result", "Precursor"そして"NONE"
の5つの既定単語について、不正な大小文字の使用を捕捉し、機能やクラス名としてそ
れらが使用されれば警告を与えるようになる。

eiffel_pedanticを設定すると、Eiffelのスタイルガイドラインを相当に厳格に強制す
る。
(キーワードの大小文字を決定する時代遅れの方法と同じくらい、大小文字の混在のよ
うな…訳不明)
(like arbitrary mixes of upper- and lowercase letters as well as outdated ways
to capitalize keywords).

"Current", "Void", "Result"そして"Precursor"の小文字版を使用するには、大小文字
を区別する強調方法を無効化する代わりに: >

	:let eiffel_lower_case_predef=1

という方法を使うことができる。

ISEが提案し、実験的に幾つかのコンパイラでは取り扱うことのできる、新しい生成構
文は次のコマンドで使用できるようになる: >

	:let eiffel_ise=1

最後に幾つかのベンダは16進数定数値をサポートしている。それを取り扱うには: >

	:let eiffel_hex_constants=1

この行を起動設定ファイルに書き足す。


ERLANG						*erlang.vim* *erlang-syntax*

これはErlang(ERicsson LANGuage: エリクソン言語)をサポートする構文強調ファイル
である。Erlangは大小文字を区別しデフォルトの拡張子は".erl"である。

キーワード強調を無効化するには、これを.vimrcに書き足す: >
If you want to disable keywords highlighting, put in your .vimrc: >
	:let erlang_keywords = 1
組み込み関数強調を無効化するには、これを.vimrcに書き足す: >
	:let erlang_functions = 1
特殊文字の強調を無効化するには、これを.vimrcに書き足す: >
	:let erlang_characters = 1


FORM						*form.vim* *form-syntax*

FORMファイルの構文要素に使用するカラースキームには、Conditional, Number,
Statement, Comment, PreProc, Type, そしてStringが、次の文献で定義される言語仕
様に沿って行なわれる。
文献: 'Symbolic Manipulation with FORM'' by J.A.M. Vermaseren, CAN,
      Netherlands, 1991.

初期設定の色に変更を加えるには、次の構文グループを再定義すれば良い:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

構文ファイルform.vimではFORMプリプロセッサコマンドとディレクティブをそれぞれ、
デフォルトでは同じ構文グループにしていることに注意。

FORM用の既定の拡張カラーモードではヘッダ命令ととFORMプログラム本体での命令を区
別できるような色設定が利用可能である。拡張カラーモードを使用可能にするには、
ファイルvimrcに次の設定を書き足す: >

	:let form_enhanced_color=1

拡張モードを使うことは、gvimで暗いディスプレイを使用した場合にも利点がある。命
令文は黄色ではなく明るい黄色で表示され、条件文は視認性のため明るい青で表示され
る。


FORTRAN					*fortran.vim* *fortran-syntax*

デフォルトの強調と方言 ~
デフォルトではf95(Fortran 95)に相当する強調が行なわれる。Fortran 95はFortran
90のスーパーセットでかつFortran 77のだいたいのスーパーセットであるから、多くの
ユーザにとって多くのケースで適切な選択である。

Fortranソースコードの形式 ~
Fortran 9xのソースコードには固定形式と自由形式が有る。形式が誤って設定されてい
ると構文強調が正しくされないことに注意。

新規にFortranのファイルを作成する場合には、構文ファイルは固定形式であると仮定
する。常に自由形式を使う場合には >
    :let fortran_free_source=1
これを.vimrcでコマンド:syntaxを実行する前に行なう必要がある。

ソースコードの形式がファイル拡張子によって決定できる場合には、ftpluginファイル
の1つでfortran_free_sourceを設定すると便利になる。ftpluginファイルについての詳
細は|ftplugin|を参照のこと。例えば、拡張子.f90を持つファイルについては全て自由
形式として扱い、それ以外のもは固定形式とする場合には、次のコードをftpluginファ
イルに記述すれば良い。 >
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let fortran_free_source=1
    else
	unlet! fortran_free_source
    endif

既存のFortranファイルを編集する時には、変数fortran_free_sourceが設定されていれ
ば構文ファイルは自由形式のソースであると仮定する。設定されていないときには、
ファイルの先頭25行の行頭5カラムを調べて、その形式が固定なのか自由なのかを決定
しようと試みる。自由形式コードの兆候が見られない場合には、ファイルは固定形式
コードとして取り扱われる。このアルゴリズムはほとんどのケースにおいて有効に機能
する。しかしいつかのケース、例えば先頭25行以上が行コメントで占められているよう
なファイルでは、構文ファイルが固定形式コードであると誤った判断をしてしまうだろ
う。そのような場合には、ファイルの先頭25行の行頭5カラムのどこかに、コメント以
外の命令文を追加し、ファイルの保存(:w)そして再読込(:e!)を行なえば良い。

Fortranファイル内のタブ文字 ~
標準のFortranではタブ文字は認識されない。固定カラム位置での境界を必要とする固
定形式のFortranソースコードでTab文字を使用するのは良いアイデアではない。従って
タブ文字はエラーとして強調される。しかしながらプログラマーによってはタブ文字を
使用することを望む場合があるだろう。Fortranファイルにタブ文字が含まれている場
合には、変数fortran_have_tabsをコマンド:syntaxが実行される前に >
    :let fortran_have_tabs=1
このように.vimrcで設定すれば良い。タブ文字を使う場合には残念ながら、構文ファイ
ルによって不正な余白を検出することができなくなる。

Fortranファイルの構文による強調 ~
foldmethod=syntax(訳注:構文による折畳)を使用したいならば、まず変数fortran_fold
を >
    :let fortran_fold=1
このようなコマンドで設定しなければならない。これにより構文ファイルはプログラム
単位の領域、プログラム命令文で始まるメインプログラム、サブルーチン、関数、
サブプログラム、ブロックデータサブプログラム、そしてモジュールといったプログラ
ム単位の領域で折畳を定義する。同時に変数fortran_fold_conditionalsを >
    :let fortran_fold_conditionals=1
このように設定すると、doループ、ifブロック、そしてselect-case構造の領域が折畳
まれる。さらに変数fortran_fold_multilinecommentsも >
    :let fortran_fold_multilinecomments=1
このように設定すれば3行以上にわたり続くコメントの領域が折畳まれる。大きなファ
イルに対してこのように構文による折畳を使用した場合、非常に遅くなることに注意。

fortran_foldを設定し、fortran_fold_conditionalsか
fortran_fold_multilinecomments(どちらか片方でも両方でも)を設定した場合には、
foldmethod=syntaxを設定してある時に、Vimはファイルを折畳む。2つのプログラム単
位の間にあるコメントや空行は折畳まれない。なぜならそれらは構文によって定義され
るプログラム単位に属していないからである。

より正確なFortranの構文 ~
変数fortran_more_preciseを >
If you set the variable fortran_more_precise with a command such as >
    :let fortran_more_precise=1
このようなコマンドで設定した場合には、構文強調がより正確になるが動作は遅くな
る。とりわけ、do、goto、そして算術if命令文に使用される命令ラベルが、do、if、
selectもしくはforall構造の終端で使用される名前として認識されるようになる。

非標準のFortran方言 ~
構文ファイルは5つのFotranの方言をサポートしている: f95, f90, f77, the Lahey
サブセットの elf90, そして Imagine1 サブセットの F.

f77の拡張機能を使うときには、それがg77(GNU Fortran)を含む多くのコンパイラがサ
ポートしている一般的な、do/enddoループ、do/whileループ、自由形式ソースコード、
拡張機能であるならば、恐らくデフォルトの強調で満足するだろう。しかしながら、拡
張機能を使用せずに厳密なf77を使用する場合や、自由形式やMIL STD 1753(訳注:MIL
STDはアメリカ軍の定める標準規格でその1753号の意味)の拡張を用いない場合には問題
がある。そのような時に方言としてf77を指定することには、SUMのようなf9xの持つ関
数として認識されてしまう名前が、ユーザ変数として認識され強調されないという利点
がある。また廃れてしまったASSIGN命令文のような構造も修正用TODOとしては強調され
なくなり、固定形式が仮定されるようになる。

elf90やFを使う場合には適切な方言を設定する。それにより、これらの方言においては
除外されるf90の機能はtodoとして強調され、これらの方言で必要とされる自由形式の
ソースコードが仮定される。

方言は変数fortran_dialectを設定することで選択できる。fortran_dialectに設定でき
る値には大小文字の区別があり"f95"、"f70"、"elf"もしくは"F"である。無効な値を
fortran_dialectへ設定した場合にはそれは無視される。

全てのFortranファイルで同じ方言を使用するならば、.vimrcでsyntax onが実行される
前にfortran_dialectを設定する。方言がファイルの拡張子に依存して決定する場合に
は、ftpluginファイル内で設定するのが最良の手段である。ftpluginファイル付いての
詳細な情報は、|ftplugin|を参照。例、全ての.f90という拡張子のファイルが"elf"サ
ブセットにより書かれているならば、ftpluginファイルに次のようなコードを書き足す
べきである >
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let fortran_dialect="elf"
    else
	unlet! fortran_dialect
    endif

拡張子が方言を一意に決定できない場合には、もっと良い制御方法が必要になる。各
ファイルの先頭3行以内にコメントで"fortran_dialect=xx"という命令を書けば方言の
設定を上書することができる(xxにはf77やelfやFやf90やf95が入る)。これによりファ
イル毎に方言を設定できる。例えば、古い.fファイルはf77の拡張を使用して書かれて
いるが、新しい.fファイルがFで書かれている場合には >
  ! fortran_dialect=F
このような形で新しいファイルの先頭3行以内にコメントを追加することで、Fで書かれ
ていることが判別できるようになる。Fとelfの両方が指定された場合には、Fの方が優
先される。

制限事項 ~
丸カッコチェックは閉じカッコが足りないことを捕捉できない。穿孔(訳注:パンチカー
ド?)文字列は認識できない。幾つかのキーワードはFortran90の予約語ではないので誤
って強調される。

Fortranに関するその他の情報は|fortran-indent|や|fortran-plugin|を参照。


FVWM CONFIGURATION FILES			*fvwm.vim* *fvwm-syntax*

Vimに*fvwmrc*や*fvwm2rc*などにマッチしないFvwmコンフィギュレーションファイルを
認識させるためには、ファイルmyfiletypefile.vimで適切な追加の認識パターンを設定
しなければならない。このパターンでは変数"b:fvwm_version"にFvwmのメジャーバージ
ョンを指定し、オプション'filetype'にfvwmを設定しなければならない。

以下は/etc/X11/fvwm2/配下のファイルをFvwm2のコンフィギュレーションとして認識さ
せるための追加設定を示している: >

  :au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |
					 \ set filetype=fvwm

有効な色の名前を全てVimに強調させたいならば、システムの色データベース(rgb.txt)
の在り処を知らせる必要がある。設定は変数"rgb_file"に行なう。色データベースが
/usr/X11/lib/X11/にあるとすれば: >

	:let rgb_file = "/usr/X11/lib/X11/rgb.txt"

このような内容をファイル.vimrcに追加する。


GSP							*gsp.vim*

GSPページのデフォルトカラーは|html.vim|にて定義され、Javaコード(Javaタグ内部や
インラインのバッククォート内)のカラーは|java.vim|にて定義される。|html.vim|で
定義される以下のHTMLグループは、インラインJavaコードを挿入したり強調するために
再定義されている:

    htmlString
    htmlValue
    htmlEndTag
    htmlTag
    htmlTagN

書かれた大抵の場所のインラインJavaコードは適切に強調されるが、幾つかの特殊な
ケースではそうはならない。他のHTMLグループ内にインラインJavaコードを書いてそれ
が正しく強調されない場合には、必要な行を|html.vim|からコピーしてgspJavaを
constains節に加えれば、正しく強調されるようになる。

インラインJavaを示すバッククォートは、目立ちやすくするためにhtmlErrorグループ
で強調される。


HTML						*html.vim* *html-syntax*

HTMLファイルのタグ用の構文ファイルは以下のように動作する。

開きタグの<>は、閉じタグの</>とは異なった色で強調される。これは意図的にそうし
てある!。開きタグには強調'Function'が使用され、閉じタグには強調'Type'が使用さ
れる(どのようにそれらがどのように定義されているかはsyntax.vimを参照)。

既知のタグ名はC命令文と同じように強調される。未知のタグ名は間違いを見分けやす
くするために、<>や</>と同じ強調がなされる。

引数(もしくは属性)名にも同じことが言える。既知の属性名と未知の属性名には異なる
強調がなされる。

幾つかのHTMLタグは表示する文字種を変更するために使用される。以下のタグは構文
ファイルhtml.vimによって認識され、その内容は通常の文字種とは異なる文字種で表示
される: <B> <I> <U> <EM> <STRONG> (<EM>は<I>のエイリアスとして使われ、<STRONG>
は<B>のエイリアス)、<H1> - <H6>、<HEAD>、<TITLE>そして<A>、ただしhrefが含まれ
ていてリンクとして使われている(例<A href="somefile.html">)場合。

それらのテキストの文字種を変更するには、以下の構文グループを再定義する必要があ
る:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlTitle for titles
    - htmlH1 - htmlH6 for headings

To make this redefinition work you must redefine them all with the exception
of the last two (htmlTitle and htmlH[1-6], which are optional) and define the
following variable in your vimrc (this is due to the order in which the files
are read during initialization) >
	:let html_my_rendering=1

If you'd like to see an example download mysyntax.vim at
http://www.fleiner.com/vim/mysyntax.vim

You can also disable this rendering by adding the following line to your
vimrc file: >
	:let html_no_rendering=1

HTML comments are rather special (see an HTML reference document for the
details), and the syntax coloring scheme will highlight all errors.
However, if you prefer to use the wrong style (starts with <!-- and
ends with --!>) you can define >
	:let html_wrong_comments=1

JavaScript and Visual Basic embedded inside HTML documents are highlighted as
'Special' with statements, comments, strings and so on colored as in standard
programming languages. Note that only JavaScript and Visual Basic are currently
supported, no other scripting language has been added yet.

Embedded and inlined cascading style sheets (CSS) are highlighted too.

There are several html preprocessor languages out there. html.vim has been
written such that it should be trivial to include it. To do so add the
following two lines to the syntax coloring file for that language
(the example comes from the asp.vim file):

    runtime! syntax/html.vim
    syn cluster htmlPreproc add=asp

Now you just need to make sure that you add all regions that contain
the preprocessor language to the cluster htmlPreproc.


HTML/OS (by Aestiva)				*htmlos.vim* *htmlos-syntax*

The coloring scheme for HTML/OS works as follows:

Functions and variable names are the same color by default, because VIM
doesn't specify different colors for Functions and Identifiers.  To change
this (which is recommended if you want function names to be recognizable in a
different color) you need to add the following line to either your ~/.vimrc: >
  :hi Function term=underline cterm=bold ctermfg=LightGray

Of course, the ctermfg can be a different color if you choose.

Another issues that HTML/OS runs into is that there is no special filetype to
signify that it is a file with HTML/OS coding.  You can change this by opening
a file and turning on HTML/OS syntax by doing the following: >
  :set syntax=htmlos

Lastly, it should be noted that the opening and closing characters to begin a
block of HTML/OS code can either be << or [[ and >> or ]], respectively.


IA64				*ia64.vim* *intel-itanium* *ia64-syntax*

Highlighting for the Intel Itanium 64 assembly language.  See |asm.vim| for
how to recognize this filetype.

To have *.inc files be recognized as IA64, add this to your .vimrc file: >
	:let g:filetype_inc = "ia64"


INFORM						*inform.vim* *inform-syntax*

Inform highlighting includes symbols provided by the Inform Library, as
most programs make extensive use of it.  If do not wish Library symbols
to be highlighted add this to your vim startup: >
	:let inform_highlight_simple=1

By default it is assumed that Inform programs are Z-machine targetted,
and highlights Z-machine assembly language symbols appropriately.  If
you intend your program to be targetted to a Glulx/Glk environment you
need to add this to your startup sequence: >
	:let inform_highlight_glulx=1

This will highlight Glulx opcodes instead, and also adds glk() to the
set of highlighted system functions.


JAVA						*java.vim* *java-syntax*

The java.vim syntax highlighting file offers several options:

In Java 1.0.2 it was never possible to have braces inside parens, so this was
flagged as an error.  Since Java 1.1 this is possible (with anonymous
classes), and therefore is no longer marked as an error. If you prefer the old
way, put the following line into your vim startup file: >
	:let java_mark_braces_in_parens_as_errors=1

All identifiers in java.lang.* are always visible in all classes.  To
highlight them use: >
	:let java_highlight_java_lang_ids=1

You can also highlight identifiers of most standard java packages if you
download the script at http://www.fleiner.com/vim/syntax/javaid.vim
If you prefer to only highlight identifiers of a certain package, say java.io
use the following: >
	:let java_highligh_java_io=1
Check the javaid.vim file for a list of all the packages that are supported.

Function names are not highlighted, as the way to find functions depends on
how you write java code.  The syntax file knows two possible ways to highlight
functions:

If you write function declarations that are always indented by either
a tab, 8 spaces or 2 spaces you may want to set >
	:let java_highlight_functions="indent"
However, if you follow the java guidlines about how functions and classes are
supposed to be named (with respect to upper and lowercase), use >
	:let java_highlight_functions="style"
If both options do not work for you, but you would still want function
declarations to be highlighted create your own definitions by changing the
definitions in java.vim or by creating your own java.vim which includes the
original one and then adds the code to highlight functions.

In java 1.1 the functions System.out.println() and System.err.println() should
only be used for debugging. Therefor it is possible to highlight debugging
statements differently. To do this you must add the following definition in
your startup file: >
	:let java_highlight_debug=1
The result will be that those statements are highlighted as 'Special'
characters. If you prefer to have them highlighted differently you must define
new highlightings for the following groups.:
    Debug, DebugSpecial, DebugString, DebugBoolean, DebugType
which are used for the statement itself, special characters used in debug
strings, strings, boolean constants and types (this, super) respectively. I
have opted to chose another background for those statements.

In order to help you to write code that can be easely ported between
java and C++, all C++ keywords are marked as error in a java program.
However, if you use them regularly, you may want to define the following
variable in your .vimrc file: >
	:let java_allow_cpp_keywords=1

Javadoc is a program that takes special comments out of java program files and
creates HTML pages. The standard configuration will highlight this HTML code
similarly to HTML files (see |html.vim|). You can even add javascript
and CSS inside this code (see below). There are four differences however:
  1. The title (all characters up to the first '.' which is followed by
     some white space or up to the first '@') is colored differently (to change
     the color change the group CommentTitle).
  2. The text is colored as 'Comment'.
  3. HTML comments are colored as 'Special'
  4. The special javadoc tags (@see, @param, ...) are highlighted as specials
     and the argument (for @see, @param, @exception) as Function.
To turn this feature off add the following line to your startup file: >
	:let java_ignore_javadoc=1

If you use the special javadoc comment highlighting described above you
can also turn on special highlighting for javascript, visual basic
scripts and embedded CSS (stylesheets). This makes only sense if you
actually have javadoc comments that include either javascript or embedded
CSS. The options to use are >
	:let java_javascript=1
	:let java_css=1
	:let java_vb=1

In order to highlight nested parens with different colors define colors
for javaParen, javaParen1 and javaParen2, for example with >
	:hi link javaParen Comment
or >
	:hi javaParen ctermfg=blue guifg=#0000ff

If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "java_minlines" internal variable
to a larger number: >
	:let java_minlines = 50
This will make the syntax synchronization start 50 lines before the first
displayed line.  The default value is 10.  The disadvantage of using a larger
number is that redrawing can become slow.


LACE						*lace.vim* *lace-syntax*

Lace (Language for Assembly of Classes in Eiffel) is case insensitive, but the
style guide lines are not.  If you prefer case insensitive highlighting, just
define the vim variable 'lace_case_insensitive' in your startup file: >
	:let lace_case_insensitive=1


LEX						*lex.vim* *lex-syntax*

Lex uses brute-force synchronizing as the "^%%$" section delimiter
gives no clue as to what section follows.  Consequently, the value for >
	:syn sync minlines=300
may be changed by the user if s/he is experiencing synchronization
difficulties (such as may happen with large lex files).


LITE						*lite.vim* *lite-syntax*

There are two options for the lite syntax highlighting.

If you like SQL syntax highligthing inside Strings, use this: >

	:let lite_sql_query = 1

For syncing, minlines defaults to 100.  If you prefer another value, you can
set "lite_minlines" to the value you desire.  Example: >

	:let lite_minlines = 200


MAPLE						*maple.vim* *maple-syntax*

Maple V, by Waterloo Maple Inc, supports symbolic algebra.  The language
supports many packages of functions which are selectively loaded by the user.
The standard set of packages' functions as supplied in Maple V release 4 may be
highlighted at the user's discretion.  Users may place in their .vimrc file: >

	:let mvpkg_all= 1

to get all package functions highlighted, or users may select any subset by
choosing a variable/package from the table below and setting that variable to
1, also in their .vimrc file (prior to sourcing
$VIMRUNTIME/syntax/syntax.vim).

	Table of Maple V Package Function Selectors >
  mv_DEtools	 mv_genfunc	mv_networks	mv_process
  mv_Galois	 mv_geometry	mv_numapprox	mv_simplex
  mv_GaussInt	 mv_grobner	mv_numtheory	mv_stats
  mv_LREtools	 mv_group	mv_orthopoly	mv_student
  mv_combinat	 mv_inttrans	mv_padic	mv_sumtools
  mv_combstruct mv_liesymm	mv_plots	mv_tensor
  mv_difforms	 mv_linalg	mv_plottools	mv_totorder
  mv_finance	 mv_logic	mv_powseries


MOO						*moo.vim* *moo-syntax*

If you use C-style comments inside expressions and find it mangles your
highlighting, you may want to use extended (slow!) matches for C-style
comments: >

	:let moo_extended_cstyle_comments = 1

To disable highlighting of pronoun substitution patterns inside strings: >

	:let moo_no_pronoun_sub = 1

To disable highlighting of the regular expression operator '%|', and matching
'%(' and '%)' inside strings: >

	:let moo_no_regexp = 1

Unmatched double quotes can be recognized and highlighted as errors: >

	:let moo_unmatched_quotes = 1

To highlight builtin properties (.name, .location, .programmer etc.): >

	:let moo_builtin_properties = 1

Unknown builtin functions can be recognized and highlighted as errors. If you
use this option, add your own extensions to the mooKnownBuiltinFunction group.
To enable this option: >

	:let moo_unknown_builtin_functions = 1

An example of adding sprintf() to the list of known builtin functions: >

	:syn keyword mooKnownBuiltinFunction sprintf contained


MSQL						*msql.vim* *msql-syntax*

There are two options for the msql syntax highlighting.

If you like SQL syntax highligthing inside Strings, use this: >

	:let msql_sql_query = 1

For syncing, minlines defaults to 100.  If you prefer another value, you can
set "msql_minlines" to the value you desire.  Example: >

	:let msql_minlines = 200


NCF						*ncf.vim* *ncf-syntax*

There is one option for NCF syntax highlighting.

If you want to have unrecognized (by ncf.vim) statements highlighted as
errors, use this: >

	:let ncf_highlight_unknowns = 1

If you don't want to highlight these errors, leave it unset.


NROFF						*nroff.vim* *nroff-syntax*

To mark trailing spaces as an error, use this: >

	:let nroff_space_errors = 1


PAPP						*papp.vim* *papp-syntax*

The PApp syntax file handles .papp files and, to a lesser extend, .pxml
and .pxsl files which are all a mixture of perl/xml/html/other using xml
as the top-level file format. By default everything inside phtml or pxml
sections is treated as a string with embedded preprocessor commands. If
you set the variable: >

	:let papp_include_html=1

in your startup file it will try to syntax-hilight html code inside phtml
sections, but this is relatively slow and much too colourful to be able to
edit sensibly ;)

The newest version of the papp.vim syntax file can usually be found at
http://papp.plan9.de.


PASCAL						*pascal.vim* *pascal-syntax*

Files matching "*.p" could be Progress or Pascal.  If the automatic detection
doesn't work for you, or you don't edit Progress at all, use this in your
startup vimrc: >

   :let filetype_p = "pascal"

The Pascal syntax file has been extended to take into account some extensions
provided by Turbo Pascal, Free Pascal Compiler and GNU Pascal Compiler.
Delphi keywords are also supported. By default, Turbo Pascal 7.0 features are
enabled.  If you prefer to stick with the standard Pascal keywords, add the
following line to your startup file: >

   :let pascal_traditional=1

To switch on Delphi specific constructions (such as one-line comments,
keywords, etc): >

   :let pascal_delphi=1


The option pascal_symbol_operator controls whether symbol operators such as +,
*, .., etc. are displayed using the Operator color or not.  To colorize symbol
operators, add the following line to your startup file: >

   :let pascal_symbol_operator=1

Some functions are highlighted by default.  To switch it off: >

   :let pascal_no_functions=1

Furthermore, there are specific variable for some compiler.  Besides
pascal_delphi, there are pascal_gpc and pascal_fpc.  Default extensions try to
match Turbo Pascal. >

   :let pascal_gpc=1

or >

   :let pascal_fpc=1

To ensure that strings are defined on a single line, you can define the
pascal_one_line_string variable. >

   :let pascal_one_line_string=1

If you dislike <Tab> chars, you can set the pascal_no_tabs variable.  Tabs
will be highlighted as Error. >

   :let pascal_no_tabs=1



PERL						*perl.vim* *perl-syntax*

There are a number of possible options to the perl syntax highlighting.

If you use POD files or POD segments, you might: >

	:let perl_include_POD = 1

To handle package references in variable and function names differently from
the rest of the name (like 'PkgName::' in '$PkgName::VarName'): >

	:let perl_want_scope_in_variables = 1

If you want complex things like '@{${"foo"}}' to be parsed: >

	:let perl_extended_vars = 1

The coloring strings can be changed. By default strings and qq friends will be
highlighted like the first line. If you set the variable
perl_string_as_statement, it will be highlighted as in the second line.

   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N       (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^^N       (let perl_string_as_statement)

(^ = perlString, S = perlStatement, N = None at all)

The syncing has 3 options. The first two switch off some triggering of
synchronization and should only be needed in case it fails to work properly.
If while scrolling all of a sudden the whole screen changes color completely
then you should try and switch off one of those. Let me know if you can figure
out the line that causes the mistake.

One triggers on "^\s*sub\s*" and the other on "^[$@%]" more or less. >

	:let perl_no_sync_on_sub
	:let perl_no_sync_on_global_var

Below you can set the maximum distance VIM should look for starting points for
its attempts in syntax highlighting. >

	:let perl_sync_dist = 100

For the "<<xxx" construct (here Documents), Vim can check for any value of
"xxx".  So currently Vim can highlight here Documents properly.
(訳注:原文では「取り扱えない」となっていますが、6.x現在では取り扱えるようにな
りました。)

If you want to use folding with perl, set perl_fold: >

       :let perl_fold = 1


PHP3 and PHP4		*php.vim* *php3.vim* *php-syntax* *php3-syntax*

[note: previously this was called "php3", but since it now also supports php4
it has been renamed to "php"]

There are the following options for the php syntax highlighting.

If you like SQL syntax hightlighting inside Strings: >

  let php_sql_query = 1

For highlighting the Baselib methods: >

  let php_baselib = 1

Enable HTML syntax highlighting inside strings: >

  let php_htmlInStrings = 1

Using the old colorstyle: >

  let php_oldStyle = 1

Enable highlighting ASP-style short tags: >

  let php_asp_tags = 1

Disable short tags: >

  let php_noShortTags = 1

For highlighting parent error ] or ): >

  let php_parent_error_close = 1

For skipping an php end tag, if there exists an open ( or [ without a closing
one: >

  let php_parent_error_open = 1

Enable folding for classes and functions: >

  let php_folding = 1

Selecting syncing method: >

  let php_sync_method = x

x = -1 to sync by search (default),
x > 0 to sync at least x lines backwards,
x = 0 to sync from start.


PPWIZARD					*ppwiz.vim* *ppwiz-syntax*

PPWizard is a preprocessor for HTML and OS/2 INF files

This syntax file has the options:

- ppwiz_highlight_defs : determines highlighting mode for PPWizard's
  definitions. Possible values are

  ppwiz_highlight_defs = 1 : PPWizard #define statements retain the
    colors of their contents (e. g. PPWizard macros and variables)

  ppwiz_highlight_defs = 2 : preprocessor #define and #evaluate
    statements are shown in a single color with the exception of line
    continuation symbols

  The default setting for ppwiz_highlight_defs is 1.

- ppwiz_with_html : If the value is 1 (the default), highlight literal
  HTML code; if 0, treat HTML code like ordinary text.


PHTML						*phtml.vim* *phtml-syntax*

There are two options for the phtml syntax highlighting.

If you like SQL syntax highligthing inside Strings, use this: >

	:let phtml_sql_query = 1

For syncing, minlines defaults to 100.  If you prefer another value, you can
set "phtml_minlines" to the value you desire.  Example: >

	:let phtml_minlines = 200


POSTSCRIPT					*postscr.vim* *postscr-syntax*

There are several options when it comes to highlighting PostScript.

First which version of the PostScript language to highlight.  There are
currently three defined language versions, or levels.  Level 1 is the original
and base version, and includes all extensions prior to the release of level 2.
Level 2 is the most common version around, and includes its own set of
extensions prior to the release of level 3.  Level 3 is currently the highest
level supported.  You select which level of the PostScript language you want
highlighted by defining the postscr_level variable as follows: >

	:let postscr_level=2

If this variable is not defined it defaults to 2 (level 2) since this is
the most prevalent version currently.

Note, not all PS interpreters will support all language features for a
particular language level.  In particular the %!PS-Adobe-3.0 at the start of
PS files does NOT mean the PostScript present is level 3 PostScript!

If you are working with Display PostScript, you can include highlighting of
Display PS language features by defining the postscr_display variable as
follows: >

	:let postscr_display=1

If you are working with Ghostscript, you can include highlighting of
Ghostscript specific language features by defining the variable
postscr_ghostscript as follows: >

	:let postscr_ghostscript=1

PostScript is a large language, with many predefined elements.  While it
useful to have all these elements highlighted, on slower machines this can
cause Vim to slow down.  In an attempt to be machine friendly font names and
character encodings are not highlighted by default.  Unless you are working
explicitly with either of these this should be ok.  If you want them to be
highlighted you should set one or both of the following variables: >

	:let postscr_fonts=1
	:let postscr_encodings=1

There is a stylistic option to the highlighting of and, or, and not.  In
PostScript the function of these operators depends on the types of their
operands - if the operands are booleans then they are the logical operators,
if they are integers then they are binary operators.  As binary and logical
operators can be highlighted differently they have to be highlighted one way
or the other.  By default they are treated as logical operators.  They can be
highlighted as binary operators by defining the variable
postscr_andornot_binary as follows: >

	:let postscr_andornot_binary=1
<

			*ptcap.vim*
PRINTCAP + TERMCAP	*ptcap-syntax* *termcap-syntax* *printcap-syntax*

This syntax file applies to the printcap and termcap databases.

In order for Vim to recognize printcap/termcap files that do not match
the patterns *printcap*, or *termcap*, you must put additional patterns
appropriate to your system in your |myfiletypefile| file.  For these
patterns, you must set the variable "b:ptcap_type" to either "print" or
"term", and then the 'filetype' option to ptcap.

For example, to make Vim identify all files in /etc/termcaps/ as termcap
files, add the following: >

   :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |
				       \ set filetype=ptcap

If you notice highlighting errors while scrolling backwards, which
are fixed when redrawing with CTRL-L, try setting the "ptcap_minlines"
internal variable to a larger number:

  let ptcap_minlines = 50

(The default is 20 lines.)


PROGRESS				*progress.vim* *progress-syntax*

Files matching "*.w" could be Progress or cweb.  If the automatic detection
doesn't work for you, or you don't edit cweb at all, use this in your
startup vimrc: >
   :let filetype_w = "progress"
The same happens for "*.i", which could be assembly, and "*.p", which could be
Pascal.  Use this if you don't use assembly and Pascal: >
   :let filetype_i = "progress"
   :let filetype_p = "progress"


PYTHON						*python.vim* *python-syntax*

There are four options to control Python syntax highlighting.

For highlighted numbers: >
	:let python_highlight_numbers = 1

For highlighted builtin functions: >
	:let python_highlight_builtins = 1

For highlighted standard exceptions: >
	:let python_highlight_exceptions = 1

If you want all possible Python highlighting (the same as setting the
preceding three options): >
	:let python_highlight_all = 1


REXX						*rexx.vim* *rexx-syntax*

If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "rexx_minlines" internal variable
to a larger number: >
	:let rexx_minlines = 50
This will make the syntax synchronization start 50 lines before the first
displayed line.  The default value is 10.  The disadvantage of using a larger
number is that redrawing can become slow.


RUBY						*ruby.vim* *ruby-syntax*

There are a few options to the Ruby syntax highlighting.

By default, the "end" keyword is colorized according to the opening statement
of the block it closes. While useful, this feature can be expensive: if you
experience slow redrawing (or you are on a terminal with poor color support)
you may want to turn it off by defining the "ruby_no_expensive" variable: >
	:let ruby_no_expensive = 1
In this case the same color will be used for all control keywords.

If you do want this feature enabled, but notice highlighting errors while
scrolling backwards, which are fixed when redrawing with CTRL-L, try setting
the "ruby_minlines" variable to a value larger than 50: >
	:let ruby_minlines = 100
Ideally, this value should be a number of lines large enough to embrace your
largest class or module.

Finally, if you do not like to see too many color items around, you can define
"ruby_no_identifiers": >
	:let ruby_no_identifiers = 1
This will prevent highlighting of special identifiers like "ConstantName",
"$global_var", "@instace_var", "| iterator |", and ":symbol".


SDL						*sdl.vim* *sdl-syntax*

The SDL highlighting probably misses a few keywords, but SDL has so many
of them it's almost impossibly to cope.

The new standard, SDL-2000, specifies that all identifiers are
case-sensitive (which was not so before), and that all keywords can be
used either completely lowercase or completely uppercase. To have the
highlighting reflect this, you can set the following variable: >
	:let sdl_2000=1

This also sets many new keywords. If you want to disable the old
keywords, which is probably a good idea, use: >
	:let SDL_no_96=1


The indentation is probably also incomplete, but right now I am very
satisfied with it for my own projects.

The last thing is a little PO-editing helper. It adds a couple of menu
entries. Though it doesn't do much, I find it extremely helpful for
translating PO files. I just won't use Emacs, you know.
(訳注:これは不明。別の形式(PO)についての記述だと思われる)


SED						*sed.vim* *sed-syntax*

To make tabs stand out from regular blanks (accomplished by using Todo
highlighting on the tabs), define "highlight_sedtabs" by putting >

	:let highlight_sedtabs = 1

in the vimrc file.  (This special highlighting only applies for tabs
inside search patterns, replacement texts, addresses or text included
by an Append/Change/Insert command.)  If you enable this option, it is
also a good idea to set the tab width to one character; by doing that,
you can easily count the number of tabs in a string.

Bugs:

  The transform command (y) is treated exactly like the substitute
  command.  This means that, as far as this syntax file is concerned,
  transform accepts the same flags as substitute, which is wrong.
  (Transform accepts no flags.)  I tolerate this bug because the
  involved commands need very complex treatment (95 patterns, one for
  each plausible pattern delimiter).


SGML						*sgml.vim* *sgml-syntax*

The coloring scheme for tags in the SGML file works as follows.

The <> of opening tags are colored differently than the </> of a closing tag.
This is on purpose! For opening tags the 'Function' color is used, while for
closing tags the 'Type' color is used (See syntax.vim to check how those are
defined for you)

Known tag names are colored the same way as statements in C.  Unknown tag
names are not colored which makes it easy to spot errors.

Note that the same is true for argument (or attribute) names. Known attribute
names are colored differently than unknown ones.

Some SGML tags are used to change the rendering of text. The following tags
are recognized by the sgml.vim syntax coloring file and change the way normal
text is shown: <varname> <emphasis> <command> <function> <literal>
<replaceable> <ulink> and <link>.

If you want to change how such text is rendered, you must redefine the
following syntax groups:

    - sgmlBold
    - sgmlBoldItalic
    - sgmlUnderline
    - sgmlItalic
    - sgmlLink for links

To make this redefinition work you must redefine them all and define the
following variable in your vimrc (this is due to the order in which the files
are read during initialization) >
   let sgml_my_rendering=1

You can also disable this rendering by adding the following line to your
vimrc file: >
   let sgml_no_rendering=1

(Adapted from the html.vim help text by Claudio Fleiner <claudio@fleiner.com>)


SH						*sh.vim* *sh-syntax*

This covers the "normal" Unix (Borne) sh, bash and the korn shell.

Vim attempts to determine which shell type is in use by specifying that
various filenames are of specific types:

	ksh : .kshrc* *.ksh
	bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash

If neither of these cases pertain, then the first line of the file is examined
(ex. /bin/sh  /bin/ksh  /bin/bash).  If the first line specifies a shelltype,
then that shelltype is used.  However some files (ex. .profile) are known to
be shell files but the type is not apparent.  One may specify buffer specific
variables prior to sourcing the <sh.vim> syntax file (b:is_kornshell,
b:is_bash, or b:is_sh) so that the associated shell type will be used.  One
may also specify a global default by instantiating one of the following
three variables:

	ksh : is_kornshell
	bash: is_bash
	sh  : is_sh

One may also specify that what looks like the "sh" shell is actually
to be interpreted as a bash shell by setting 'bash_is_sh'.  It is
best to set any of these global variables in your '.vimrc' file.

To choose between the two ways to treat single-quotes inside a pair of
double-quotes, I have introduced a Vim variable "highlight_balanced_quotes".
By default (ie by not declaring this variable) single quotes can be used
inside double quotes, and are not highlighted.  If you prefer balanced single
quotes as I do you just make the statement in your .vimrc file: >
	:let highlight_balanced_quotes = 1

Similarly I have introduced another vim variable "highlight_function_name" to
be used to enable/disable highlighting of the function-name in function
declarations.  The default is not to highlight the function name.  If you want
to highlight function names, include this in your .vimrc file: >
	:let highlight_function_name = 1

If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "sh_minlines" internal variable
to a larger number: >
	:let sh_minlines = 200
This will make the syntax synchronization start 200 lines before the first
displayed line.  The default value is 100.  The disadvantage of using a larger
number is that redrawing can become slow.

If you don't have much to synchronize on, displaying can be very slow.  To
reduce this, the "sh_maxlines" internal variable can be set: >
	:let sh_maxlines = 100
The default is to use the double of "sh_minlines".  Set it to a smaller number
to speed up displaying.  The disadvantage is that highlight errors may appear.


SPEEDUP (AspenTech plant simulator)		*spup.vim* *spup-syntax*

The Speedup syntax file has some options:

- strict_subsections : If this variable is defined, only keywords for
  sections and subsections will be highlighted as statements but not
  other keywords (like WITHIN in the OPERATION section).

- highlight_types : Definition of this variable causes stream types
  like temperature or pressure to be highlighted as Type, not as a
  plain Identifier. Included are the types that are usually found in
  the DECLARE section; if you defined own types, you have to include
  them in the syntax file.

- oneline_comments : this value ranges from 1 to 3 and determines the
  highlighting of # style comments.

  oneline_comments = 1 : allow normal Speedup code after an even
  number of #s.

  oneline_comments = 2 : show code starting with the second # as
  error. This is the default setting.

  oneline_comments = 3 : show the whole line as error if it contains
  more than one #.

Since especially OPERATION sections tend to become very large due to
PRESETting variables, syncing may be critical. If your computer is
fast enough, you can increase minlines and/or maxlines near the end of
the syntax file.


TEX						*tex.vim* *tex-syntax*

The tex highlighting supports TeX, LaTeX, and some AmsTeX.  The
highlighting supports three primary zones: normal, texZone, and texMathZone.
Although a considerable effort has been made to have these zones terminate
properly, zones delineated by $..$ and $$..$$ cannot be synchronized as
there's no difference between start and end patterns.  Consequently, a
special "TeX comment" has been provided >
	%stopzone
which will forcibly terminate the highlighting of either a texZone or a
texMathZone.

If you have a slow computer, you may wish to reduce the values for >
	:syn sync maxlines=200
	:syn sync minlines=50
(especially the latter).  If your computer is fast, you may wish to
increase them.  This primarily affects synchronizing (ie. just what group,
if any, is the text at the top of the screen supposed to be in?).

The <tex.vim> supports lexical error checking of various sorts.  Thus,
although the error checking is ofttimes very useful, it can indicate
errors where none actually are.  If this proves to be a problem for you,
you may put in your <.vimrc> the following statement: >
	let tex_no_error=1
and all error checking by <tex.vim> will be suppressed.


TF						*tf.vim* *tf-syntax*

There is one option for the tf syntax highlighting.

For syncing, minlines defaults to 100.  If you prefer another value, you can
set "tf_minlines" to the value you desire.  Example: >

	:let tf_minlines = your choice


XF86CONFIG                              *xf86conf.vim* *xf86conf-syntax*

The syntax of XF86Config file differs in XFree86 v3.x and v4.x.  Both
variants are supported.  Automatic detection is used, but is far from perfect.
You may need to specify the version manually.  Set the variable
xf86conf_xfree86_version to 3 or 4 according to your XFree86 version in
your .vimrc.  Example: >
        :let xf86conf_xfree86_version=3
When using a mix of versions, set the b:xf86conf_xfree86_version variable.

Note that spaces and underscores in option names are not supported.  Use
"SyncOnGreen" instead of "__s yn con gr_e_e_n" if you want the option name
highlighted.


XML						*xml.vim* *xml-syntax*

Xml namespaces are highlighted by default. This can be inhibited by
setting a global variable: >

	:let g:xml_namespace_transparent=1
<
							*xml-folding*
The xml syntax file provides syntax |folding| (see |:syn-fold|) between
start and end tags. This can be turned on by >

	:set foldmethod=syntax


X Pixmaps (XPM)					*xpm.vim* *xpm-syntax*

xpm.vim creates its syntax items dynamically based upon the contents of the
XPM file.  Thus if you make changes e.g. in the color specification strings,
you have to source it again e.g. with ":set syn=xpm".

To copy a pixel with one of the colors, yank a "pixel" with "yl" and insert it
somewhere else with "P".

Do you want to draw with the mouse?  Try the following: >
   :function! GetPixel()
   :   let c = getline(line("."))[col(".") - 1]
   :   echo c
   :   exe "noremap <LeftMouse> <LeftMouse>r".c
   :   exe "noremap <LeftDrag>  <LeftMouse>r".c
   :endfunction
   :noremap <RightMouse> <LeftMouse>:call GetPixel()<CR>
   :set guicursor=n:hor20	   " to see the color beneath the cursor
This turns the right button into a pipette and the left button into a pen.
It will work with XPM files that have one character per pixel only and you
must not click outside of the pixel strings, but feel free to improve it.

It will look much better with a font in a quadratic cell size, e.g. for X: >
	:set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*

==============================================================================
5. Defining a syntax					*:syn-define* *E410*

Vim understands three types of syntax items:

1. Keyword.
   It can only contain keyword characters, according to the 'iskeyword'
   option.  It cannot contain other syntax items.  It will only match with a
   complete word (there are no keyword characters before or after the match).
   The keyword "if" would match in "if(a=b)", but not in "ifdef x", because
   "(" is not a keyword character and "d" is.

2. Match.
   This is a match with a single regexp pattern.

3. Region.
   This starts at a match of the "start" regexp pattern and ends with a match
   with the "end" regexp pattern.  Any other text can appear in between.  A
   "skip" regexp pattern can be used to avoid matching the "end" pattern.

Several syntax ITEMs can be put into one syntax GROUP.  For a syntax group
you can give highlighting attributes.  For example, you could have an item
to define a "/* .. */" comment and another one that defines a "// .." comment,
and put them both in the "Comment" group.  You can then specify that a
"Comment" will be in bold font and have a blue color.  You are free to make
one highlight group for one syntax item, or put all items into one group.
This depends on how you want to specify your highlighting attributes.  Putting
each item in its own group results in having to specify the highlighting
for a lot of groups.

Note that a syntax group and a highlight group are similar.  For a highlight
group you will have given highlight attributes.  These attributes will be used
for the syntax group with the same name.

In case more than one item matches at the same position, the one that was
defined LAST wins.  Thus you can override previously defined syntax items by
using an item that matches the same text.  But a keyword always goes before a
match or region.  And a keyword with matching case always goes before a
keyword with ignoring case.


DEFINING CASE						*:syn-case* *E390*

:sy[ntax] case [match|ignore]
	This defines if the following ":syntax" commands will work with
	matching case, when using "match", or with ignoring case, when using
	"ignore".  Note that any items before this are not affected, and all
	items until the next ":syntax case" command are affected.


DEFINING KEYWORDS					*:syn-keyword*

:sy[ntax] keyword {group-name} [{options}] {keyword} .. [{options}]

	This defines a number of keywords.

	{group-name}	Is a syntax group name such as "Comment".
	[{options}]	See |:syn-arguments| below.
	{keyword} ..	Is a list of keywords which are part of this group.

	Example: >
  :syntax keyword   Type   int long char
<
	The {options} can be given anywhere in the line.  They will apply to
	all keywords given, also for options that come after a keyword.
	These examples do exactly the same: >
  :syntax keyword   Type   contained int long char
  :syntax keyword   Type   int long contained char
  :syntax keyword   Type   int long char contained
<
	When you have a keyword with an optional tail, like Ex commands in
	Vim, you can put the optional characters inside [], to define all the
	variations at once: >
  :syntax keyword   VimCommand   ab[breviate] n[ext]
<
	Don't forget that a keyword can only be recognized if all the
	characters are included in the 'iskeyword' option.  If one character
	isn't, the keyword will never be recognized.
	Multi-byte characters can also be used.  These do not have to be in
	'iskeyword'.

	A keyword always has higher priority than a match or region, the
	keyword is used if more than one item matches.  Keywords do not nest
	and a keyword can't contain anything else.

	Note that when you have a keyword that is the same as an option (even
	one that isn't allowed here), you can not use it.  Use a match
	instead.

	The maximum length of a keyword is 80 characters.

	The same keyword can be defined multiple times, when its containment
	differs.  For example, you can define the keyword once not contained
	and use one highlight group, and once contained, and use a different
	highlight group. Example: >
  :syn keyword vimCommand tag
  :syn keyword vimSetting contained tag
<	When finding "tag" outside of any syntax item, the "vimCommand"
	highlight group is used.  When finding "tag" in a syntax item that
	contains "vimSetting", the "vimSetting" group is used.


DEFINING MATCHES					*:syn-match*

:sy[ntax] match {group-name} [{options}] [excludenl] {pattern} [{options}]

	This defines one match.

	{group-name}		A syntax group name such as "Comment".
	[{options}]		See |:syn-arguments| below.
	[excludenl]		Don't make a pattern with the end-of-line "$"
				extend a containing match or region.  Must be
				given before the pattern. |:syn-excludenl|
	{pattern}		The search pattern that defines the match.
				See |:syn-pattern| below.
				Note that the pattern may match more than one
				line, which makes the match depend on where
				Vim starts searching for the pattern.  You
				need to make sure syncing takes care of this.

	Example (match a character constant): >
  :syntax match Character /'.'/hs=s+1,he=e-1
<

DEFINING REGIONS	*:syn-region* *:syn-start* *:syn-skip* *:syn-end*
							*E398* *E399*
:sy[ntax] region {group-name} [{options}]
		[matchgroup={group_name}]
		[keepend]
		[extend]
		[excludenl]
		start={start_pattern} ..
		[skip={skip_pattern}]
		end={end_pattern} ..
		[{options}]

	This defines one region.  It may span several lines.

	{group-name}		A syntax group name such as "Comment".
	[{options}]		See |:syn-arguments| below.
	[matchgroup={group-name}]  The syntax group to use for the following
				start or end pattern matches only.  Not used
				for the text in between the matched start and
				end patterns.  Use NONE to reset to not using
				a different group for the start or end match.
				See |:syn-matchgroup|.
	keepend			Don't allow contained matches to go past a
				match with the end pattern.  See
				|:syn-keepend|.
	extend			Override a "keepend" for an item this region
				is contained in. See |:syn-extend|.
	excludenl		Don't make a pattern with the end-of-line "$"
				extend a containing match or item.  Only
				useful for end patterns.  Must be given before
				the patterns it applies to. |:syn-excludenl|
	start={start_pattern}	The search pattern that defines the start of
				the region.  See |:syn-pattern| below.
	skip={skip_pattern}	The search pattern that defines text inside
				the region where not to look for the end
				pattern.  See |:syn-pattern| below.
	end={end_pattern}	The search pattern that defines the end of
				the region.  See |:syn-pattern| below.

	Example: >
  :syntax region String   start=+"+  skip=+\\"+  end=+"+
<
	The start/skip/end patterns and the options can be given in any order.
	There can be zero or one skip pattern.  There must be one or more
	start and end patterns.  This means that you can omit the skip
	pattern, but you must give at least one start and one end pattern.  It
	is allowed to have white space before and after the equal sign
	(although it mostly looks better without white space).

	When more than one start pattern is given, a match with one of these
	is sufficient.  This means there is an OR relation between the start
	patterns.  The last one that matches is used.  The same is true for
	the end patterns.

	The search for the end pattern starts right after the start pattern.
	Offsets are not used for this.  This implies that the match for the
	end pattern will never overlap with the start pattern.

	The skip and end pattern can match across line breaks, but since the
	search for the pattern can start in any line it often does not do what
	you want.  The skip pattern doesn't avoid a match of an end pattern in
	the next line.  Use single-line patterns to avoid trouble.

	Note: The decision to start a region is only based on a matching start
	pattern.  There is no check for a matching end pattern.  This does NOT
	work: >
		:syn region First  start="("  end=":"
		:syn region Second start="("  end=";"
<	The Second always matches before the First (last defined pattern has
	higher priority).  The Second region then continues until the next
	';', no matter if there is a ':' before it.  Using a match does work: >
		:syn match First  "(\_.\{-}:"
		:syn match Second "(\_.\{-};"
<	This pattern matches any character or line break with "\_." and
	repeats that with "\{-}" (repeat as few as possible).

							*:syn-keepend*
	By default, a contained match can obscure a match for the end pattern.
	This is useful for nesting.  For example, a region that starts with
	"{" and ends with "}", can contain another region.  An encountered "}"
	will then end the contained region, but not the outer region:
	    {		starts outer "{}" region
		{	starts contained "{}" region
		}	ends contained "{}" region
	    }		ends outer "{} region
	If you don't want this, the "keepend" argument will make the matching
	of an end pattern of the outer region also end any contained item.
	This makes it impossible to nest the same region, but allows for
	contained items to highlight parts of the end pattern, without causing
	that to skip the match with the end pattern.  Example: >
  :syn match  VimComment +"[^"]\+$+
  :syn region VimCommand start="set" end="$" contains=VimComment keepend
<	The "keepend" makes the VimCommand always end at the end of the line,
	even though the contained VimComment includes a match with the <EOL>.

	When "keepend" is not used, a match with an end pattern is retried
	after each contained match.  When "keepend" is included, the first
	encountered match with an end pattern is used, truncating any
	contained matches.
							*:syn-extend*
	The "keepend" behavior can be changed by using the "extend" argument.
	When an item with "extend" is contained in an item that uses
	"keepend", the "keepend" is ignored and the containing region will be
	extended.
	This can be used to have some contained items extend a region while
	others don't.  Example: >

   :syn region htmlRef start=+<a>+ end=+</a>+ keepend contains=htmlItem,htmlScript
   :syn match htmlItem +<[^>]*>+ contained
   :syn region htmlScript start=+<script+ end=+</script[^>]*>+ contained extend

<	Here the htmlItem item does not make the htmlRef item continue
	further, it is only used to highlight the <> items.  The htmlScript
	item does extend the htmlRef item.

	Another example: >
   :syn region xmlFold start="<a>" end="</a>" fold transparent keepend extend
<	This defines a region with "keepend", so that its end cannot be
	changed by contained items, like when the "</a>" is matched to
	highlight it differently.  But when the xmlFold region is nested (it
	includes itself), the "extend" applies, so that the "</a>" of a nested
	region only ends that region, and not the one it is contained in.

							*:syn-excludenl*
	When a pattern for a match or end pattern of a region includes a '$'
	to match the end-of-line, it will make a region item that it is
	contained in continue on the next line.  For example, a match with
	"\\$" (backslash at the end of the line) can make a region continue
	that would normally stop at the end of the line.  This is the default
	behavior.  If this is not wanted, there are two ways to avoid it:
	1. Use "keepend" for the containing item.  This will keep all
	   contained matches from extending the match or region.  It can be
	   used when all contained items must not extend the containing item.
	2. Use "excludenl" in the contained item.  This will keep that match
	   from extending the containing match or region.  It can be used if
	   only some contained items must not extend the containing item.
	   "excludenl" must be given before the pattern it applies to.

							*:syn-matchgroup*
	"matchgroup" can be used to highlight the start and/or end pattern
	differently than the body of the region.  Example: >
  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+  end=+"+
<	This will highlight the quotes with the "Quote" group, and the text in
	between with the "String" group.
	The "matchgroup" is used for all start and end patterns that follow,
	until the next "matchgroup".  Use "matchgroup=NONE" to go back to not
	using a matchgroup.

	In a start or end pattern that is highlighted with "matchgroup" the
	contained items of the region are not used.  This can be used to avoid
	that a contained item matches in the start or end pattern match.  When
	using "transparent", this does not apply to a start or end pattern
	match that is highlighted with "matchgroup".

	Here is an example, which highlights three levels of parentheses in
	different colors: >
   :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2
   :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained
   :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained
   :hi par1 ctermfg=red guifg=red
   :hi par2 ctermfg=blue guifg=blue
   :hi par3 ctermfg=darkgreen guifg=darkgreen

==============================================================================
6. :syntax arguments					*:syn-arguments*

The :syntax commands that define syntax items take a number of arguments.
The common ones are explained here.  The arguments may be given in any order
and may be mixed with patterns.

Not all commands accept all arguments.  This table shows which arguments
can not be used for all commands:
							*E395* *E396*
		    contains  oneline	fold  display  extend~
:syntax keyword		 -	 -	 -	 -	 -
:syntax match		yes	 -	yes	yes	yes
:syntax region		yes	yes	yes	yes	yes

These arguments can be used for all three commands:
	contained
	containedin
	nextgroup
	transparent
	skipwhite
	skipnl
	skipempty


contained						*:syn-contained*

When the "contained" argument is given, this item will not be recognized at
the top level, but only when it is mentioned in the "contains" field of
another match.  Example: >
   :syntax keyword Todo    TODO    contained
   :syntax match   Comment "//.*"  contains=Todo


display							*:syn-display*

If the "display" argument is given, this item will be skipped when the
detected highlighting will not be displayed.  This will speed up highlighting,
by skipping this item when only finding the syntax state for the text that is
to be dislayed.

Generally, you can use "display" for match and region items that meet these
conditions:
- The item does not continue past the end of a line.  Example for C: A region
  for a "/*" comment can't contain "display", because it continues on the next
  line.
- The item does not contain items that continue past the end of the line or
  make it continue on the next line.
- The item does not change the size of any item it is contained in.  Example
  for C: A match with "\\$" in a preprocessor match can't have "display",
  because it may make that preprocessor match shorter.
- The item does not allow other items to match that didn't match otherwise,
  and that item may extend the match too far.  Example for C: A match for a
  "//" comment can't use "display", because a "/*" inside that comment would
  match then and start a comment which extends past the end of the line.

Examples, for the C language, where "display" can be used:
- match with a number
- match with a label


transparent						*:syn-transparent*

If the "transparent" argument is given, this item will not be highlighted
itself, but will take the highlighting of the item it is contained in.  This
is useful for syntax items that don't need any highlighting but are used
only to skip over a part of the text.

The "contains=" argument is also inherited from the item it is contained in,
unless a "contains" argument is given for the transparent item itself.  To
avoid that unwanted items are contained, use "contains=NONE".  Example, which
highlights words in strings, but makes an exception for "vim": >
	:syn match myString /'[^']*'/ contains=myWord,myVim
	:syn match myWord   /\<[a-z]*\>/ contained
	:syn match myVim    /\<vim\>/ transparent contained contains=NONE
	:hi link myString String
	:hi link myWord   Comment
Since the "myVim" match comes after "myWord" it is the preferred match (last
match in the same position overrules an earlier one).  The "transparent"
argument makes the "myVim" match use the same highlighting as "myString".  But
it does not contain anything.  If the "contains=NONE" argument would be left
out, then "myVim" would use the contains argument from myString and allow
"myWord" to be contained, which will be highlighted as a Constant.  This
happens because a contained match doesn't match inside itself in the same
position, thus the "myVim" match doesn't overrule the "myWord" match here.

When you look at the colored text, it is like looking at layers of contained
items.  The contained item is on top of the item it is contained in, thus you
see the contained item.  When a contained item is transparent, you can look
through, thus you see the item it is contained in.  In a picture:

		look from here

	    |	|   |	|   |	|
	    V	V   V	V   V	V

	       xxxx	  yyy		more contained items
	    ....................	contained item (transparent)
	=============================	first item

The 'x', 'y' and '=' represent a highlighted syntax item.  The '.' represent a
transparent group.

What you see is:

	=======xxxx=======yyy========

Thus you look through the transparent "....".


oneline							*:syn-oneline*

The "oneline" argument indicates that the region does not cross a line
boundary.  It must match completely in the current line.  However, when the
region has a contained item that does cross a line boundary, it continues on
the next line anyway.  A contained item can be used to recognize a line
continuation pattern.

When the start pattern includes a "\n" to match an end-of-line, the end
pattern must found in the same line as where the start pattern ends.  The end
pattern may also include an end-of-line.  Thus the "oneline" argument
means that the end of the start pattern and the start of the end pattern must
be within one line.  This can't be changed by a skip pattern that matches a
line break.


fold							*:syn-fold*

The "fold" argument makes the fold level increased by one for this item.
Example: >
   :syn region myFold start="{" end="}" transparent fold
   :syn sync fromstart
   :set foldmethod=syntax
This will make each {} block form one fold.

The fold will start on the line where the item starts, and end where the item
ends.  If the start and end are within the same line, there is no fold.
The 'foldnestmax' option limits the nesting of syntax folds.
{not available when Vim was compiled without |+folding| feature}


			*:syn-contains* *E405* *E406* *E407* *E408* *E409*
contains={groupname},..

The "contains" argument is followed by a list of syntax group names.  These
groups will be allowed to begin inside the item (they may extend past the
containing group's end).  This allows for recursive nesting of matches and
regions.  If there is no "contains" argument, no groups will be contained in
this item.  The group names do not need to be defined before they can be used
here.

contains=ALL
		If the only item in the contains list is "ALL", then all
		groups will be accepted inside the item.

contains=ALLBUT,{group-name},..
		If the first item in the contains list is "ALLBUT", then all
		groups will be accepted inside the item, except the ones that
		are listed.  Example: >
  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function

contains=TOP
		If the first item in the contains list is "TOP", then all
		groups will be accepted that don't have the "contained"
		argument.
contains=TOP,{group-name},..
		Like "TOP", but excluding the groups that are listed.

contains=CONTAINED
		If the first item in the contains list is "CONTAINED", then
		all groups will be accepted that have the "contained"
		argument.
contains=CONTAINED,{group-name},..
		Like "CONTAINED", but excluding the groups that are
		listed.


The {group-name} in the "contains" list can be a pattern.  All group names
that match the pattern will be included (or excluded, if "ALLBUT" is used).
The pattern cannot contain white space or a ','.  Example: >
   ... contains=Comment.*,Keyw[0-3]
The matching will be done at moment the syntax command is executed.  Groups
that are defined later will not be matched.  Also, if the current syntax
command defines a new group, it is not matched.  Be careful: When putting
syntax commands in a file you can't rely on groups NOT being defined, because
the file may have been sourced before, and ":syn clear" doesn't remove the
group names.

The contained groups will also match in the start and end patterns of a
region.  If this is not wanted, the "matchgroup" argument can be used
|:syn-matchgroup|.  The "ms=" and "me=" offsets can be used to change the
region where contained items do match.  Note that this may also limit the
area that is highlighted


containedin={groupname}...				*:syn-containedin*

The "containedin" argument is followed by a list of syntax group names.  The
item will be allowed to begin inside these groups.  This works as if the
containing item has a "contains=" argument that includes this item.

The {groupname}... can be used just like for "contains", as explained above.

This is useful when adding a syntax item afterwards.  An item can be told to
be included inside an already existing item, without changing the definition
of that item.  For example, to highlight a word in a C comment after loading
the C syntax: >
	:syn keyword myword HELP containedin=cComment contained
Note that "contained" is also used, to avoid that the item matches at the top
level.

Matches for "containedin" are added to the other places where the item can
appear.  A "contains" argument may also be added as usual.  Don't forget that
keywords never contain another item, thus adding them to "containedin" won't
work.


nextgroup={groupname},..				*:syn-nextgroup*

The "nextgroup" argument is followed by a list of syntax group names,
separated by commas (just like with "contains", so you can also use patterns).

If the "nextgroup" argument is given, the mentioned syntax groups will be
tried for a match, after the match or region ends.  If none of the groups have
a match, highlighting continues normally.  If there is a match, this group
will be used, even when it is not mentioned in the "contains" field of the
current group.  This is like giving the mentioned group priority over all
other groups.  Example: >
   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo
   :syntax match  ccFoo     "Foo"	    contained nextgroup=ccFiller
   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained

This will highlight "Foo" and "Bar" differently, and only when there is a
"Bar" after "Foo".  In the text line below, "f" shows where ccFoo is used for
highlighting, and "bbb" where ccBar is used. >

   Foo asdfasd Bar asdf Foo asdf Bar asdf
   fff	       bbb      fff      bbb

Note the use of ".\{-}" to skip as little as possible until the next Bar.
when ".*" would be used, the "asdf" in between "Bar" and "Foo" would be
highlighted according to the "ccFoobar" group, because the ccFooBar match
would include the first "Foo" and the last "Bar" in the line (see |pattern|).


skipwhite						*:syn-skipwhite*
skipnl							*:syn-skipnl*
skipempty						*:syn-skipempty*

These arguments are only used in combination with "nextgroup".  They can be
used to allow the next group to match after skipping some text:
	skipwhite	skip over space and Tab characters
	skipnl		skip over the end of a line
	skipempty	skip over empty lines (implies a "skipnl")

When "skipwhite" is present, the white space is only skipped if there is no
next group that matches the white space.

When "skipnl" is present, the match with nextgroup may be found in the next
line.  This only happens when the current item ends at the end of the current
line!  When "skipnl" is not present, the nextgroup will only be found after
the current item in the same line.

When skipping text while looking for a next group, the matches for other
groups are ignored.  Only when no next group matches, other items are tried
for a match again.  This means that matching a next group and skipping white
space and <EOL>s has a higher priority than other items.

Example: >
  :syn match ifstart "if.*"     nextgroup=ifline skipwhite skipempty
  :syn match ifline  "endif"    contained
  :syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained
Note that the last match, which matches any non-white text, is put last,
otherwise the "endif" of the indent would never match, because the "[^ \t].*"
would match first.
Note that this example doesn't work for nested "if"s.  You need to add
"contains" arguments to make that work (omitted for simplicity of the
example).

==============================================================================
7. Syntax patterns				*:syn-pattern* *E401* *E402*

In the syntax commands, a pattern must be surrounded by two identical
characters.  This is like it works for the ":s" command.  The most common to
use is the double quote.  But if the pattern contains a double quote, you can
use another character that is not used in the pattern.  Examples: >
  :syntax region Comment  start="/\*"  end="\*/"
  :syntax region String   start=+"+    end=+"+   skip=+\\"+

See |pattern| for the explanation of what a pattern is.  Syntax patterns are
always interpreted like the 'magic' options is set, no matter what the actual
value of 'magic' is.  And the patterns are interpreted like the 'l' flag is
not included in 'cpoptions'.  This was done to make syntax files portable and
independent of 'compatible' and 'magic' settings.

Try to avoid patterns that can match an empty string, such as "[a-z]*".
This slows down the highlighting a lot, because it matches everywhere.

						*:syn-pattern-offset*
The pattern can be followed by a character offset.  This can be used to
change the highlighted part, and to change the text area included in the
match or region (which only matters when trying to match other items).  Both
are relative to the matched pattern.  The character offset for a skip
pattern can be used to tell where to continue looking for an end pattern.

The offset takes the form of "{what}={offset}"
The {what} can be one of seven strings:

ms	Match Start	offset for the start of the matched text
me	Match End	offset for the end of the matched text
hs	Highlight Start	offset for where the highlighting starts
he	Highlight End	offset for where the highlighting ends
rs	Region Start	offset for where the body of a region starts
re	Region End	offset for where the body of a region ends
lc	Leading Context	offset past "leading context" of pattern

The {offset} can be:

s	start of the matched pattern
s+{nr}	start of the matched pattern plus {nr} chars to the right
s-{nr}	start of the matched pattern plus {nr} chars to the left
e	end of the matched pattern
e+{nr}	end of the matched pattern plus {nr} chars to the right
e-{nr}	end of the matched pattern plus {nr} chars to the left
{nr}	(for "lc" only): start matching {nr} chars to the left

Examples: "ms=s+1", "hs=e-2", "lc=3".

Although all offsets are accepted after any pattern, they are not always
meaningful.  This table shows which offsets are actually used:

		    ms   me   hs   he   rs   re	  lc ~
match item	    yes  yes  yes  yes  -    -    yes
region item start   yes  -    yes  -    yes  -    yes
region item skip    -    yes  -    -    -    -    yes
region item end     -    yes  -    yes  -    yes  yes

Offsets can be concatenated, with a ',' in between.  Example: >
  :syn match String  /"[^"]*"/hs=s+1,he=e-1
<
    some "string" text
	  ^^^^^^		highlighted

Notes:
- There must be no white space between the pattern and the character
  offset(s).
- The highlighted area will never be outside of the matched text.
- A negative offset for an end pattern may not always work, because the end
  pattern may be detected when the highlighting should already have stopped.
- The start of a match cannot be in a line other than where the pattern
  matched.  This doesn't work: "a\nb"ms=e.  You can make the highlighting
  start in another line, this does work: "a\nb"hs=e.

Example (match a comment but don't highlight the /* and */): >
  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1
<
	/* this is a comment */
	  ^^^^^^^^^^^^^^^^^^^     highlighted

A more complicated Example: >
  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1
<
	 abcfoostringbarabc
	    mmmmmmmmmmm	    match
	      ssrrrreee	    highlight start/region/end ("Foo", "Exa" and "Bar")

Leading context			*:syn-lc* *:syn-leading* *:syn-context*

Note: This is an obsolete feature, only included for backwards compatibility
with previous Vim versions.  It's now recommended to use the |/\@<=| construct
in the pattern.

The "lc" offset specifies leading context -- a part of the pattern that must
be present, but is not considered part of the match.  An offset of "lc=n" will
cause Vim to step back n columns before attempting the pattern match, allowing
characters which have already been matched in previous patterns to also be
used as leading context for this match.  This can be used, for instance, to
specify that an "escaping" character must not precede the match: >

  :syn match ZNoBackslash "[^\\]z"ms=s+1
  :syn match WNoBackslash "[^\\]w"lc=1
  :syn match Underline "_\+"
<
	  ___zzzz ___wwww
	  ^^^     ^^^	  matches Underline
	      ^ ^	  matches ZNoBackslash
		     ^^^^ matches WNoBackslash

The "ms" offset is automatically set to the same value as the "lc" offset,
unless you set "ms" explicitly.


Multi-line patterns					*:syn-multi-line*

The patterns can include "\n" to match an end-of-line.  Mostly this works as
expected, but there are a few exceptions.

When using a start pattern with an offset, the start of the match is not
allowed to start in a following line.  The highlighting can start in a
following line though.

The skip pattern can include the "\n", but the search for an end pattern will
continue in the first character of the next line, also when that character is
matched by the skip pattern.  This is because redrawing may start in any line
halfway a region and there is no check if the skip pattern started in a
previous line.  For example, if the skip pattern is "a\nb" and an end pattern
is "b", the end pattern does match in the second line of this: >
	 x x a
	 b x x
Generally this means that the skip pattern should not match any characters
after the "\n".


External matches					*:syn-ext-match*

These extra regular expression items are available in region patterns:

						*/\z(* */\z(\)* *E50* *E52*
    \z(\)	Marks the sub-expression as "external", meaning that it is can
		be accessed from another pattern match.  Currently only usable
		in defining a syntax region start pattern.

    \z1  ...  \z9				*/\z1* */\z2* *\z9* *E66* *E67*
		Matches the same string that was matched by the corresponding
		sub-expression in a previous start pattern match.

Sometimes the start and end patterns of a region need to share a common
sub-expression.  A common example is the "here" document in Perl and many Unix
shells.  This effect can be achieved with the "\z" special regular expression
items, which marks a sub-expression as "external", in the sense that it can be
referenced from outside the pattern in which it is defined.  The here-document
example, for instance, can be done like this: >
  :syn region hereDoc start="<<\z(\I\i*\)" end="^\z1$"

As can be seen here, the \z actually does double duty.  In the start pattern,
it marks the "\(\I\i*\)" sub-expression as external; in the end pattern, it
changes the \1 back-reference into an external reference referring to the
first external sub-expression in the start pattern.  External references can
also be used in skip patterns: >
  :syn region foo start="start \(\I\i*\)" skip="not end \z1" end="end \z1"

Note that normal and external sub-expressions are completely orthogonal and
indexed separately; for instance, if the pattern "\z(..\)\(..\)" is applied
to the string "aabb", then \1 will refer to "bb" and \z1 will refer to "aa".
Note also that external sub-expressions cannot be accessed as back-references
within the same pattern like normal sub-expressions.  If you want to use one
sub-expression as both a normal and an external sub-expression, you can nest
the two, as in "\(\z(...\)\)".

Note that only matches within a single line can be used.  Multi-line matches
cannot be referred to.

==============================================================================
8. Syntax clusters					*:syn-cluster* *E400*

:sy[ntax] cluster {cluster-name} [contains={group-name}..]
				 [add={group-name}..]
				 [remove={group-name}..]

This command allows you to cluster a list of syntax groups together under a
single name.

	contains={group-name}..
		The cluster is set to the specified list of groups.
	add={group-name}..
		The specified groups are added to the cluster.
	remove={group-name}..
		The specified groups are removed from the cluster.

A cluster so defined may be referred to in a contains=.., nextgroup=.., add=..
or remove=.. list with a "@" prefix.  You can also use this notation to
implicitly declare a cluster before specifying its contents.

Example: >
   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers
   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2

As the previous example suggests, modifications to a cluster are effectively
retroactive; the membership of the cluster is checked at the last minute, so
to speak: >
   :syntax keyword A aaa
   :syntax cluster AandB contains=A
   :syntax match Stuff "( aaa bbb )" contains=@AandB
   :syntax cluster AandB add=B    " now both keywords are matched in Stuff

This also has implications for nested clusters: >
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster SmallGroup contains=B
   :syntax cluster BigGroup contains=A,@SmallGroup
   :syntax match Stuff "( aaa bbb )" contains=@BigGroup
   :syntax cluster BigGroup remove=B    " no effect, since B isn't in BigGroup
   :syntax cluster SmallGroup remove=B  " now bbb isn't matched within Stuff

==============================================================================
9. Including syntax files				*:syn-include* *E397*

It is often useful for one language's syntax file to include a syntax file for
a related language.  Depending on the exact relationship, this can be done in
two different ways:

	- If top-level syntax items in the included syntax file are to be
	  allowed at the top level in the including syntax, you can simply use
	  the |:runtime| command: >

  " In cpp.vim:
  :runtime! syntax/c.vim
  :unlet b:current_syntax

<	- If top-level syntax items in the included syntax file are to be
	  contained within a region in the including syntax, you can use the
	  ":syntax include" command:

:sy[ntax] include [@{grouplist-name}] {file-name}

	  All syntax items declared in the included file will have the
	  "contained" flag added.  In addition, if a group list is specified,
	  all top-level syntax items in the included file will be added to
	  that list. >

   " In perl.vim:
   :syntax include @Pod <sfile>:p:h/pod.vim
   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod
<
	  When {file-name} is an absolute path (starts with "/", "c:", "$VAR"
	  or "<sfile>") that file is sourced.  When it is a relative path
	  (e.g., "syntax/pod.vim") the file is searched for in 'runtimepath'.
	  All matching files are loaded.  Using a relative path is
	  recommended, because it allows a user to replace the included file
	  with his own version, without replacing the file that does the ":syn
	  include".

==============================================================================
10. Synchronizing				*:syn-sync* *E403* *E404*

Vim wants to be able to start redrawing in any position in the document.  To
make this possible it needs to know the syntax state at the position where
redrawing starts.

:sy[ntax] sync [ccomment [group-name] | minlines={N} | ...]

There are four ways to synchronize:
1. Always parse from the start of the file.
   |:syn-sync-first|
2. Based on C-style comments.  Vim understands how C-comments work and can
   figure out if the current line starts inside or outside a comment.
   |:syn-sync-second|
3. Jumping back a certain number of lines and start parsing there.
   |:syn-sync-third|
4. Searching backwards in the text for a pattern to sync on.
   |:syn-sync-fourth|

				*:syn-sync-maxlines* *:syn-sync-minlines*
For the last three methods, the line range where the parsing can start is
limited by "minlines" and "maxlines".

If the "minlines={N}" argument is given, the parsing always starts at least
that many lines backwards.  This can be used if the parsing may take a few
lines before it's correct, or when it's not possible to use syncing.

If the "maxlines={N}" argument is given, the number of lines that are searched
for a comment or syncing pattern is restricted to N lines backwards (after
adding "minlines".  This is useful if you have few things to sync on and a
slow machine.  Example: >
   :syntax sync ccomment maxlines=500
<
						*:syn-sync-linebreaks*
When using a pattern that matches multiple lines, a change in one line may
cause a pattern to no longer match in a previous line.  This means has to
start above where the change was made.  How many lines can be specified with
the "linebreaks" argument.  For example, when a pattern may include one line
break use this: >
   :syntax sync linebreaks=1
The result is that redrawing always starts at least one line before where a
change was made.  The default value for "linebreaks" is zero.  Usually the
value for "minlines" is bigger than "linebreaks".


First syncing method:			*:syn-sync-first*
>
   :syntax sync fromstart

The file will be parsed from the start.  This makes syntax highlighting
accurate, but can be slow for long files.  Vim caches previously parsed text,
so that it's only slow when parsing the text for the first time.  However,
when making changes some part of the next needs to be parsed again (worst
case: to the end of the file).

Using "fromstart" is equivalent to using "minlines" with a very large number.


Second syncing method:			*:syn-sync-second* *:syn-sync-ccomment*

For the second method, only the "ccomment" argument needs to be given.
Example: >
   :syntax sync ccomment

When Vim finds that the line where displaying starts is inside a C-style
comment, the last region syntax item with the group-name "Comment" will be
used.  This requires that there is a region with the group-name "Comment"!
An alternate group name can be specified, for example: >
   :syntax sync ccomment javaComment
This means that the last item specified with "syn region javaComment" will be
used for the detected C comment region.  This only works properly if that
region does have a start pattern "\/*" and an end pattern "*\/".

The "maxlines" argument can be used to restrict the search to a number of
lines.  The "minlines" argument can be used to at least start a number of
lines back (e.g., for when there is some construct that only takes a few
lines, but it hard to sync on).

Note: Syncing on a C comment doesn't work properly when strings are used
that cross a line and contain a "*/".  Since letting strings cross a line
is a bad programming habit (many compilers give a warning message), and the
chance of a "*/" appearing inside a comment is very small, this restriction
is hardly ever noticed.


Third syncing method:				*:syn-sync-third*

For the third method, only the "minlines={N}" argument needs to be given.
Vim will subtract {N} from the line number and start parsing there.  This
means {N} extra lines need to be parsed, which makes this method a bit slower.
Example: >
   :syntax sync minlines=50

"lines" is equivalent to "minlines" (used by older versions).


Fourth syncing method:				*:syn-sync-fourth*

The idea is to synchronize on the end of a few specific regions, called a
sync pattern.  Only regions can cross lines, so when we find the end of some
region, we might be able to know in which syntax item we are.  The search
starts in the line just above the one where redrawing starts.  From there
the search continues backwards in the file.

This works just like the non-syncing syntax items.  You can use contained
matches, nextgroup, etc.  But there are a few differences:
- Keywords cannot be used.
- The syntax items with the "sync" keyword form a completely separated group
  of syntax items.  You can't mix syncing groups and non-syncing groups.
- The matching works backwards in the buffer (line by line), instead of
  forwards.
- A line continuation pattern can be given.  It is used to decide which group
  of lines need to be searched like they were one line.  This means that the
  search for a match with the specified items starts in the first of the
  consecutive that contain the continuation pattern.
- When using "nextgroup" or "contains", this only works within one line (or
  group of continued lines).
- When using a region, it must start and end in the same line (or group of
  continued lines).  Otherwise the end is assumed to be at the end of the
  line (or group of continued lines).
- When a match with a sync pattern is found, the rest of the line (or group of
  continued lines) is searched for another match.  The last match is used.
  This is used when a line can contain both the start end the end of a region
  (e.g., in a C-comment like /* this */, the last "*/" is used).

There are two ways how a match with a sync pattern can be used:
1. Parsing for highlighting starts where redrawing starts (and where the
   search for the sync pattern started).  The syntax group that is expected
   to be valid there must be specified.  This works well when the regions
   that cross lines cannot contain other regions.
2. Parsing for highlighting continues just after the match.  The syntax group
   that is expected to be present just after the match must be specified.
   This can be used when the previous method doesn't work well.  It's much
   slower, because more text needs to be parsed.
Both types of sync patterns can be used at the same time.

Besides the sync patterns, other matches and regions can be specified, to
avoid finding unwanted matches.

[The reason that the sync patterns are given separately, is that mostly the
search for the sync point can be much simpler than figuring out the
highlighting.  The reduced number of patterns means it will go (much)
faster.]

					    *syn-sync-grouphere* *E393* *E394*
    :syntax sync match {sync-group-name} grouphere {group-name} "pattern" ..

	Define a match that is used for syncing.  {group-name} is the
	name of a syntax group that follows just after the match.  Parsing
	of the text for highlighting starts just after the match.  A region
	must exist for this {group-name}.  The first one defined will be used.
	"NONE" can be used for when there is no syntax group after the match.

						*syn-sync-groupthere*
    :syntax sync match {sync-group-name} groupthere {group-name} "pattern" ..

	Like "grouphere", but {group-name} is the name of a syntax group that
	is to be used at the start of the line where searching for the sync
	point started.  The text between the match and the start of the sync
	pattern searching is assumed not to change the syntax highlighting.
	For example, in C you could search backwards for "/*" and "*/".  If
	"/*" is found first, you know that you are inside a comment, so the
	"groupthere" is "cComment".  If "*/" is found first, you know that you
	are not in a comment, so the "groupthere" is "NONE".  (in practice
	it's a bit more complicated, because the "/*" and "*/" could appear
	inside a string.  That's left as an exercise to the reader...).

    :syntax sync match ..
    :syntax sync region ..

	Without a "groupthere" argument.  Define a region or match that is
	skipped while searching for a sync point.

    :syntax sync linecont {pattern}

	When {pattern} matches in a line, it is considered to continue in
	the next line.  This means that the search for a sync point will
	consider the lines to be concatenated.

If the "maxlines={N}" argument is given too, the number of lines that are
searched for a match is restricted to N.  This is useful if you have very
few things to sync on and a slow machine.  Example: >
   :syntax sync maxlines=100

You can clear all sync settings with: >
   :syntax sync clear

You can clear specific sync patterns with: >
   :syntax sync clear {sync-group-name} ..

==============================================================================
11. Listing syntax items		*:syntax* *:sy* *:syn* *:syn-list*

This commands lists all the syntax items: >

    :sy[ntax] [list]

To show the syntax items for one syntax group: >

    :sy[ntax] list {group-name}

To list the syntax groups in one cluster:			*E392*  >

    :sy[ntax] list @{cluster-name}

See above for other arguments for the ":syntax" command.

Note that the ":syntax" command can be abbreviated to ":sy", although ":syn"
is mostly used, because it looks better.

==============================================================================
12. Highlight command			*:highlight* *:hi* *E28* *E411* *E415*

There are three types of highlight groups:
- The ones used for specific languages.  For these the name starts with the
  name of the language.  Many of these don't have any attributes, but are
  linked to a group of the second type.
- The ones used for all syntax languages.
- The ones used for the 'highlight' option.
							*hitest.vim*
You can see all the groups currently active with this command: >
    :so $VIMRUNTIME/syntax/hitest.vim
This will open a new window containing all highlight group names, displayed
in their own color.

						*:colo* *:colorscheme* *E185*
:colo[rscheme] {name}	Load color scheme {name}.  This searches 'runtimepath'
			for the file "colors/{name}.vim.  The first one that
			is found is loaded.
			To see the name of the currently active color scheme: >
				:echo colors_name

:hi[ghlight]		List all the current highlight groups that have
			attributes set.

:hi[ghlight] {group-name}
			List one highlight group.

:hi[ghlight] clear	Reset all highlighting to the defaults.  Removes all
			highlighting for groups added by the user!
			Uses the current value of 'background' to decide which
			default colors to use.

:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
			Disable the highlighting for one highlight group.  It
			is _not_ set back to the default colors.

:hi[ghlight] [default] {group-name} {key}={arg} ..
			Add a highlight group, or change the highlighting for
			an existing group.
			See |highlight-args| for the {key}={arg} arguments.
			See |:highlight-default| for the optional [default]
			argument.

Normally a highlight group is added once, in the *.vim file.  This sets
the default values for the highlighting.  After that, you can use additional
highlight commands to change the arguments that you want to set to
non-default values.  The value "NONE" can be used to switch the value off or
go back to the default value.

Example.  The syntax.vim file contains this line: >
   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff

You can change this by giving another ":highlight: command: >
   :hi Comment	gui=bold

Note that all settings that are not included remain the same, only the
specified field is used, and settings are merged with previous ones.  So, the
result is like this single command has been used: >
   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold
<
					*highlight-args* *E416* *E417* *E423*
There are three types of terminals for highlighting:
term	a normal terminal (vt100, xterm)
cterm	a color terminal (MS-DOS console, color-xterm, these have the "Co"
	termcap entry)
gui	the GUI

For each type the highlighting can be given.  This makes it possible to use
the same syntax file on all terminals, and use the optimal highlighting.

1. highlight arguments for normal terminals

term={attr-list}			*attr-list* *highlight-term* *E418*
	attr-list is a comma separated list (without spaces) of the
	following items (in any order):
		bold
		underline
		reverse
		inverse		same as reverse
		italic
		standout
		NONE		no attributes used (used to reset it)

	Note that "bold" can be used here and by using a bold font.  They
	have the same effect.

start={term-list}				*highlight-start* *E422*
stop={term-list}				*term-list* *highlight-stop*
	These lists of terminal codes can be used to get
	non-standard attributes on a terminal.

	The escape sequence specified with the "start" argument
	is written before the characters in the highlighted
	area.  It can be anything that you want to send to the
	terminal to highlight this area.  The escape sequence
	specified with the "stop" argument is written after the
	highlighted area.  This should undo the "start" argument.
	Otherwise the screen will look messed up.

	The {term-list} can have two forms:

	1. A string with escape sequences.
	   This is any string of characters, except that it can't start with
	   "t_" and blanks are not allowed.  The <> notation is recognized
	   here, so you can use things like "<Esc>" and "<Space>".  Example:
		start=<Esc>[27h;<Esc>[<Space>r;

	2. A list of terminal codes.
	   Each terminal code has the form "t_xx", where "xx" is the name of
	   the termcap entry.  The codes have to be separated with commas.
	   White space is not allowed.  Example:
		start=t_C1,t_BL
	   The terminal codes must exist for this to work.


2. highlight arguments for color terminals

cterm={attr-list}					*highlight-cterm*
	See above for the description of {attr-list} |attr-list|.
	The "cterm" argument is likely to be different from "term", when
	colors are used.  For example, in a normal terminal comments could
	be underlined, in a color terminal they can be made Blue.
	Note: Many terminals (e.g., DOS console) can't mix these attributes
	with coloring.  Use only one of "cterm=" OR "ctermfg=" OR "ctermbg=".

ctermfg={color-nr}				*highlight-ctermfg* *E421*
ctermbg={color-nr}				*highlight-ctermbg*
	The {color-nr} argument is a color number.  Its range is zero to
	(not including) the number given by the termcap entry "Co".
	The actual color with this number depends on the type of terminal
	and its settings.  Sometimes the color also depends on the settings of
	"cterm".  For example, on some systems "cterm=bold ctermfg=3" gives
	another color, on others you just get color 3.

	For an xterm this depends on your resources, and is a bit
	unpredictable.  See your xterm documentation for the defaults.  The
	colors for a color-xterm can be changed from the .Xdefaults file.
	Unfortunately this means that it's not possible to get the same colors
	for each user.  See |xterm-color| for info about color xterms.

	The MSDOS standard colors are fixed (in a console window), so these
	have been used for the names.  But the meaning of color names in X11
	are fixed, so these color settings have been used, to make the
	highlighting settings portable (complicated, isn't it?).  The
	following names are recognized, with the color number used:

	    NR-16   NR-8    COLOR NAME ~
							*cterm-colors*
	    0	    0	    Black
	    1	    4	    DarkBlue
	    2       2	    DarkGreen
	    3       6	    DarkCyan
	    4       1	    DarkRed
	    5       5	    DarkMagenta
	    6       3	    Brown, DarkYellow
	    7       7	    LightGray, LightGrey, Gray, Grey
	    8	    0*	    DarkGray, DarkGrey
	    9	    4*	    Blue, LightBlue
	    10	    2*	    Green, LightGreen
	    11	    6*	    Cyan, LightCyan
	    12	    1*	    Red, LightRed
	    13	    5*	    Magenta, LightMagenta
	    14	    3*	    Yellow, LightYellow
	    15	    7*	    White

	The number under "NR-16" is used for 16-color terminals ('t_Co'
	greater than or equal to 16).  The number under "NR-8" is used for
	8-color terminals ('t_Co' less than 16).  The '*' indicates that the
	bold attribute is set for ctermfg.  In many 8-color terminals (e.g.,
	"linux"), this causes the bright colors to appear.  This doesn't work
	for background colors!  Without the '*' the bold attribute is removed.
	If you want to set the bold attribute in a different way, put a
	"cterm=" argument AFTER the "ctermfg=" or "ctermbg=" argument.  Or use
	a number instead of a color name.

	The case of the color names is ignored.
	Note that for 16 color ansi style terminals (including xterms), the
	numbers in the NR-8 column is used. Here '*' means 'add 8' so that Blue
	is 12, DarkGray is 8 etc.

	Note that for some color terminals these names may result in the wrong
	colors!

							*:hi-normal-cterm*
	When setting the "ctermfg" or "ctermbg" colors for the Normal group,
	these will become the colors used for the non-highlighted text.
	Example: >
		:highlight Normal ctermfg=grey ctermbg=darkblue
<	When setting the "ctermbg" color for the Normal group, the
	'background' option will be adjusted automatically.  This causes the
	highlight groups that depend on 'background' to change!  This means
	you should set the colors for Normal first, before setting other
	colors.
	When a colorscheme is being used, changing 'background' causes it to
	be reloaded, which may reset all colors (including Normal).  First
	delete the "colors_name" variable when you don't want this.

	When you have set "ctermfg" or "ctermbg" for the Normal group, Vim
	needs to reset the color when exiting.  This is done with the "op"
	termcap entry |t_op|.  If this doesn't work correctly, try setting the
	't_op' option in your .vimrc.
							*E419* *E420*
	When Vim knows the normal foreground and background colors, "fg" and
	"bg" can be used as color names.  This only works after setting the
	colors for the Normal group and for the MS-DOS console.  Example, for
	reverse video: >
	    :highlight Visual ctermfg=bg ctermbg=fg
<	Note that the colors are used that are valid at the moment this
	command are given.  If the Normal group colors are changed later, the
	"fg" and "bg" colors will not be adjusted.


3. highlight arguments for the GUI

gui={attr-list}						*highlight-gui*
	These give the attributes to use in the GUI mode.
	See |attr-list| for a description.
	Note that "bold" can be used here and by using a bold font.  They
	have the same effect.
	Note that the attributes are ignored for the "Normal" group.

font={font-name}					*highlight-font*
	font-name is the name of a font, as it is used on the system Vim
	runs on.  For X11 this is a complicated name, for example: >
   font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1
<
	The font-name "NONE" can be used to revert to the default font.
	When setting the font for the "Normal" group, this becomes the default
	font (until the 'guifont' option is changed; the last one set is
	used).
	The following only works with Motif and Athena, not with other GUIs:
	When setting the font for the "Menu" group, the menus will be changed.
	When setting the font for the "Tooltip" group, the tooltips will be
	changed.
	All fonts used, except for Menu and Tooltip, should be of the same
	character size as the default font!  Otherwise redrawing problems will
	occur.

guifg={color-name}					*highlight-guifg*
guibg={color-name}					*highlight-guibg*
	These give the foreground (guifg) and background (guibg) color to
	use in the GUI.  There are a few special names:
		NONE		no color (transparent)
		bg		use normal background color
		background	use normal background color
		fg		use normal foreground color
		foreground	use normal foreground color
	To use a color name with an embedded space or other special character,
	put it in single quotes.  The single quote cannot be used then.
	Example: >
	    :hi comment guifg='salmon pink'
<
							*gui-colors*
	Suggested color names (these are available on most systems):
	    Red		LightRed	DarkRed
	    Green	LightGreen	DarkGreen	SeaGreen
	    Blue	LightBlue	DarkBlue	SlateBlue
	    Cyan	LightCyan	DarkCyan
	    Magenta	LightMagenta	DarkMagenta
	    Yellow	LightYellow	Brown		DarkYellow
	    Gray	LightGray	DarkGray
	    Black	White
	    Orange	Purple		Violet

	In the Win32 GUI version, additional system colors are available.  See
	|win32-colors|.

	You can also specify a color by its Red, Green and Blue values.
	The format is "#rrggbb", where
		"rr"	is the Red value
		"bb"	is the Blue value
		"gg"	is the Green value
	All values are hexadecimal, range from "00" to "ff".  Examples: >
  :highlight Comment guifg=#11f0c3 guibg=#ff00ff
<
					*highlight-groups* *highlight-default*
These are the default highlighting groups.  These groups are used by the
'highlight' option default.  Note that the highlighting depends on the value
of 'background'.  You can see the current settings with the ":highlight"
command.
							*hl-Cursor*
Cursor		the character under the cursor
							*hl-CursorIM*
CursorIM	like Cursor, but used when in IME mode |CursorIM|
							*hl-Directory*
Directory	directory names (and other special names in listings)
							*hl-DiffAdd*
DiffAdd		diff mode: Added line |diff.txt|
							*hl-DiffChange*
DiffChange	diff mode: Changed line |diff.txt|
							*hl-DiffDelete*
DiffDelete	diff mode: Deleted line |diff.txt|
							*hl-DiffText*
DiffText	diff mode: Changed text within a changed line |diff.txt|
							*hl-ErrorMsg*
ErrorMsg	error messages on the command line
							*hl-VertSplit*
VertSplit	the column separating vertically split windows
							*hl-Folded*
Folded		line used for closed folds
							*hl-FoldColumn*
FoldColumn	'foldcolumn'
							*hl-IncSearch*
IncSearch	'incsearch' highlighting; also used for the text replaced with
		":s///c"
							*hl-LineNr*
LineNr		line number for ":number" and ":#" commands, and when 'number'
		option is set.
							*hl-ModeMsg*
ModeMsg		'showmode' message (e.g., "-- INSERT --")
							*hl-MoreMsg*
MoreMsg		|more-prompt|
							*hl-NonText*
NonText		'~' and '@' at the end of the window, characters from
		'showbreak' and other characters that do not really exist in
		the text (e.g., ">" displayed when a double-wide character
		doesn't fit at the end of the line).
							*hl-Normal*
Normal		normal text
							*hl-Question*
Question	|hit-enter| prompt and yes/no questions
							*hl-Search*
Search		last search pattern highlighting (see 'hlsearch')
							*hl-SpecialKey*
SpecialKey	Meta and special keys listed with ":map", also for text used
		to show unprintable characters in the text, 'listchars'.
		Generally: text that is displayed differently from what it
		really is.
							*hl-StatusLine*
StatusLine	status line of current window
							*hl-StatusLineNC*
StatusLineNC	status lines of not-current windows
		Note: if this is equal to "StatusLine" Vim will use "^^^" in
		the status line of the current window.
							*hl-Title*
Title		titles for output from ":set all", ":autocmd" etc.
							*hl-Visual*
Visual		Visual mode selection
							*hl-VisualNOS*
VisualNOS	Visual mode selection when vim is "Not Owning the Selection".
		Only X11 Gui's |gui-x11| and |xterm-clipboard| supports this.
							*hl-WarningMsg*
WarningMsg	warning messages
							*hl-WildMenu*
WildMenu	current match in 'wildmenu' completion

						*hl-User1* *hl-User1..9*
The 'statusline' syntax allows the use of 9 different highlights in the
statusline and ruler (via 'rulerformat'). The names are User1 to User9.

For the GUI you can use these groups to set the colors for the menu,
scrollbars and tooltips.  They don't have defaults.  This doesn't work for the
Win32 GUI.  Only three highlight arguments have any effect here: font, guibg,
and guifg.

							*hl-Menu*
Menu		Current font, background and foreground colors of the menus.
		Also used for the toolbar.
		Applicable highlight arguments: font, guibg, guifg.

		NOTE: For Motif and Athena the font argument actually
		specifies a fontset at all times, no matter if 'guifontset' is
		empty, and as such it is tied to the current |:language| when
		set.

							*hl-Scrollbar*
Scrollbar	Current background and foreground of the main window's
		scrollbars.
		Applicable highlight arguments: guibg, guifg.

							*hl-Tooltip*
Tooltip		Current font, background and foreground of the tooltips.
		Applicable highlight arguments: font, guibg, guifg.

		NOTE: For Motif and Athena the font argument actually
		specifies a fontset at all times, no matter if 'guifontset' is
		empty, and as such it is tied to the current |:language| when
		set.

==============================================================================
13. Linking groups		*:hi-link* *:highlight-link* *E412* *E413*

When you want to use the same highlighting for several syntax groups, you
can do this more easily by linking the groups into one common highlight
group, and give the color attributes only for that group.

To set a link:

    :hi[ghlight][!] [default] link {from-group} {to-group}

To remove a link:

    :hi[ghlight][!] [default] link {from-group} NONE

Notes:							*E414*
- If the {from-group} and/or {to-group} doesn't exist, it is created.  You
  don't get an error message for a non-existing group.
- As soon as you use a ":highlight" command for a linked group, the link is
  removed.
- If there are already highlight settings for the {from-group}, the link is
  not made, unless the '!' is given.  For a ":highlight link" command in a
  sourced file, you don't get an error message.  This can be used to skip
  links for groups that already have settings.

					*:hi-default* *:highlight-default*
The [default] argument is used for setting the default highlighting for a
group.  If highlighting has already been specified for the group the command
will be ignored.  Also when there is an existing link.

Using [default] is especially useful to overrule the highlighting of a
specific syntax file.  For example, the C syntax file contains: >
	:highlight default link cComment Comment
If you like Question highlighting for C comments, put this in your vimrc file: >
	:highlight link cComment Question
Without the "default" in the C syntax file, the highlighting would be
overruled when the syntax file is loaded.

==============================================================================
14. Cleaning up						*:syn-clear* *E391*

If you want to clear the syntax stuff for the current buffer, you can use this
command: >
  :syntax clear

This command should be used when you want to switch off syntax highlighting,
or when you want to switch to using another syntax.  It's normally not needed
in a syntax file itself, because syntax is cleared by the autocommands that
load the syntax file.
The command also deletes the "b:current_syntax" variable, since no syntax is
loaded after this command.

If you want to disable syntax highlighting for all buffers, you need to remove
the autocommands that load the syntax files: >
  :syntax off

What this command actually does, is executing the command >
  :source $VIMRUNTIME/syntax/nosyntax.vim
See the "nosyntax.vim" file for details.  Note that for this to work
$VIMRUNTIME must be valid.  See |$VIMRUNTIME|.

To clean up specific syntax groups for the current buffer: >
  :syntax clear {group-name} ..
This removes all patterns and keywords for {group-name}.

To clean up specific syntax group lists for the current buffer: >
  :syntax clear @{grouplist-name} ..
This sets {grouplist-name}'s contents to an empty list.

						*:syntax-reset* *:syn-reset*
If you have changed the colors and messed them up, use this command to get the
defaults back: >

  :syntax reset

This doesn't change the colors for the 'highlight' option.

Note that the syntax colors that you set in your vimrc file will also be reset
back to their Vim default.
Note that if you are using a color scheme, the colors defined by the color
scheme for syntax highlighting will be lost.

What this actually does is: >

	let g:syntax_cmd = "reset"
	runtime! syntax/syncolor.vim

Note that this uses the 'runtimepath' option.

							*syncolor*
If you want to use different colors for syntax highlighting, you can add a Vim
script file to set these colors.  Put this file in a directory in
'runtimepath' which comes after $VIMRUNTIME, so that your settings overrule
the default colors.  This way these colors will be used after the ":syntax
reset" command.

For Unix you can use the file ~/.vim/after/syntax/syncolor.vim.  Example: >

	if &background == "light"
	  highlight comment ctermfg=darkgreen guifg=darkgreen
	else
	  highlight comment ctermfg=green guifg=green
	endif

Note that when a color scheme is used, there might be some confusion whether
your defined colors are to be used or the colors from the scheme.  This
depends on the color scheme file.  See |:colorscheme|.

							*syntax_cmd*
The "syntax_cmd" variable is set to one of these values when the
syntax/syncolor.vim files are loaded:
   "on"		":syntax on" command.  Highlight colors are overruled but
		links are kept
   "enable"	":syntax enable" command.  Only define colors for groups that
		don't have highlighting yet.  Use ":syntax default".
   "reset"	":syntax reset" command or loading a color scheme.  Define all
		the colors.
   "skip"	Dont' define colors.  Used to skip the default settings when a
		syncolor.vim file earlier in 'runtimepath' has already set
		them.

==============================================================================
15. Highlighting tags					*tag-highlight*

If you want to highlight all the tags in your file, you can use the following
mappings.

	<F11>	-- Generate tags.vim file, and highlight tags.
	<F12>	-- Just highlight tags based on existing tags.vim file.
>
  :map <F11>  :sp tags<CR>:%s/^\([^	:]*:\)\=\([^	]*\).*/syntax keyword Tag \2/<CR>:wq! tags.vim<CR>/^<CR><F12>
  :map <F12>  :so tags.vim<CR>

WARNING: The longer the tags file, the slower this will be, and the more
memory Vim will consume.

Only highlighting typedefs, unions and structs can be done too.  For this you
must use Exuberant ctags (found at http://ctags.sf.net).

Put these lines in your Makefile:

# Make a highlight file for types.  Requires Exuberant ctags and awk
types: types.vim
types.vim: *.[ch]
	ctags -i=gstuS -o- *.[ch] |\
		awk 'BEGIN{printf("syntax keyword Type\t")}\
			{printf("%s ", $$1)}END{print ""}' > $@

And put these lines in your .vimrc: >

   " load the types.vim highlighting file, if it exists
   autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'
   autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)
   autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname
   autocmd BufRead,BufNewFile *.[ch] endif

==============================================================================
16. Color xterms				*xterm-color* *color-xterm*

Most color xterms have only eight colors.  They should work with these
lines in your .vimrc: >
   :if has("terminfo")
   :  set t_Co=8
   :  set t_Sf=<Esc>[3%p1%dm
   :  set t_Sb=<Esc>[4%p1%dm
   :else
   :  set t_Co=8
   :  set t_Sf=<Esc>[3%dm
   :  set t_Sb=<Esc>[4%dm
   :endif
<	[<Esc> is a real escape, type CTRL-V <Esc>]

You might want to put these lines in an ":if" that checks the name of your
terminal, for example: >
   :if &term =~ "xterm"
<  put above lines here >
   :endif

Note: Do these settings BEFORE doing ":syntax on".  Otherwise the colors may
be wrong.
							*xiterm* *rxvt*
The above settings have been mentioned to work for xiterm and rxvt too.
But for using 16 colors in an rxvt these should work with terminfo: >
	:set t_AB=<Esc>[%?%p1%{8}%<%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm
	:set t_AF=<Esc>[%?%p1%{8}%<%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm
<
							*colortest.vim*
To test your color setup, a file has been included in the Vim distribution.
To use it, execute these commands: >
   :e $VIMRUNTIME/syntax/colortest.vim
   :so %

Some versions of xterm (and other terminals, like the linux console) can
output lighter foreground colors, even though the number of colors is defined
at 8.  Therefore Vim sets the "cterm=bold" attribute for light foreground
colors, when 't_Co' is 8.

							*xfree-xterm*
To get 16 colors or more, get the newest xterm version (which should be
included with Xfree86 3.3 and later).  You can also find the latest version
at: >
	http://www.clark.net/pub/dickey/xterm
Here is a good way to configure it.  This uses 88 colors and enables the
termcap-query feature, which allows Vim to ask the xterm how many colors it
supports. >
	./configure --disable-bold-color --enable-88-color --enable-tcap-query
If you only get 8 colors, check the xterm compilation settings.
(Also see |UTF8-xterm| for using this xterm with UTF-8 character encoding).

This xterm should work with these lines in your .vimrc: >
   :if has("terminfo")
   :  set t_Co=16
   :  set t_AB=<Esc>[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm
   :  set t_AF=<Esc>[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm
   :else
   :  set t_Co=16
   :  set t_Sf=<Esc>[3%dm
   :  set t_Sb=<Esc>[4%dm
   :endif
<	[<Esc> is a real escape, type CTRL-V <Esc>]

Without |+terminfo|, Vim will recognize these settings, and automatically
translate cterm colors of 8 and above to "<Esc>[9%dm" and "<Esc>[10%dm".
Colors above 16 are also translated automatically.

Or just set the TERM environment variable to "xterm-16color" and try if that
works.

You probably want to use these X resources (in your ~/.Xdefaults file):
	XTerm*color0:			#000000
	XTerm*color1:			#c00000
	XTerm*color2:			#008000
	XTerm*color3:			#808000
	XTerm*color4:			#0000c0
	XTerm*color5:			#c000c0
	XTerm*color6:			#008080
	XTerm*color7:			#c0c0c0
	XTerm*color8:			#808080
	XTerm*color9:			#ff6060
	XTerm*color10:			#00ff00
	XTerm*color11:			#ffff00
	XTerm*color12:			#8080ff
	XTerm*color13:			#ff40ff
	XTerm*color14:			#00ffff
	XTerm*color15:			#ffffff
	Xterm*cursorColor:		Black

[Note: The cursorColor is required to work around a bug, which changes the
cursor color to the color of the last drawn text.  This has been fixed by a
newer version of xterm, but not everybody is it using yet.]

To get these right away, reload the .Xdefaults file to the X Option database
Manager (you only need to do this when you just changed the .Xdefaults file): >
  xrdb -merge ~/.Xdefaults
<
							*xterm-blink*
To make the cursor blink in an xterm, see tools/blink.c.  Or use Thomas
Dickey's xterm above patchlevel 107 (see above for where to get it), with
these resources:
	XTerm*cursorBlink:	on
	XTerm*cursorOnTime:	400
	XTerm*cursorOffTime:	250
	XTerm*cursorColor:	White

							*hpterm-color*
These settings work (more or less) for a hpterm, which only supports 8
foreground colors: >
   :if has("terminfo")
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%p1%dS
   :  set t_Sb=<Esc>[&v7S
   :else
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%dS
   :  set t_Sb=<Esc>[&v7S
   :endif
<	[<Esc> is a real escape, type CTRL-V <Esc>]

						*Eterm* *enlightened-terminal*
These settings have been reported to work for the Enlightened terminal
emulator, or Eterm.  They might work for all xterm-like terminals that use the
bold attribute to get bright colors.  Add an ":if" like above when needed. >
       :set t_Co=16
       :set t_AF=^[[%?%p1%{8}%<%t3%p1%d%e%p1%{22}%+%d;1%;m
       :set t_AB=^[[%?%p1%{8}%<%t4%p1%d%e%p1%{32}%+%d;1%;m
<
						*TTpro-telnet*
These settings should work for TTpro telnet.  Tera Term Pro is a freeware /
open-source program for MS-Windows. >
	set t_Co=16
	set t_AB=^[[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{32}%+5;%;%dm
	set t_AF=^[[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{22}%+1;%;%dm
Also make sure TTpro's Setup / Window / Full Color is enabled, and make sure
that Setup / Font / Enable Bold is NOT enabled.
(info provided by John Love-Jensen <eljay@Adobe.COM>)

 vim:tw=78:sw=4:ts=8:ft=help:norl:
