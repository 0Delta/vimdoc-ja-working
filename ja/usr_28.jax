COMMENT: 折畳み
STATUS: finished 6.3.054
TRANSLATOR: 清水俊彦(しみず) <mailto:t_smz@syd.odn.ne.jp>
TRANSLATOR: nakadaira <hopper2@nanameue.jp>

*usr_28.txt*	For Vim version 6.3.  Last change: 2003 Dec 21

		     VIM USER MANUAL - by Bram Moolenaar

				    折畳み


構造を持った文章であれば、セクションに分割することができます。各セクションに
はさらにサブセクションがあります。フォールドを使うと１つのセクションを１行に
表示することで、文書の概要を見やすくできます。この章では違った方法でこれを実
行する方法も説明します。

|28.1|	フォールドって何？
|28.2|	手動でのフォールド
|28.3|	フォールドで作業する
|28.4|	フォールドの保存と復元
|28.5|	段付けを使ったフォールド
|28.6|	マーク(?marker)を使ったフォールド
|28.7|	文法を使ったフォールド
|28.8|	式によるフォールド
|28.9|	変更していな行をフォールドする
|28.10| どのフォールド方法を使えばいいの？

     Next chapter: |usr_29.txt|  プログラム内の移動
 Previous chapter: |usr_27.txt|  検索コマンドと正規表現
Table of contents: |usr_toc.txt|

==============================================================================
*28.1*	フォールドって何？

フォールドはバッファ中のある範囲の行を画面上で１行にまとめて表示する時に使い
ます。本物の紙のように一部を折り畳んでコンパクトにすることができます。

	+------------------------+
	| line 1		 |
	| line 2		 |
	| line 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / folded lines		  /
	/________________________/
	| line 12		 |
	| line 13		 |
	| line 14		 |
	+------------------------+

フォールドしてもその文章はバッファに残ったままで変化ありません。画面に表示さ
れている行だけがフォールドの影響を受けます。

フォールドのメリットは文章の構造の見通しを良くしてくれる点にあります。１つの
セクションをフォールドすると、それがセクションであることを示す１行の表示とな
ります。

==============================================================================
*28.2*	手動でのフォールド

まずはやってみましょう。カーソルをどこかの段落に動かしてこう入力しましょう。
>
	zfap

段落がハイライト表示の行に置き換わったでしょう。これでフォールドを作ったわけ
です。|zf|はオペレータ、|ap|はテキストオブジェクト選択のコマンドです。ですか
ら、|zf|オペレータと好きなカーソル移動コマンドを組み合せて、対象としたい範囲
を自由に指定することができます。|zf|コマンドはビジュアルモードでも使えます。

フォールドした文章を見るには、このコマンドを使います。 >

	zo

再度フォールドするのはこのコマンドです。 >

	zc

フォールド関連のコマンドは全て"z"で始まります。少し想像力を働かせると、折畳ん
だ紙を横から見た図に見えるでしょう。"z"に続く文字にはコマンドを覚えやすそうな
ものを選んでいます。

	zf	フォールド(Fold)を作る
	zo	フォールドを開く(Open)
	zc	フォールドを閉じる(Close)

フォールドはネスト(多重化)できます。途中にフォールドがある範囲をさらにフォー
ルドすることもできます。例えば、この章の各段落をそれぞれフォールドしておいて
さらにこの章全体をフォールドできます。やってみましょう。章全体のフォールドを
解く(開く)とその中にあるフォールドは元の状態、つまり一部はフォールドしたまま
で、一部は開いた状態で表示されることがわかります。

いくつかのフォールドを作っていて、その全部を開きたい時はどうすればいいでしょ
うか。それぞれのフォールドにカーソルを動かして"zo"を使うのもできますが、この
コマンドを使えば、ずっと早くできます。 >

	zr

これはフォールドを減らす(Reduce)という意味です。その逆は、 >

	zm

です。これはフォールドを増やす(More)という意味です。"zr"と"zm"を繰り返すと多
重化したフォールドを数回で開いたり閉じたりできます。

何重にも多重化したフォールドがある場合は、こうすれば全部を一気に開くことがで
きます。 >

	zR

これは全てのフォールドが開いた状態になるまでフォールドを減らし(Reduces)続け
ます。この逆に全部を閉じるのはこのコマンドです。 >

	zM

これは次々(More&More)とフォールドします。

|zn|コマンドを使うとフォールドを禁止できます。|zN|を使えば、それは解除され、
元のフォールドした状態に戻ります。|zi|はフォールドの禁止をon/offします。こ
れは作業中に便利に使えます。
  - フォールドを作ってファイル全体を見通しやすくします。
  - 編集作業を行いたい場所を探してカーソルを動かします。
  - |zi|でフォールドを解除して編集作業を行います。
  - その場所の作業が終ると、もう一度|zi|を使って次の編集場所を探します。

手作業でのフォールドの詳しい説明はリファレンスマニュアル|fold-manual|をご覧
ください。

==============================================================================
*28.3*	フォールドで作業する

一部のフォールドを閉じている時に"j"や"k"のようなカーソル移動コマンドでフォー
ルドの上を通ると、１行の空行のように扱われます。つまりフォールドした状態の文
章は簡単に動かすことができるのです。

フォールドをヤンクするのも削除するのもプットするのも、普通の行のように扱えま
す。例えば、プログラム中の関数の順序を変えたりする時にはとても便利です。最初
に'foldmethod'を正しく設定して、各フォールドが関数全体(か少ない目に)を含んで
いることを確認します。次にその関数を"dd"コマンドで削除し、カーソルを動かして
"p"でプットします。関数の一部の行がフォールドの上下にはみ出している時は次の
ようにビジュアル選択を使うこともできます。
  - カーソルを移動したい関数の最初の行に動かします。
  - "V"を押してビジュアルモードに移ります。
  - カーソルを移動する関数の最後に動かします。
  - "d"を押して選択した範囲の行を削除します。
  - カーソルを新たな場所に移動し、"p"を使って上で削除した行をプットします。

どこにフォールドがあるのか、つまり|zo|コマンドが使える場所がどこかを探したり
覚えたりするのが難しい時もあります。定義済のフォールドを見るのは次のコマンド
です。 >

	:set foldcolumn=4

これはフォールドが解りやすいようにウィンドウの左側に小さなカラムを表示しま
す。畳んだ状態のフォールドには"+"と表示されます。開いた状態のフォールドでは
先頭行に"-"が、それに続く行には"|"が表示されます。

マウスでフォールド表示位置にある"+"をクリックすると、そのフォールドが開きま
す。"-"や"|"の上でクリックすると、そこに開いていたフォールドは閉じます。

数字はフォールドのレベルを示します。

カーソル位置にある全フォールドを開くのは|zO|
カーソル位置にある全フォールドを閉じるには|zC|
カーソル位置にあるフォールドを削除するのは|zd|
カーソル位置にある全フォールドを削除するのは|zD|

挿入モードの時はカーソル行にあるフォールドは絶対に閉じません。つまり入力した
ものを見ることができるのです。

カーソルをジャンプさせたり、左右に動かした時はフォールドは自動的に開きます。
例えば、"0"コマンドはカーソル位置のフォールドを開きます。(ただし、'foldopen'
がデフォルト値の"hor"になっていた場合)'foldopen'オプションには特定のコマンド
の時にフォールドを開くように変更できます。
フォールドの上にカーソルが来た時に常に開くようにしたければ、こうします。 >

	:set foldopen=all

Warning: この場合、閉じたフォールドの上にカーソルを移動できなくなります。
一時的にだけこの指定を使い、後で元に戻すようにも使えます。 >

	:set foldopen&

フォールドの範囲からカーソルを移動させると自動的にフォールドを閉じることが
できるようにもできます。 >

	:set foldclose=all

これはカーソルを含んでいない全てのフォールドに'foldlevel'を適用します。
この感覚が好みかどうかはご自分で試してください。より多くフォールドしたい場合
は|zm|を、フォールドを少なくしたい場合は|zr|を使いましょう。

なお、フォールドはウィンドウ毎に固有です。ですから同じファイルを２つのウィン
ドウで開き、片方でフォールドを使い、もう片方は使わないということができます。
また、片方はフォールドを閉じておいて、もう片方は開いておくといったことも可能
です。

==============================================================================
*28.4*	フォールドの保存と復元

ファイルの変更を捨て（て、他のファイルを編集しようとす）る時、フォールドの情
報はなくなります。後でそのファイルを編集しようとしても、手動で設定したフォー
ルドの開閉状態はデフォルトに戻ります。また手動で作成したフォールドについては
全てなくなります！フォールドを保存するには|:mkview|コマンドを使います。 >

	:mkview

これはファイルの見かけに影響のある設定その他を保存するコマンドです。保存の対
象となる項目は'viewoptions'オプションで変更できます。後でそのファイルに戻っ
てきた時にはこのコマンドで復元できます。 >

	:loadview

１つのファイルについて10種類のビューを持つことができます。例えば今の設定を３
つ目のビューにして保存し、それを２つ目のビューとしてロードできます。 >

	:mkview 3
	:loadview 2

行を挿入したり削除したりすると、ビューが無効になる場合がありますので気を付け
てください。また'viewdir'オプションにはビューを保存する時の場所を指定できま
すので、そちらも確認してください。いつ古くなったビューを削除したくなるかわか
りませんからね。

==============================================================================
*28.5*	段付けを使ったフォールド

|zf|でフォールドを一つづつ定義するのは大変ですよね。もしフォールドを付けたい
文章が階層的に段付けしてあれば、その段付けを頼りにしてフォールドを設定させる
方法があります。この方法だと同じレベルの段付けをしてある行をまとめてフォール
ドを作成します。より深い段付けの部分は多重化したフォールドになります。このや
り方は、多くのプログラム言語に対応しています。

'foldmethod'オプションをこう設定してトライしてください。 >

	:set foldmethod=indent

さて、ここで|zm|や|zr|コマンドを使うとフォールドを開いたり閉じたり簡単にでき
ます。これなら次の例のような文章を見るのも簡単です。

この行は段付けしていません。
	この行は１回段付けしています。
		この行は２回段付けしています。
		この行は２回段付けしています。
	この行は１回段付けしています。
この行は段付けしていません。
	この行は１回段付けしています。
	この行は１回段付けしています。

段付けの量とフォールドの深さの関係は'shiftwidth'オプションの値に依存するとい
うことを覚えておいてください。'shiftwidth'の値の分だけ段付けが深なるとフォー
ルドの深さが１つ増えます。このことをフォールドレベルと呼びます。

|zr|や|zm|コマンドを使うと、内部的には'foldlevel'の値を増やしたり減らしたり
しています。これを直接設定することもできます。 >

	:set foldlevel=3

これは'shiftwidth'の段付けが３回分より深いフォールドを全て閉じるという意味で
す。フォールドレベルが小さくなると、より多くのフォールドを閉じます。
'foldlevel'が０であれば、全てのフォールドは閉じます。|zM|は'foldlevel'を０に
設定するコマンドです。逆に|zR|は'foldlevel'をファイル中で最も深いレベルの値
に設定するコマンドです。

つまり、フォールドを開いたり閉じたりするには２つの方法があるわけです。
(A) フォールドレベルを設定する方法
    これを使うと、文章の構造を"ズームアウト"した上でカーソルを動かし、再度
    "ズームイン"することが可能です。

(B) |zo|や|zc|コマンドを使って個々のフォールドを開閉する方法
    これの場合は自分で開きたいフォールドだけを開き、それ以外は閉じたままにし
    ておくことができます。

この両方は組み合せて使えます。最初に|zm|を数度使ってほとんどのフォールドを閉
じ、次に|zo|で開きたいフォールドだけを開きます。もしくは|zR|で全部のフォール
ドを開いておいて、|zc|で一部のフォールドだけを閉じることもできます。

ただし、'foldmethod'が"indent"に設定されていると手動ではフォールドの定義がで
きません。これは段付けとフォールドレベルの関係を崩す可能性があるためです。

段付けを使ったフォールドの詳しい説明はリファレンスマニュアルの|fold-indent|
をご覧ください。

==============================================================================
*28.6*	マーカを使ったフォールド

文章中のマーカはフォールド範囲の始点と終点を指定するのに用います。これだとど
の行をフォールドに含むのかを正確に制御できます。逆に欠点は文章に変更を加える
必要があるという点です。

これを実行します。 >

	:set foldmethod=marker

以下はＣのプログラムっぽい例題です。

	/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */

フォールドした行にはマーカの前に書いてある文字列が表示されている点に気が付か
れたと思います。これだとフォールドしている内容がわかるのでとても便利です。

逆に行を移動させた後でマーカのペアが正しく呼応しなくなるととてもうっとおしく
なります。

	/* global variables {{{1 */
	int varA, varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */

それぞれ番号付きのマーカは指定のレベルでフォールドとなります。これは高いレベ
ルにあるフォールドをそこで停止します。フォールドの定義用として番号付きのマー
カはどこでも生成できます。他のフォールドの前で明示的にフォールドを止めたい場
合には必ず終了マーカが必要となります。

マーカを使ったフォールドについての詳細はリファレンスマニュアル|fold-marker|
をご覧ください。

==============================================================================
*28.7*	シンタックスを使ったフォールド

vimではプログラム言語毎に個別のシンタックスファイルを用意しています。この
ファイルには各項目を何色で表示するかを定義しています。例えばこの文章をカラー
端末を使ってvimで見ると、"help"シンタックス用の指定色で表示されます。
シンタックスファイルでは各項目に"fold"というパラメタを追加することができま
す。これにはシンタックスファイルを書いた上でその指定を追加しておかなければな
りません。決して簡単なことではありません。ですが一度それをやれば、完全に自動
的にフォールドを行ってくれます。
ここでは既存のシンタックスファイルを使うことを前提にしていますので、これ以上
のことは説明しません。これまでに述べた方法でフォールドの開閉ができます。
この時のフォールドはファイルの編集を始める時に自動的に生成／削除されます。

シンタックスを使ったフォールドについての詳細はリファレンスマニュアルの
|fold-syntax|をご覧ください。

==============================================================================
*28.8*	式を使ったフォールド

これは段付けによるフォールドと同じような方法ですが、各行の段付けによって
フォールドレベルを求めるのではなく、フォールドレベルを計算するユーザ定義関数
によって求めます。どの行が同じレベルに属するかを示すマーカのようなものを文章
中に埋め込んでおいて使います。Ｅメールを例にあげましょう。メールでは引用部分
の行頭に">"を付けます。引用部分をフォールドするにはこのようにします。 >

	:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))

これを実行すると次の文章はどうなるでしょう。

> 彼から来た返信(引用)
> 彼から来た返信(引用)
> > 私が書いた元の文章(二重引用)
> > 私が書いた元の文章(二重引用)
> 彼から来た返信(引用)

上の例の'foldexpr'中の関数は次の意味です。(逆順です)
   getline(v:lnum)			現在行を取得
   substitute(...,'\\s','','g')		行から空白類を削除
   substitute(...,'[^>].*','',''))	先頭の'>'以降を全て削除
   strlen(...)				文字列中で見つけた'>'の数をカウント

":set"コマンドでは、全ての空白記号、ダブルクオート、バックスラッシュの前に
バックスラッシュが必要となります。注意してください。
よくわからなくなってきたら、このコマンドで実際に設定されている内容をチェック
してください。 >

	:set foldexpr

複雑な式を修正する時にはコマンド行補完を使いましょう。 >

	:set foldexpr=<Tab>
<
<Tab>の場所で実際にTAB記号を押します。vimは現在値を補いますから、それを自由
に編集できます。

複雑な式を使いたい時は'foldexpr'にあなたが定義した関数を設定してください。

式を使ったフォールドの詳細についてはリファレンスマニュアルの|fold-expr|をご
覧ください。

==============================================================================
*28.9*	変更していな行をフォールドする

同じウィンドウで'diff'オプションを設定するのは便利です。|vimdiff|コマンドは
これと同じことを行っています。例をあげしょう。 >

	setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1

これを同じファイルの異ったバージョンを表示している各ウィンドウで実行します。
こうすると変更されていない行はフォールドされますので、両ファイルの差異がはっ
きりと解ります。

詳しくは|fold-diff|をご覧ください。

==============================================================================
*28.10* どのフォールド方法を使えばいいの？

さてフォールドには述べてきたようないろいろな方法があるため、どの方法を使うの
が良いかわかりづらい場合があります。残念ながら、鉄則というのはないのですが、
いくつか指針となりそうな点について述べます。

編集したい言語用にフォールドをサポートしたシンタックスファイルがあるのなら、
おそらくそれを使うのがベストです。そういったファイルがなければ、それを書くの
もいいですが、これにはパターン検索のことをかなり知っている必要があります。
これは簡単ではありませんが、一度作ってしまえば、手動でフォールドを定義しなく
てもよくなります。

手動でフォールドの範囲を指定する方法は構造を持たない文章に対しても使えます。
その場合はフォールドの保存／復元に|:mkview|コマンドを使いましょう。

マーカを使う方法ではファイルを変更する必要があります。他の人とファイルを共有
する場合や社内のコーディング基準に合わせる必要がある時には、この方法は使えな
いかもしれません。
マーカを使った場合の最大の利点は、自分で明確にフォールドする場所を決められる
点です。このためフォールドをカット＆ペーストした時に漏れを発生することを避け
られます。またフォールド行に表示するコメントの追加も可能です。

段付けを使ったフォールドはたいていのファイルで使えます。ですがいつもうまくい
くとは限りません。ですから他の方法ではできない場合に使うのが良いでしょう。
とはいえ、アウトラインプロセッサとして使うのであれば、とても便利です。その場
合は'shiftwidth'の１レベル＝フォールドレベルとなるように指定しましょう。

式によるフォールドはほとんどどんな構造のテキストでもフォールドできます。指定
方法も、フォールドの開始・終了を簡担に識別できる時には特に簡単です。
ただし、フォールドを「式」方式で定義した場合でも、その方法が明確に定義できな
い部分については、「手動」方式に切り換えることができます。これを行っても既に
定義済のフォールドには影響ありません。ですから削除も追加も手動で行うことがで
きます。

==============================================================================

Next chapter: |usr_29.txt|  プログラム内の移動

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
