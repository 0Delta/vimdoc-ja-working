COMMENT: プログラマー支援機能(コンパイル、インデント、タブ、整形)
STATUS: finished 7.1
TRANSLATOR: 清水俊彦(しみず) <mailto:t_smz@syd.odn.ne.jp>
TRANSLATOR: nakadaira <hopper2@nanameue.jp>

*usr_30.txt*	For Vim version 7.1.  Last change: 2007 Apr 22

		     VIM USER MANUAL - by Bram Moolenaar

			       プログラムの編集


vimにはコンピュータプログラムを書くのを助けるためのコマンドをいろいろと用意
しています。プログラムをコンパイルしたり、そこで出たエラー行に直接ジャンプ
したりできます。また多くの言語で自動的な段付けの設定ができますし、コメント
の整形も簡単です。

|30.1|	コンパイル
|30.2|	Ｃのファイルの段付け(インデント)
|30.3|	自動段付け(インデント)
|30.4|	その他の段付け(インデント)
|30.5|	タブと空白
|30.6|	コメントの整形

     Next chapter: |usr_31.txt|  ＧＵＩの活用
 Previous chapter: |usr_29.txt|  プログラム中を動く
Table of contents: |usr_toc.txt|

==============================================================================
*30.1*	コンパイル

vimには"quickfix"と呼ばれるコマンド群があります。これはvimの中からコンパイル
をし、発生したエラー位置にジャンプして(直せるなら)修正するということを可能に
します。そして、コンパイルをしては新たなエラーを修正し、というのを最
終的にエラーが出なくなるまで繰り返します。

次のコマンドは"make"（入力したパラメタもそのまま渡します）プログラムを実行し
て、結果を取り込みます。 >

	:make {arguments}

エラーが発生した時は、それを取り込み、最初にエラーが発生した場所にカーソルを
移動します。
次に":make"を実行した時の例を掲げます。(通常は:makeではもっと大量の意味のあ
るエラーを吐いてくれます）":make"を入力すると、このような表示が画面に出てき
ます。

	:!make | &tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~

	2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Hit ENTER or type command to continue ~

これを見ると、"main.c"でエラーが発生しているのがわかります。ここで<Enter>を
押すと、vimは"main.c"を表示した上でカーソルを最初のエラー位置の６行目に移動
します。vimはエラーメッセージを見て、どこにジャンプすべきかを認識しますから
利用者側でファイル名や行番号を指定する必要はありません。

		+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
      cursor -> |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+

次のコマンドで次のエラーの発生個所まで移動します。 >

	:cnext

vimは10行目にジャンプします。これは最後の行です。ここに余分な"}"があります。
メッセージが全部表示できなければ、vimはエラーメッセージを短かく省略します。
全体メッセージを見るにはこうします。 >

	:cc

また":clist"コマンドを使うと全エラーメッセージの概略を見ることができます。
その出力は次のようになります。 >

	:clist
<	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~

ここで表示されるのはvimがファイル名と行番号を認識できた行だけです。vimにとっ
てはここに表示した行だけが意味のあるもので、残りはただの文字の羅列に過ぎない
のです。とはいっても、認識できなかった行に必要なことを含んでいる場合もありま
す。例えばリンカが出す未定義の関数に関する情報などです。こういったものも含め
て出力するにはコマンドに"!"を付けます。 >

	:clist!
<	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~

vimは現在のエラー行をハイライトで表示します。１つ前のエラーに戻るにはこうしま
す。
>
	:cprevious

他にも次のようなエラーリストを用いた移動コマンドがあります。

	:cfirst		最初のエラー
	:clast		最後のエラー
	:cc 3		３つ目のエラー


他のコンパイラの使用
--------------------

":make"コマンドを実行した時に動くプログラムの名称は'makeprg'オプションで定義
します。通常は"make"に設定してありますが、例えば Visual C++ のユーザなら、次
のコマンドを実行してこれを"nmake"に設定すべきでしょう。 >

	:set makeprg=nmake

また、このオプションにはパラメタを含むこともできます。特殊文字はバックスラッ
シュでエスケープしてください。例を示します。 >

	:set makeprg=nmake\ -f\ project.mak

また、コマンド指定には特別なvimキーワードが使えます。例えば、"%"文字は現在編
集中のファイル名に置き換わります。次のようなコマンドを実行したとします。 >

	:set makeprg=make\ %

main.cを編集している時であれば、":make"は次のようなコマンドを実行することに
なります。 >

	make main.c

このままではあまり便利とはいえません。では、":r"修飾子(modifier)を使って少し
コマンドを改良しましょう。 >

	:set makeprg=make\ %:r.o

これで、":make"を行うと次のコマンドを実行することになります。 >

	make main.o

こういった修飾子についての詳細は|filename-modifiers|をご覧ください。


古いエラーリスト
----------------

":make"でプログラムを作ったとします。あるファイルで警告メッセージが出、また
別のファイルでエラーが出たとします。修正したエラーが本当に直っているかを調べ
るために、再度":make"を実行します。次に警告メッセージを見たくなります。です
が直前のエラーリストには表示されていません。なぜなら警告が出ているだけのファ
イルは再コンパイルしないからです。この場合、このコマンドで前回のエラーリスト
に戻ることができます。 >

	:colder

ここで":clist"と":cc {nr}"を使って警告が発生した場所にジャンプします。
エラーリストを新しいものに切り換えるのはこうします。 >

	:cnewer

vimは10個のエラーリストを覚えています。


コンパイラの変更
----------------

使っているコンパイラが出すエラーメッセージのフォーマットをvimに教えなければ
なりません。これは'errorformat'オプションで指定します。このオプションの記述
方法はとても複雑ですが、ほとんどどんなコンパイラにも合せることができるもので
す。詳しい内容については|errorformat|をご覧ください。

様々なコンパイラを使っている場合'makeprg'オプションや'errorformat'オプション
を毎回設定していては大変です。vimではそのために簡便な方法を用意しています。
例えば、Microsoft Visual C++ を使うように変更するのであればこのようにします。
>
	:compiler msvc

このコマンドは"msvc"というコンパイラ用のvimスクリプトを読み込み、適切なオプ
ション設定をしてくれます。
自力でコンパイラ用スクリプトを作ることもできます。|write-compiler-plugin|を
ご覧ください。


出力のリダイレクト
------------------

":make"コマンドによって実行したプログラムの出力はエラーファイルにリダイレク
トされます。これがどのように動くかは'shell'オプションなどいろいろな要因に左
右されます。":make"コマンドでうまくプログラムの出力を拾えない場合は'makeef'
オプションと'shellpipe'オプションを調べてください。また'shellquote'オプショ
ンと'shellxquote'オプションも調べた方が良いかもしれません。

":make"でエラーファイルをリダイレクトしてくれない場合は、他のウィンドウ(vim
の分割ウィンドウではなく別セッションのシェルなどのウィンドウ）でプログラムを
コンパイルして、その出力をファイルに落としておく方法もあります。そして、この
ようにファイルを読み込ませるのです。 >

	:cfile {filename}

この場合も":make"の場合と同様にエラー行にジャンプしたりできます。

==============================================================================
*30.2*	Ｃのファイルの段付け(インデント)

行をきちんと段付けしてあるプログラムというのはとても読み易いものです。vimで
は段付けのサポート機能をいろいろと用意しています。
Ｃのプログラムであれば'cindent'オプションをonに設定します。vimはＣプログラム
のことをいろいろ解っていますので、自動的に段付けを行うという難業に挑みます。
１レベル分の段付けでの文字数の指定は'shiftwidth'オプションで行います。４桁に
しておけば問題ないでしょう。１回の":set"コマンドで両方を設定できます。 >

	:set cindent shiftwidth=4

このオプションをonに設定しておくと例えば、"if (x)"と入力した次の行では自動的
に１レベル分段付けされます。

				    if (flag)
	Automatic indent   --->		do_the_work();
	Automatic unindent <--	    if (other_flag) {
	Automatic indent   --->		do_file();
	keep indent			do_some_more();
	Automatic unindent <--	    }

また、波カッコ({ })をどこかで入力すると、"{"の時はその次の行を段付けし、"}"
の時は１レベル段付けを解除します。あなたが今から入力しようとしている文字を
vimは予測できませんので、"}"の入力があると直後に段付けの解除を行います。

自動段付けによる効用として、コードに潜むバグを早いうちにつぶす役に立つという
点があります。関数の最後で"}"を入力した時に、自動段付けで思っていたよりも多
い段付けになっていれば、それだけで"}"を忘れているだろうというのがわかります。
"%"コマンドを使って、入力した"}"と呼応している"{"を探しましょう。
同じように")"や";"を忘れた場合も余分な段付けが残ります。つまり、思っていたよ
りも行頭の空白が多ければ、それより上を調べるようにしましょう。

フォーマットの汚ないコードや、挿入削除を繰り返したコードでは、行の段付けをや
り直す必要があります。"="オペレータでこれができます。一番単純なやり方はこう
です。 >

	==

これは現在行の段付けを行います。他のオペレータと同様に３つの範囲指定の方法が
あります。ビジュアルモードでは"="で選択行を段付けします。また便利な"a{"とい
う現在の{ }で囲まれたブロックを選択できる便利なテキストオブジェクトがありま
す。これを使うとカーソルのある場所のコードブロックを段付けします。 >

	=a{

また、コード全体の段付けがまずいのなら、ファイル全体を最初から段付けさせるこ
ともできます。 >
>
	gg=G

ただ、手動で丁寧に段付けしてあるファイルに対してこれを実行しないでください。
自動段付けはおおむね良い仕事をしますが、場合によってはそのルールに従わない書
き方をしたい場合もあることでしょう。


段付けのスタイル設定
------------------------

段付けのスタイルは人によって様々です。デフォルトでもvimはプログラマーの90%が
やっているような方法で段付けをかなりうまくこなします。それでも違ったスタイル
というのは存在します。もし必要なら'cinoptions'オプションを使って段付けのスタ
イルをカスタマイズできます。
デフォルトでは'cinoptions'は空です。その場合vimはデフォルトのスタイルで段付
けします。デフォルトから変えたい点についていろいろな設定を追加できます。例え
ば、波カッコをこのようにレイアウトしたいとしましょう。

	if (flag) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~

これにはこのコマンドを使います。 >

	:set cinoptions+={2

他にも多くの設定ができます。|cinoptions-values|をご覧ください。

==============================================================================
*30.3*	自動段付け

Ｃのファイルを編集する都度、手で'cindent'オプションをonにするのはとても面倒
です。このコマンドはこれを自動的に行ってくれます。 >

	:filetype indent on

実は、これはＣのファイルの時に'cindent'をonにするだけでなく、ずっといろんな
ことを行います。その第一はファイルタイプの認識を可能にする点です。これはシン
タックスハイライトに使っているのと同じ仕掛けです。
既知のファイルタイプであれば、vimはこのタイプのファイルを処理できる段付け情
報ファイルを探します。vimの配布物には様々なプログラム言語用のものを多数含ん
でいます。この段付け情報ファイルは編集しようとしているファイル用に自動段付け
を行うように準備します。

自動段付け処理が好みでなければ、こうしてoffに戻すこともできます。 >

	:filetype indent off

ある特定タイプのファイルの時に段付けをしたくなければ、こうすれば実現できま
す。これを行う１行だけのファイルを作りましょう。 >

	:let b:did_indent = 1

次にこれをその特定の名前で保存する必要があります。

	{directory}/indent/{filetype}.vim

上の{filetype}は、"cpp"とか"java"といったファイルタイプ名です。実際にvimは検
出する名称はこのコマンドで見ることができます。 >

	:set filetype

このファイルの場合なら出力は次のようになります。

	filetype=help ~

ですから、{filetype}には"help"を使うわけです。
{directory}部分にはランタイムディレクトリを指定します。このコマンドの出力結
果を見てください。 >

	set runtimepath

出力されたうち、先頭から最初のカンマの前までを使います。つまり、上のコマンド
の実行結果がこうだったとしましょう。

	runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~

この場合なら{directory}には"~/.vim"を使います。結局ファイル名は次のようにな
ります。

	~/.vim/indent/help.vim ~

段付けをoffにするのではなく、独自の段付けファイルを書くこともできます。この
方法は|indent-expression|で説明しています。

==============================================================================
*30.4*	その他の段付け

自動段付けで一番シンプルなのは'autoindent'オプションを使うことです。これは直
前の行と同じ段付けを行います。それよりほんの少し賢いのは'smartindent'オプ
ションです。これは段付けファイルが提供されていない言語では便利に使えるでしょ
う。'smartindent'は'cindent'ほどではありませんが、'autoindent'よりは賢いで
す。
'smartindent'をonにすると、"{"毎に段付けレベルが１つづつ深くなり、"}"毎にレ
ベルが浅くなります。また、'cinwords'オプションで定義してある単語のどれかが現
れる毎に段付けレベルが深くなります。行頭が"#"の行は特別扱いで、段付けは省か
れます。これはプリプロセッサのディレクティブが常に１桁目であるためです。その
次の行では段付けは元に戻ります。


段付けの訂正
------------

直前の行と同じ段付けをするために'autoindent'や'smartindent'を使っていると、
その行の段付けを'shiftwidth'分だけ変更したいことが頻繁に起こります。これを素
早くやるには挿入モードでCTRL-DとCTRL-Tを使いましょう。
例えば、シェルスクリプトを編集中にこのように入力したいとしましょう。

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~

まずオプション設定を次のようにします。 >

	:set autoindent shiftwidth=3

次に最初の行から入力を始めます。行末で<Enter>を押して２行目に移ります。

	if test -n a; then ~
	echo ~

ここで段付けが一つ必要です。CTRL-Tを押します。するとこうなります。

	if test -n a; then ~
	   echo ~

挿入モードでCTRL-Tコマンドを使うと、１つ分の'shiftwidth'の段付けを追加しま
す。行のどの場所にカーソルがあるかは関係ありません。
２行目の入力を続けます。<Enter>を押して３行目にかかります。ここでは段付けに
問題ありません。<Enter>を押して最後の行となります。この時点でこのように見え
ているでしょう。

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~

余分な段付けを削るには最後の行でCTRL-Dを押します。これは段付け情報を１レベル
分'shiftwidth'を削除します。行のどこにカーソルがあっても構いません。
通常モードの時は"<<"と">>"コマンドを使うと行が左右にシフトします。"<"と">"は
オペレータですので、いつもの３種類の方法で段付けの行範囲を指定できます。次の
ような組み合せは便利です。 >

	>i{

これはカーソルのあるブロック全体、{ }の中を１レベル段付けします。"{"と"}"の
行自体は段付けされませんが、">a{"コマンドなら段付けします。下の例ではカーソ
ルが"printf"にあるとします。

	original text		after ">i{"		after ">a{"

	if (flag)		if (flag)		if (flag) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	flag = 0;		    flag = 0;		    flag = 0;  ~
	}			}			    } ~

==============================================================================
*30.5*	タブ文字と空白文字

'tabstop'はデフォルトでは８になっています。変更はできますが、後でトラブルの
元になりやすいのです。他のプログラムからは、あなたが設定しているタブ桁数を知
りようがありません。おそらくはデフォルトの８桁となるため、作ったテキストが
突然違ったもののように見えることでしょう。また、ほとんどのプリンタはタブ桁数
が８桁固定です。つまり'tabstop'はそのままにしておくのが良いのです。(違ったタ
ブ桁数で書かれたファイルを修正する方法については|25.3|をご覧ください。)
プログラム内で段付けをするために１レベルを８桁づつにするとすぐにウィンドウの
右端に到達してしまいます。でも１レベルが１桁だと見た目の違いがわかりづらくな
ります。ですので１レベルを４桁にしている人が多いですが、これは手頃な妥協点だ
と思います。
<Tab>は８桁分ですが、実際に段付けしたいのが４桁だとすると、段付けには<Tab>は
使えないということになります。この対処には２つの方法があります。

1.  <Tab>と空白を混在して使う。<Tab>だと８桁分の空白となるため、ファイル中の
    無駄な文字数を削減できます。空白文字を８回打つより<Tab>の方が速く入力で
    きますし、文字削除する時も速いです。

2.  空白文字だけを使う。これならタブ桁数が違うプログラムを使う時のトラブルを
    避けることができます。

vimはどちらの方法でもバッチリ使えます。


空白とタブ
----------

If you are using a combination of tabs and spaces, you just edit normally.
タブと空白の組み合せを使っている場合は普通に編集します。vimはデフォルトで実
にうまくこれを処理してくれます。
'softtabstop'オプションを設定しておくと少しだけ作業を楽にしてくれます。この
オプションを設定すると、Tabキーがまるで'softtabstop'で設定した値であるかのよ
うにvimは振る舞いますが、実際にはタブと空白を組み合せてそう見せかけているの
です。
以下のコマンドを実行した後は、<Tab>を押す都度カーソルが４桁づつ動きます。
>
	:set softtabstop=4

最初の桁で<Tab>を押すと、文章には４つの空白を挿入します。もう一度押すと、
先ほどの４つの空白を取り除いて、<Tab>を１つ挿入します。(結局８桁になります)
つまり、vimは<Tab>を使えるだけ使い、残りは空白で埋めるのです。
文字削除の時はまた違った動きとなります。<BS>を押すと'softtabstop'で指定して
いる桁数だけ削除します。この場合も<Tab>を使えるだけ使い、すき間を空白で埋め
るわけです。
以下の図は<Tab>を数回押してから<BS>を使った時に何が起こるかを示しています。
図中の"------->"は<Tab>記号、"."は空白記号を示します。。

	type			  result ~
	<Tab>			  ....
	<Tab><Tab>		  ------->
	<Tab><Tab><Tab>		  ------->....
	<Tab><Tab><Tab><BS>	  ------->
	<Tab><Tab><Tab><BS><BS>   ....

似たオプションで'smarttab'オプションというのがあります。これをonにしておくと
行の段付けする部分で<Tab>を押すと'shiftwidth'分の段付けを行いますが、行の最
初の非空白文字より右側では本当に<Tab>記号となります。ただし、<BS>キーについ
ては'softtabstop'の場合のようになりません。


空白文字
--------

ファイル中にTAB記号が全くないようにしたければ、'expandtab'オプションをonにし
ます。 >

	:set expandtab

このオプションをonにすると、<Tab>キーは一連の空白文字に置き換わります。
つまり<Tab>文字と同じ量の空白文字が挿入されます。しかし、ファイル中に<Tab>文
字が入ることはありません。
<BS>で削除する時は１文字ずつとなります。ですから、<Tab>を１度押した後でそれ
を取り消すには<BS>キーを８回押さなければなりません。段付けしている場所であれ
ば、CTRL-Dを押せばとても早く入力できます。


タブを空白に(または空白をタブに)変更
------------------------------------

'expandtab'をonにしても既存のタブには何も影響ありません。つまり、文章中のタ
ブはタブのままです。既存のタブを空白に変換したければ、":retab"コマンドを使い
ます。このようにします。 >

	:set expandtab
	:%retab

これでタブの代わりに空白記号を使って全ての段付けを変更します。ですが、行頭の
最初の非空白文字以降のタブはそのままです。それも含めて全てを空白文字に変換す
るには、コマンド名に"!"を追加します。 >

	:%retab!

これは少しばかり危険を伴います。というのは文字列中のタブも変更されてしまうた
めです。まずこのコマンドでそういったパターンがないか確認してください。 >

	/"[^"\t]*\t[^"]*"

ですが、文字列の中には実際のTabコードを埋め込まないこをとお勧めします。こう
いったトラブルを避けるためにも"\t"などに変更した方が良いでしょう。

このようにしても全く同じことになります。 >

	:set noexpandtab
	:%retab!

==============================================================================
*30.6*	コメントの整形

vimがすごい点のひとつにコメントを理解できるというのがあります。vimにコメント
の整形を頼めば、ちゃんとそれをしてくれます。
例えば、次のようなコメントがあるとします。

	/* ~
	 * This is a test ~
	 * of the text formatting. ~
	 */ ~

ここでカーソルをコメントの開始位置に置いて、次のように入力してvimにコメント
整形を依頼します。 >

	gq]/

"gq"はテキストの整形を行うためのオペレータです。"]/"はコメントの末尾に移動す
るモーション(カーソル移動)コマンドです。結果はこのようになります。

	/* ~
	 * This is a test of the text formatting. ~
	 */ ~

vimが各行の先頭を正しく処理している点に注目してください。
整形対象となる文章を選択するにはビジュアルモードを使って"gq"を入力する方法も
あります。

コメントに新しい行を追加するには、カーソルを行の途中に移動して"o"を押します。
その結果、次のようになります。

	/* ~
	 * This is a test of the text formatting. ~
	 * ~
	 */ ~

vimは自動的に"*"と空白を挿入しますので、すぐにコメントを入力することができま
す。長さが、'textwidth'を超えると、vimは行を分割します。その時も"*"と空白を
自動的に補います。

	/* ~
	 * This is a test of the text formatting. ~
	 * Typing a lot of text here will make Vim ~
	 * break ~
	 */ ~

この機能を使うには'formatpiotions'でいくつか指定しなければならないフラグがあ
ります。

	r	挿入モードで<Enter>を押した時に"*"を挿入する。
	o	通常モードで"o"か"O"を使った時に"*"を挿入する。
	c	コメントについても'textwidth'の桁数で改行する

これ以外のフラグについては|fo-table|をご覧ください。


コメントの定義

コメントがどのような形かは'comment'オプションで定義できます。vimは１行コメン
トと、開始記号、終端記号、本文が違っているコメントとを違うものとして扱います。
１行コメントの多くは特殊文字で始まります。Ｃ＋＋では"//"ですし、Makefileでは
"#"です。vimスクリプトなら'"'(ダブルクオート１つ)です。例えば、vimでＣ＋＋形
式のコメントを使うにはこうします。 >

	:set comments=://

コロン(:)はフラブ部とコメント文字列部の識別に使っています。'comment'オプショ
ンはこういう構造となります。

	{flags}:{text}

{frags}部はこの例のように空っぽでも構いません。

複数の項目をカンマ(,)を使って繋ぐこともできます。これを使うと同時にタイプの
違うコメントを認識させることができます。例えば、Ｅメールを編集してみましょう。
返事を書く時には、他の人の書いた部分の行頭には">"か"!"を補ってあるとします。
次のコマンドはそういった動きになります。 >

	:set comments=n:>,n:!

上では">"で始まるコメントと"!"で始まるコメントの２種類があります。どちらも
"n"フラグを指定しています。これはコメントがネスト(多重化)できることを示して
います。これでメッセージを次のようにフォーマットすることを認めます。

	> ! Did you see that site? ~
	> ! It looks really great. ~
	> I don't like it.  The ~
	> colors are terrible. ~
	What is the URL of that ~
	site? ~

'textwidth'を違った値(例えば80)にし、ビジュアル選択で引用部分を選択して"gq"
と入力します。結果はこうなります。

	> ! Did you see that site? It looks really great. ~
	> I don't like it.  The colors are terrible. ~
	What is the URL of that site? ~

あるコメントからもう１つのタイプのコメントに文章が動いていない点にお気付きで
しょう。２行目の"I"は１行目の末尾に入れることもできます。でも１行目は行頭が
"> !"で始まっていて、２行目は">"です。vimはこの２つが違った意味のコメントだ
と区別するのです。


３部構成のコメント
------------------


"/*"で始まって、途中は"*"で、最後が"*/"となるようなコメントもあります。この
場合の'comments'の内容は次のようになります。 >

	:set comments=s1:/*,mb:*,ex:*/

最初の部分は"s1:/*"です。"s"というのはこれが３部構成のコメントであることを示
しています。":"はフラグとコメントとして認識される文字列("/*")のセパレータで
す。この他に"1"というフラグがあります。これは２つ目の項目にオフセットとして１
つの空白があることを示します。
２つ目の項目は"mb:*"です。"m"というのはこれが２つ目の項目であることを示して
います。"b"フラグは文字列の後に空白がなければならないことを示します。これが
ないと、"*pointer"で始まっているような行もコメントだと認識してしまいます。
最後の項目は"ex:*/"です。この"e"は終端であることの識別子です。"x"フラグには
特別な意味があります。これはvimが自動的に"*"を挿入した直後に"/"を入力した場
合、間にできる空白文字を削除する意味となります。

詳細は|format-comments|をご覧ください。

==============================================================================

Next chapter: |usr_31.txt|  ＧＵＩの活用

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
