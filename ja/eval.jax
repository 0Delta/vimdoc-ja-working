COMMENT: Vimスクリプト
STATUS: suspended 7.1
TRANSLATOR: 村岡太郎 <koron@tka.att.ne.jp>

*eval.txt*      For Vim version 7.1.  Last change: 2007 May 11


		VIMリファレンスマニュアル    by Bram Moolenaar


Vimスクリプト				*expression* *expr* *E15* *eval*

Vimスクリプトの利用についてはユーザマニュアルの41章|user_41.txt|でも解説されて
いる。

注意:Vimスクリプトはコンパイル時に無効化できる。もしそうなっているとこのドキュ
メントに書かれている事は有効ではない。|+eval|と|no-eval-feature|を参照。

1.  変数		|variables|
    1.1 変数の型
    1.2 関数への参照			|Funcref|
    1.3 リスト				|Lists|
    1.4 辞書				|Dictionaries|
    1.5 変数について補足		|more-variables|
2.  式の文法		|expression-syntax|
3.  内部変数		|internal-variables|
4.  組み込み関数	|functions|
5.  関数定義		|user-functions|
6.  波括弧{}の名前	|curly-braces-names|
7.  コマンド		|expression-commands|
8.  例外処理		|exception-handling|
9.  例			|eval-examples|
10. +eval機能が無効	|no-eval-feature|
11. サンドボックス	|eval-sandbox|
12. テキストロック	|textlock|

{Vi にはこれらのコマンドは存在しない}

==============================================================================
1. 変数							*variables*

1.1 変数の型 ~
							*E712*
変数には5種類の型がある:

数値		32ビット符合有整数
		例: -123 0x10 0177

文字列		終端がNUL文字である8ビットの符号無し文字(バイト)
		例: "ab\txx\"--"  'x-z''a,c'

Funcref		関数への参照 |Funcref|.
		例: function("strlen")

リスト		要素の順序つきの列 |List|.
		例: [1, 2, ['a', 'b']]

辞書		順序を持たない連想配列: 各要素はキーと値を持つ。|Dictionary|
		例: {'blue': "#0000ff", 'red': "#ff0000"}

数値と文字列は文脈に応じて相互に変換される。

数値から文字列への変換は数字のASCII表現によって行なわれる。例: >
	数値 123	-->	文字列 "123"
	数値 0		-->	文字列 "0"
	数値 -1		-->	文字列 "-1"

文字列から数値への変換は最初の数字を用いて数値に変換する。16進表記"0xf9"や8進
表記"017"も認識される。文字列が数字で始まらない場合結果は0となる。例: >
	文字列 "456"	-->	数値 456
	文字列 "6bar"	-->	数値 6
	文字列 "foo"	-->	数値 0
	文字列 "0xf1"	-->	数値 241
	文字列 "0100"	-->	数値 64
	文字列 "-8"	-->	数値 -8
	文字列 "+8"	-->	数値 0

文字列を強制的に数値に変換するには0を足す: >
	:echo "0100" + 0
<	64 ~

先頭の0によって8進数とみなされるのを防いだり、異なる基数を使うには|str2nr()|を
使う。

ブール(真理値)演算には数値が使われる。0は偽を意味し、非0は真を表す。

Note 次のコマンドをみると >
	:if "foo"
"foo"は0に変換され、それは偽を意味する。文字列が空ではないか調べるためには
strlen()を使用して次のようにする。 >
	:if strlen("foo")
<				*E745* *E728* *E703* *E729* *E730* *E731*
List, Dictionary and Funcref types are not automatically converted.

								*E706*
You will get an error if you try to change the type of a variable.  You need
to |:unlet| it first to avoid this error.  String and Number are considered
equivalent though.  Consider this sequence of commands: >
	:let l = "string"
	:let l = 44		" changes type from String to Number
	:let l = [1, 2, 3]	" error!


1.2 Function references ~
					*Funcref* *E695* *E718*
A Funcref variable is obtained with the |function()| function.  It can be used
in an expression in the place of a function name, before the parenthesis
around the arguments, to invoke the function it refers to.  Example: >

	:let Fn = function("MyFunc")
	:echo Fn()
<							*E704* *E705* *E707*
A Funcref variable must start with a capital, "s:", "w:", "t:" or "b:".  You
cannot have both a Funcref variable and a function with the same name.

A special case is defining a function and directly assigning its Funcref to a
Dictionary entry.  Example: >
	:function dict.init() dict
	:   let self.val = 0
	:endfunction

The key of the Dictionary can start with a lower case letter.  The actual
function name is not used here.  Also see |numbered-function|.

A Funcref can also be used with the |:call| command: >
	:call Fn()
	:call dict.init()

The name of the referenced function can be obtained with |string()|. >
	:let func = string(Fn)

You can use |call()| to invoke a Funcref and use a list variable for the
arguments: >
	:let r = call(Fn, mylist)


1.3 Lists ~
							*List* *Lists* *E686*
A List is an ordered sequence of items.  An item can be of any type.  Items
can be accessed by their index number.  Items can be added and removed at any
position in the sequence.


List creation ~
							*E696* *E697*
A List is created with a comma separated list of items in square brackets.
Examples: >
	:let mylist = [1, two, 3, "four"]
	:let emptylist = []

An item can be any expression.  Using a List for an item creates a
List of Lists: >
	:let nestlist = [[11, 12], [21, 22], [31, 32]]

An extra comma after the last item is ignored.


List index ~
							*list-index* *E684*
An item in the List can be accessed by putting the index in square brackets
after the List.  Indexes are zero-based, thus the first item has index zero. >
	:let item = mylist[0]		" get the first item: 1
	:let item = mylist[2]		" get the third item: 3

When the resulting item is a list this can be repeated: >
	:let item = nestlist[0][1]	" get the first list, second item: 12
<
A negative index is counted from the end.  Index -1 refers to the last item in
the List, -2 to the last but one item, etc. >
	:let last = mylist[-1]		" get the last item: "four"

To avoid an error for an invalid index use the |get()| function.  When an item
is not available it returns zero or the default value you specify: >
	:echo get(mylist, idx)
	:echo get(mylist, idx, "NONE")


List concatenation ~

Two lists can be concatenated with the "+" operator: >
	:let longlist = mylist + [5, 6]
	:let mylist += [7, 8]

To prepend or append an item turn the item into a list by putting [] around
it.  To change a list in-place see |list-modification| below.


Sublist ~

A part of the List can be obtained by specifying the first and last index,
separated by a colon in square brackets: >
	:let shortlist = mylist[2:-1]	" get List [3, "four"]

Omitting the first index is similar to zero.  Omitting the last index is
similar to -1. >
	:let endlist = mylist[2:]	" from item 2 to the end: [3, "four"]
	:let shortlist = mylist[2:2]	" List with one item: [3]
	:let otherlist = mylist[:]	" make a copy of the List

If the first index is beyond the last item of the List or the second item is
before the first item, the result is an empty list.  There is no error
message.

If the second index is equal to or greater than the length of the list the
length minus one is used: >
	:let mylist = [0, 1, 2, 3]
	:echo mylist[2:8]		" result: [2, 3]

NOTE: mylist[s:e] means using the variable "s:e" as index.  Watch out for
using a single letter variable before the ":".  Insert a space when needed:
mylist[s : e].


List identity ~
							*list-identity*
When variable "aa" is a list and you assign it to another variable "bb", both
variables refer to the same list.  Thus changing the list "aa" will also
change "bb": >
	:let aa = [1, 2, 3]
	:let bb = aa
	:call add(aa, 4)
	:echo bb
<	[1, 2, 3, 4]

Making a copy of a list is done with the |copy()| function.  Using [:] also
works, as explained above.  This creates a shallow copy of the list: Changing
a list item in the list will also change the item in the copied list: >
	:let aa = [[1, 'a'], 2, 3]
	:let bb = copy(aa)
	:call add(aa, 4)
	:let aa[0][1] = 'aaa'
	:echo aa
<	[[1, aaa], 2, 3, 4] >
	:echo bb
<	[[1, aaa], 2, 3]

To make a completely independent list use |deepcopy()|.  This also makes a
copy of the values in the list, recursively.  Up to a hundred levels deep.

The operator "is" can be used to check if two variables refer to the same
List.  "isnot" does the opposite.  In contrast "==" compares if two lists have
the same value. >
	:let alist = [1, 2, 3]
	:let blist = [1, 2, 3]
	:echo alist is blist
<	0 >
	:echo alist == blist
<	1

Note about comparing lists: Two lists are considered equal if they have the
same length and all items compare equal, as with using "==".  There is one
exception: When comparing a number with a string they are considered
different.  There is no automatic type conversion, as with using "==" on
variables.  Example: >
	echo 4 == "4"
<	1 >
	echo [4] == ["4"]
<	0

Thus comparing Lists is more strict than comparing numbers and strings.  You
can compare simple values this way too by putting them in a string: >

	:let a = 5
	:let b = "5"
	echo a == b
<	1 >
	echo [a] == [b]
<	0


List unpack ~

To unpack the items in a list to individual variables, put the variables in
square brackets, like list items: >
	:let [var1, var2] = mylist

When the number of variables does not match the number of items in the list
this produces an error.  To handle any extra items from the list append ";"
and a variable name: >
	:let [var1, var2; rest] = mylist

This works like: >
	:let var1 = mylist[0]
	:let var2 = mylist[1]
	:let rest = mylist[2:]

Except that there is no error if there are only two items.  "rest" will be an
empty list then.


List modification ~
							*list-modification*
To change a specific item of a list use |:let| this way: >
	:let list[4] = "four"
	:let listlist[0][3] = item

To change part of a list you can specify the first and last item to be
modified.  The value must at least have the number of items in the range: >
	:let list[3:5] = [3, 4, 5]

Adding and removing items from a list is done with functions.  Here are a few
examples: >
	:call insert(list, 'a')		" prepend item 'a'
	:call insert(list, 'a', 3)	" insert item 'a' before list[3]
	:call add(list, "new")		" append String item
	:call add(list, [1, 2])		" append a List as one new item
	:call extend(list, [1, 2])	" extend the list with two more items
	:let i = remove(list, 3)	" remove item 3
	:unlet list[3]			" idem
	:let l = remove(list, 3, -1)	" remove items 3 to last item
	:unlet list[3 : ]		" idem
	:call filter(list, 'v:val !~ "x"')  " remove items with an 'x'

Changing the order of items in a list: >
	:call sort(list)		" sort a list alphabetically
	:call reverse(list)		" reverse the order of items


For loop ~

The |:for| loop executes commands for each item in a list.  A variable is set
to each item in the list in sequence.  Example: >
	:for item in mylist
	:   call Doit(item)
	:endfor

This works like: >
	:let index = 0
	:while index < len(mylist)
	:   let item = mylist[index]
	:   :call Doit(item)
	:   let index = index + 1
	:endwhile

Note that all items in the list should be of the same type, otherwise this
results in error |E706|.  To avoid this |:unlet| the variable at the end of
the loop.

If all you want to do is modify each item in the list then the |map()|
function will be a simpler method than a for loop.

Just like the |:let| command, |:for| also accepts a list of variables.  This
requires the argument to be a list of lists. >
	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]
	:   call Doit(lnum, col)
	:endfor

This works like a |:let| command is done for each list item.  Again, the types
must remain the same to avoid an error.

It is also possible to put remaining items in a List variable: >
	:for [i, j; rest] in listlist
	:   call Doit(i, j)
	:   if !empty(rest)
	:      echo "remainder: " . string(rest)
	:   endif
	:endfor


List functions ~
						*E714*
Functions that are useful with a List: >
	:let r = call(funcname, list)	" call a function with an argument list
	:if empty(list)			" check if list is empty
	:let l = len(list)		" number of items in list
	:let big = max(list)		" maximum value in list
	:let small = min(list)		" minimum value in list
	:let xs = count(list, 'x')	" count nr of times 'x' appears in list
	:let i = index(list, 'x')	" index of first 'x' in list
	:let lines = getline(1, 10)	" get ten text lines from buffer
	:call append('$', lines)	" append text lines in buffer
	:let list = split("a b c")	" create list from items in a string
	:let string = join(list, ', ')	" create string from list items
	:let s = string(list)		" String representation of list
	:call map(list, '">> " . v:val')  " prepend ">> " to each item

Don't forget that a combination of features can make things simple.  For
example, to add up all the numbers in a list: >
	:exe 'let sum = ' . join(nrlist, '+')


1.4 Dictionaries ~
						*Dictionaries* *Dictionary*
A Dictionary is an associative array: Each entry has a key and a value.  The
entry can be located with the key.  The entries are stored without a specific
ordering.


Dictionary creation ~
						*E720* *E721* *E722* *E723*
A Dictionary is created with a comma separated list of entries in curly
braces.  Each entry has a key and a value, separated by a colon.  Each key can
only appear once.  Examples: >
	:let mydict = {1: 'one', 2: 'two', 3: 'three'}
	:let emptydict = {}
<							*E713* *E716* *E717*
A key is always a String.  You can use a Number, it will be converted to a
String automatically.  Thus the String '4' and the number 4 will find the same
entry.  Note that the String '04' and the Number 04 are different, since the
Number will be converted to the String '4'.

A value can be any expression.  Using a Dictionary for a value creates a
nested Dictionary: >
	:let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}

An extra comma after the last entry is ignored.


Accessing entries ~

The normal way to access an entry is by putting the key in square brackets: >
	:let val = mydict["one"]
	:let mydict["four"] = 4

You can add new entries to an existing Dictionary this way, unlike Lists.

For keys that consist entirely of letters, digits and underscore the following
form can be used |expr-entry|: >
	:let val = mydict.one
	:let mydict.four = 4

Since an entry can be any type, also a List and a Dictionary, the indexing and
key lookup can be repeated: >
	:echo dict.key[idx].key


Dictionary to List conversion ~

You may want to loop over the entries in a dictionary.  For this you need to
turn the Dictionary into a List and pass it to |:for|.

Most often you want to loop over the keys, using the |keys()| function: >
	:for key in keys(mydict)
	:   echo key . ': ' . mydict[key]
	:endfor

The List of keys is unsorted.  You may want to sort them first: >
	:for key in sort(keys(mydict))

To loop over the values use the |values()| function:  >
	:for v in values(mydict)
	:   echo "value: " . v
	:endfor

If you want both the key and the value use the |items()| function.  It returns
a List in which each item is a  List with two items, the key and the value: >
	:for [key, value] in items(mydict)
	:   echo key . ': ' . value
	:endfor


Dictionary identity ~
							*dict-identity*
Just like Lists you need to use |copy()| and |deepcopy()| to make a copy of a
Dictionary.  Otherwise, assignment results in referring to the same
Dictionary: >
	:let onedict = {'a': 1, 'b': 2}
	:let adict = onedict
	:let adict['a'] = 11
	:echo onedict['a']
	11

Two Dictionaries compare equal if all the key-value pairs compare equal.  For
more info see |list-identity|.


Dictionary modification ~
							*dict-modification*
To change an already existing entry of a Dictionary, or to add a new entry,
use |:let| this way: >
	:let dict[4] = "four"
	:let dict['one'] = item

Removing an entry from a Dictionary is done with |remove()| or |:unlet|.
Three ways to remove the entry with key "aaa" from dict: >
	:let i = remove(dict, 'aaa')
	:unlet dict.aaa
	:unlet dict['aaa']

Merging a Dictionary with another is done with |extend()|: >
	:call extend(adict, bdict)
This extends adict with all entries from bdict.  Duplicate keys cause entries
in adict to be overwritten.  An optional third argument can change this.
Note that the order of entries in a Dictionary is irrelevant, thus don't
expect ":echo adict" to show the items from bdict after the older entries in
adict.

Weeding out entries from a Dictionary can be done with |filter()|: >
	:call filter(dict, 'v:val =~ "x"')
This removes all entries from "dict" with a value not matching 'x'.


Dictionary function ~
					*Dictionary-function* *self* *E725*
When a function is defined with the "dict" attribute it can be used in a
special way with a dictionary.  Example: >
	:function Mylen() dict
	:   return len(self.data)
	:endfunction
	:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}
	:echo mydict.len()

This is like a method in object oriented programming.  The entry in the
Dictionary is a |Funcref|.  The local variable "self" refers to the dictionary
the function was invoked from.

It is also possible to add a function without the "dict" attribute as a
Funcref to a Dictionary, but the "self" variable is not available then.

				*numbered-function* *anonymous-function*
To avoid the extra name for the function it can be defined and directly
assigned to a Dictionary in this way: >
	:let mydict = {'data': [0, 1, 2, 3]}
	:function mydict.len() dict
	:   return len(self.data)
	:endfunction
	:echo mydict.len()

The function will then get a number and the value of dict.len is a |Funcref|
that references this function.  The function can only be used through a
|Funcref|.  It will automatically be deleted when there is no |Funcref|
remaining that refers to it.

It is not necessary to use the "dict" attribute for a numbered function.


Functions for Dictionaries ~
							*E715*
Functions that can be used with a Dictionary: >
	:if has_key(dict, 'foo')	" TRUE if dict has entry with key "foo"
	:if empty(dict)			" TRUE if dict is empty
	:let l = len(dict)		" number of items in dict
	:let big = max(dict)		" maximum value in dict
	:let small = min(dict)		" minimum value in dict
	:let xs = count(dict, 'x')	" count nr of times 'x' appears in dict
	:let s = string(dict)		" String representation of dict
	:call map(dict, '">> " . v:val')  " prepend ">> " to each item


1.5 変数について補足 ~
							*more-variables*

変数や式の結果の型を知りたいのならば、関数|type()|を使う。

オプション'viminfo'にフラグ'!'が含まれるならば、大文字で始まり小文字を含まない
名前のグローバル変数は、viminfoファイル|viminfo-file|に格納される。

オプション'sessionoptions'が"global"を含むなら、大文字で始まり少なくとも一文字
以上の小文字を含む名前のグローバル変数は、sessionファイル|session-file|に格納
される。

変数名			何処に保存されるか ~
my_var_6		されない
My_Var_6		sessionファイル
MY_VAR_6		viminfoファイル


波括弧を使って変数名を構成できる。詳細は|curly-braces-names|を参照。

==============================================================================
2. 式の文法						*expression-syntax*

式文法一覧、優先順位の低いものから高い順に:

|expr1| expr2 ? expr1 : expr1	if-then-else 条件式

|expr2|	expr3 || expr3 ..	論理和

|expr3|	expr4 && expr4 ..	論理積

|expr4|	expr5 == expr5		等しい
	expr5 != expr5		等しくない
	expr5 >	 expr5		より大きい
	expr5 >= expr5		大きいか等しい
	expr5 <	 expr5		より小さい
	expr5 <= expr5		小さいか等しい
	expr5 =~ expr5		正規表現にマッチする
	expr5 !~ expr5		正規表現にマッチしない

	expr5 ==? expr5		文字列として等しい(大文字/小文字区別無し)
	expr5 ==# expr5		文字列として等しい(大文字/小文字区別有り)
	etc.			上記の各式は大小文字の区別を、?を付加すると行
				わず、#を付加すると行う

	expr5 is expr5		同一の |List| のインスタンス
	expr5 isnot expr5	異なる |List| のインスタンス

|expr5|	expr6 +	 expr6 ..	足し算またはリストの連結
	expr6 -	 expr6 ..	引き算
	expr6 .	 expr6 ..	文字列の連結

|expr6|	expr7 *	 expr7 ..	掛け算
	expr7 /	 expr7 ..	割り算
	expr7 %	 expr7 ..	剰余(割った余り)

|expr7|	! expr7			論理否定
	- expr7			単項のマイナス(訳注:-1等)
	+ expr7			単項のプラス

|expr8|	expr8[expr1]		文字列のバイト、またはリストの要素
	expr8[expr1 : expr1]	文字列の部分文字列、またはリストの部分リスト
	expr8.name		辞書 |Dictionary| の要素
	expr8(expr1, ...)	|Funcref| 変数による関数呼び出し

|expr9|	number			数定数
	"string"		文字列定数。バックスラッシュは特別な意味を持つ
	'string'		リテラル文字列定数。'を含めるには2重にする
	[expr1, ...]		リスト |List|
	{expr1: expr1, ...}	辞書 |Dictionary|
	&option			オプション変数
	(expr1)			式の入れ子
	variable		内部変数
	va{ria}ble		波括弧付きの内部変数
	$VAR			環境変数
	@r			レジスタ'r'の値
	function(expr1, ...)	関数呼出し
	func{ti}on(expr1, ...)	波括弧付きの内部変数

".." はその演算が、その後に他の演算を続ける事が出来ることを示している。
例: >
	&nu || &list && &shell == "csh"

一つのレベルにある全ての式は左から右に解釈される。


expr1							*expr1* *E109*
-----

expr2 ? expr1 : expr1

'?'より前の式は数値として評価される。その結果が非0であった場合、'?'と':'に挟ま
れた式の値がこの式全体の値となり、逆に0であった場合は':'以降の式の値が全体の値
となる。
例: >
	:echo lnum == 1 ? "先頭" : lnum

始めの式が"expr2"であるから、そこに別の?:を含むことはできない。残り二つの式に
ついては以下のように再帰的な?:の利用が許される。
例: >
	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum

読み易くするために、行継続|list-continuation|を利用することが推奨される: >
	:echo lnum == 1
	:\	? "top"
	:\	: lnum == 1000
	:\		? "last"
	:\		: lnum

':'の前には必ずスペースを入れること。そうでないと"a:1"のような変数の使用と間違
えてしまう可能性がある。


expr2 and expr3						*expr2* *expr3*
---------------

						*expr-barbar* *expr-&&*
演算子"||"と"&&"は左右に一つずつ引数を取る。引数は数値に変換される。結果は:

	  入力				   出力		    ~
n1		n2		n1 || n2	n1 && n2    ~
零		零		零		零
零		非零		非零		零
非零		零		非零		零
非零		非零		非零		非零

演算子は続けて書く事ができる。例: >

	&nu || &list && &shell == "csh"

Note "&&"は"||"よりも高い優先順位を持っている。これは次の事を意味する: >

	&nu || (&list && &shell == "csh")

結果が確定した時点で残りの式は省略され、解釈されない。これはC言語で行なわれる
ことに似ている。例: >

	let a = 1
	echo a || b

これはaが非零で戻り値は絶対に非零であるから、変数bが宣言されていなくても有効で
ある。次のも同様に: >

	echo exists("b") && b == "yes"

これもbが宣言されているいないに関わらず有効である。後半の項はbが定義されている
時にだけ評価される。


expr4							*expr4*
-----

expr5 {cmp} expr5

2つの式expr5を比較し、結果が偽なら0を、真なら1を返す。

				*expr-==*  *expr-!=*  *expr->*   *expr->=*
				*expr-<*   *expr-<=*  *expr-=~*  *expr-!~*
				*expr-==#* *expr-!=#* *expr->#*  *expr->=#*
				*expr-<#*  *expr-<=#* *expr-=~#* *expr-!~#*
				*expr-==?* *expr-!=?* *expr->?*  *expr->=?*
				*expr-<?*  *expr-<=?* *expr-=~?* *expr-!~?*
				*expr-is*
		'ignorecase'次第   大小文字考慮    大小文字無視 ~
等しい			==		==#		==?
等しくない		!=		!=#		!=?
より大きい		>		>#		>?
より大きいか等しい	>=		>=#		>=?
より小さい		<		<#		<?
より小さいか等しい	<=		<=#		<=?
正規表現マッチ		=~		=~#		=~?
正規表現非マッチ	!~		!~#		!~?
同一のインスタンス	is
異なるインスタンス	isnot

Examples:
"abc" ==# "Abc"	  0と評価される
"abc" ==? "Abc"	  1と評価される
"abc" == "Abc"	  'ignorecase'が設定されていれば1と、でなければ0と評価

							*E691* *E692*
A |List| can only be compared with a |List| and only "equal", "not equal" and
"is" can be used.  This compares the values of the list, recursively.
Ignoring case means case is ignored when comparing item values.

							*E735* *E736*
A |Dictionary| can only be compared with a |Dictionary| and only "equal", "not
equal" and "is" can be used.  This compares the key/values of the |Dictionary|
recursively.  Ignoring case means case is ignored when comparing item values.

							*E693* *E694*
A |Funcref| can only be compared with a |Funcref| and only "equal" and "not
equal" can be used.  Case is never ignored.

When using "is" or "isnot" with a |List| this checks if the expressions are
referring to the same |List| instance.  A copy of a |List| is different from
the original |List|.  When using "is" without a |List| it is equivalent to
using "equal", using "isnot" equivalent to using "not equal".  Except that a
different type means the values are different.  "4 == '4'" is true, "4 is '4'"
is false.

文字列と数値を比較した場合、文字列が数値に変換され、数値として比較される。これ
は"0 == 'x'"が、'x'が数値としては0であることから、真となることを意味する。

文字列同士を比較した場合、strcmp()やstricmp()によって比較される。これは数値的
に(バイトの値で)比較されるのであって、必ずしも言語に基づく文字種の違いではな
い。

'#'を付けた演算子を使うか、省略形かつ'ignorecase'が設定されていない場合、比較
はstrcmp()で行なわれる。大文字・小文字は区別される。

'?'を付けた演算子を使うか、省略形かつ'ignorecase'が設定されている場合、比較は
stricmp()で行なわれる。大文字・小文字は区別されない。

'smartcase' は適用されない。

"=~"と"!~"演算子は右側の引数を正規表現のパターンとして、左側の引数に対してマッ
チを試みる。正規表現のパターンに関しては|pattern|を参照。このマッチは'magic'が
設定され'cpoptions'が空であるように振舞い、実際の'magic'や'cpoptions'に何が設
定されているには依存しない。これがスクリプトをポータブルにしてくれる。正規表現
中のバックスラッシュが重複してしまうのを避けるには、シングルクォーテーションの
文字列を使用する。詳細は|literal-string|を参照。
文字列は単一行として扱われるので、複数行のパターン(\nを含むもの)はマッチしな
い。しかしながらリテラルなヌル文字(NL)を、普通の文字として代用することはでき
る。例:
	"foo\nbar" =~ "\n"	1として評価される
	"foo\nbar" =~ "\\n"	0として評価される


expr5 and expr6						*expr5* *expr6*
---------------
expr6 +	 expr6 ..	足し算、またはリストの連結	*expr-+*
expr6 -	 expr6 ..	引き算				*expr--*
expr6 .	 expr6 ..	文字列の連結			*expr-.*

リストに対しては"+"のみ可能で、expr6は両方ともリストでなければならない。結果は
2つのリストを連結した新しいリスト。

expr7 *	 expr7 ..	掛け算				*expr-star*
expr7 /	 expr7 ..	割り算				*expr-/*
expr7 %	 expr7 ..	剰余(割った余り)		*expr-%*

"."を除く全ての演算子は自動的に文字列を数値に変換する。

"+"と"."の違いに注意:
	"123" + "456" = 579
	"123" . "456" = "123456"

'/'の右辺(除数)が0の場合、結果は0x7ffffffになる。
'%'の右辺(法)が0の場合、結果は0になる。

これらは全て|Funcref|には適用できない。


expr7							*expr7*
-----
! expr7			論理否定		*expr-!*
- expr7			単項マイナス		*expr-unary--*
+ expr7			unary plus		*expr-unary-+*

'!'演算子では非零は0に、0は1になる。
'-'では数値の符号が反転される。
'+"では変化はない。

文字列はまず数値に変換される。

これら2つは繰り返したり混ぜたりできる。例:
	!-1	    == 0
	!!8	    == 1
	--9	    == 9


expr8							*expr8*
-----
expr8[expr1]		文字列またはリストの要素	*expr-[]* *E111*

expr8が数値か文字列ならば、これの結果は文字列expr8のexpr1番目の単一のバイトか
らなる文字列である。expr8は文字列、expr1は数である。ただしマルチバイトエンコー
ディングの文字列については、単なるバイトコードであることに注意。

インデックスが0の場合、先頭のキャラクタが得られることに注意。これはC言語のよう
に働く。注意:カラム番号は1から始まる。例えばカーソルの下の文字を得るためには、
次のようにする必要がある: >
	:let c = getline(".")[col(".") - 1]

文字列の長さよりも大きなインデックスが指定された場合、結果は空文字列になる。負
数のインデックスを指定すると、結果は常に空文字列になる(後方互換性のため)。
最後のバイトを得るには[-1:]を使うこと。

If expr8 is a |List| then it results the item at index expr1.  See |list-index|
for possible index values.  If the index is out of range this results in an
error.  Example: >
	:let item = mylist[-1]		" get last item

Generally, if a |List| index is equal to or higher than the length of the
|List|, or more negative than the length of the |List|, this results in an
error.


expr8[expr1a : expr1b]	substring or sublist		*expr-[:]*

If expr8 is a Number or String this results in the substring with the bytes
from expr1a to and including expr1b.  expr8 is used as a String, expr1a and
expr1b are used as a Number.  Note that this doesn't recognize multi-byte
encodings.

If expr1a is omitted zero is used.  If expr1b is omitted the length of the
string minus one is used.

A negative number can be used to measure from the end of the string.  -1 is
the last character, -2 the last but one, etc.

If an index goes out of range for the string characters are omitted.  If
expr1b is smaller than expr1a the result is an empty string.

Examples: >
	:let c = name[-1:]		" last byte of a string
	:let c = name[-2:-2]		" last but one byte of a string
	:let s = line(".")[4:]		" from the fifth byte to the end
	:let s = s[:-3]			" remove last two bytes

If expr8 is a |List| this results in a new |List| with the items indicated by
the indexes expr1a and expr1b.  This works like with a String, as explained
just above, except that indexes out of range cause an error.  Examples: >
	:let l = mylist[:3]		" first four items
	:let l = mylist[4:4]		" List with one item
	:let l = mylist[:]		" shallow copy of a List

Using expr8[expr1] or expr8[expr1a : expr1b] on a |Funcref| results in an
error.


expr8.name		entry in a |Dictionary|		*expr-entry*

If expr8 is a |Dictionary| and it is followed by a dot, then the following
name will be used as a key in the |Dictionary|.  This is just like:
expr8[name].

The name must consist of alphanumeric characters, just like a variable name,
but it may start with a number.  Curly braces cannot be used.

There must not be white space before or after the dot.

Examples: >
	:let dict = {"one": 1, 2: "two"}
	:echo dict.one
	:echo dict .2

Note that the dot is also used for String concatenation.  To avoid confusion
always put spaces around the dot for String concatenation.


expr8(expr1, ...)	|Funcref| function call

When expr8 is a |Funcref| type variable, invoke the function it refers to.



							*expr9*
数
------
number			数定数			*expr-number*

10進数、16進数(0xか0Xで始まる)、もしくは8進数(0で始まる)の数定数。


文字列							*expr-string* *E114*
------
"string"		文字列定数		*expr-quote*

ダブルクォートが使われていることに注意。

文字列定数には以下の特殊文字が使用できる: 
\...	3桁の8進数字 (例 "\316")
\..	2桁の8進数字 (非数字が続かなければならない)
\.	1桁の8進数字 (非数字が続かなければならない)
\x..	2桁の16進数字 (例 "\x1f")
\x.	1桁の16進数字 (16進数字でないものが続かなければならない)
\X..	\x..に同じ
\X.	\x.に同じ
\u....  文字を4桁の16進数で表現したもので、実際の値は現在の'encoding'の値に依
	存する (例えば "\u02a4")
\U....	\u....に同じ
\b	バックスペース <BS>
\e	エスケープ <Esc>
\f	フォームフィード <FF>
\n	改行 <NL>
\r	改行(キャリッジリターン) <CR>
\t	タブ <Tab>
\\	円記号(バックスラッシュ)
\"	ダブルクォート
\<xxx>	"xxx"というなの特別キー。 例 "\<C-W>" は CTRL-W.

Note that "\xff" is stored as the byte 255, which may be invalid in some
encodings.  Use "\u00ff" to store character 255 according to the current value
of 'encoding'.

Note "\000"と"\x00"は強制的に文字列の終端として扱われる。


リテラル文字列						*literal-string* *E115*
---------------
'string'		文字列定数		*expr-'*

Note シングルクォートが使われていることに注意。

この文字列は文字通りに扱われる。バックスラッシュは取り除かれないし、また特別な
意味を持ったりもしない。唯一の例外は、2つのシングルクォートで1つのシングルクォ
ートになることである。

Single quoted strings are useful for patterns, so that backslashes do not need
to be doubled.  These two commands are equivalent: >
	if a =~ "\\s*"
	if a =~ '\s*'


オプション					*expr-option* *E112* *E113*
------
&option			オプション変数、ローカルなものが優先
&g:option		グローバルオプション変数
&l:option		ローカルオプション変数

例: >
	echo "タブストップは " . &tabstop . " です"
	if &insertmode

ここにはあらゆるオプション名を使うことができる。|options|を参照。ローカル変数
を使おうとして、実際にはバッファローカルもウィンドウローカルも存在しない場合に
は、グローバル変数が利用される。


レジスタ						*expr-register* *@r*
--------
@r			レジスタ'r'の値

結果は、名前付けられたレジスタの内容が単一の文字列として与えられる。必要なとこ
ろには改行文字が挿入されている。無名レジスタの内容を取得するためには@"か@@を使
う。どのようなレジスタがあるのかは、|registers|を参照。

When using the '=' register you get the expression itself, not what it
evaluates to.  Use |eval()| to evaluate it.


入れ子							*expr-nesting* *E110*
-------
(expr1)			式の入れ子


環境変数						*expr-env*
--------------------
$VAR			環境変数

環境変数の文字列。定義されていない環境変数を指定した場合、結果は空文字列。
							*expr-env-expand*
Note $VARを直接使用した場合とexpand("$VAR")を使用した場合では、動作に違いがあ
ることに注意。直接使用した場合には、現在のVimのセッション中で既知の値に展開さ
れるだけである。expand()を使用した場合、まず最初にVimのセッション中で既知の値
に展開される。それが失敗した場合、変数の展開にシェルが使用されることになる。こ
れは遅くはなるが、シェルの知りうる総ての変数を展開することができる。例: >
	:echo $version
	:echo expand("$version")
最初の一つは恐らく何も帰ってこず、2つ目は$versionの値が帰ってくるだろう(貴方の
シェルがサポートしていたとして)


内部変数						*expr-variable*
-----------------
variable		内部変数
以下の|internal-variables|を参照。


関数呼出		*expr-function* *E116* *E118* *E119* *E120*
-------------
function(expr1, ...)	関数呼出
以下の|functions|を参照。


==============================================================================
3. 内部変数					*internal-variables* *E121*
									*E461*
内部変数の名前には文字と、数字とアンダーバー('_')を使うことができる。しかし数
字で始めることはできない。波括弧を使うこともできる。
詳細は|curly-braces-names|を参照。

内部変数は":let"コマンドで作成される|:let|。":unlet"コマンドで明示的に内部変数
を破棄することができる|:unlet|。内部変数に使われてない名前か、既に破棄された内
部変数を使うとエラーとなる。

変数には幾つもの名前空間が存在する。実際にどれが利用されるかは、どのような前置
子が使われたかで決まる:

		(無し) 関数の中では関数ローカル、それ以外ではグローバル
|buffer-variable|    b:	  現在のバッファにローカル
|window-variable|    w:	  現在のウィンドウにローカル
|tabpage-variable|   t:	  現在のタブページにローカル
|global-variable|    g:	  グローバル
|local-variable|     l:	  関数にローカル
|script-variable|    s:	  |:source|されたVimスクリプトにローカル
|function-argument|  a:	  関数の引数(関数内のみ)
|vim-variable|       v:	  グローバル、Vimがあらかじめ定義

The scope name by itself can be used as a |Dictionary|.  For example, to
delete all script-local variables: >
	:for k in keys(s:)
	:    unlet s:[k]
	:endfor
<
						*buffer-variable* *b:var*
"b:"で始まる変数名は、カレントバッファに局所的な変数を意味する。このように一つ
一つのバッファ毎に、変数"b:foo"を別々に使用することができる。この種の変数は
バッファが掃除(wipe out)された時や、":bdelete"で削除された時に一緒に削除され
る。

1つのバッファローカル変数が定義済:
					*b:changedtick-variable* *changetick*
b:changedtick	現在のバッファに対する総変更の回数。変更を行うたびに増加する。
		これには一回のアンドゥ操作もカウントされる。この変数はバッファ
		に変更が行われた際にだけアクションを起こしたい時に利用できる。
		例: >
		    :if my_changedtick != b:changedtick
		    :   let my_changedtick = b:changedtick
		    :   call My_Update()
		    :endif
<
						*window-variable* *w:var*
"w:"で始まる変数名は、カレントウィンドウに局所的な変数を意味する。これはウィン
ドウを閉じるときに破棄される。

						*tabpage-variable* *t:var*
A variable name that is preceded with "t:" is local to the current tab page,
It is deleted when the tab page is closed. {not available when compiled
without the +windows feature}

						*global-variable* *g:var*
関数の中からグローバル変数へアクセスするには、"g:"を付けた名前を使用する。これ
が省略された場合は関数ローカルな変数にアクセスする。ただし"g:"自体は、関数の外
でも使うことができる。

						*local-variable* *l:var*
関数の中からそのローカル変数にアクセスするには何も前置しなければ良い。しかし明
示的に"l:"を付けることも可能。However, without prepending "l:"
you may run into reserved variable names.  For example "count".  By itself it
refers to "v:count".  Using "l:count" you can have a local variable with the
same name.


						*script-variable* *s:var*
In a Vim script variables starting with "s:" can be used.  They cannot be
accessed from outside of the scripts, thus are local to the script.

They can be used in:
- commands executed while the script is sourced
- functions defined in the script
- autocommands defined in the script
- functions and autocommands defined in functions and autocommands which were
  defined in the script (recursively)
- user defined commands defined in the script
Thus not in:
- other scripts sourced from this one
- mappings
- etc.

script variables can be used to avoid conflicts with global variable names.
Take this example: >

	let s:counter = 0
	function MyCounter()
	  let s:counter = s:counter + 1
	  echo s:counter
	endfunction
	command Tick call MyCounter()

You can now invoke "Tick" from any script, and the "s:counter" variable in
that script will not be changed, only the "s:counter" in the script where
"Tick" was defined is used.

Another example that does the same: >

	let s:counter = 0
	command Tick let s:counter = s:counter + 1 | echo s:counter

When calling a function and invoking a user-defined command, the context for
script varialbes is set to the script where the function or command was
defined.

The script variables are also available when a function is defined inside a
function that is defined in a script.  Example: >

	let s:counter = 0
	function StartCounting(incr)
	  if a:incr
	    function MyCounter()
	      let s:counter = s:counter + 1
	    endfunction
	  else
	    function MyCounter()
	      let s:counter = s:counter - 1
	    endfunction
	  endif
	endfunction

This defines the MyCounter() function either for counting up or counting down
when calling StartCounting().  It doesn't matter from where StartCounting() is
called, the s:counter variable will be accessible in MyCounter().

When the same script is sourced again it will use the same script variables.
They will remain valid as long as Vim is running.  This can be used to
maintain a counter: >

	if !exists("s:counter")
	  let s:counter = 1
	  echo "script executed for the first time"
	else
	  let s:counter = s:counter + 1
	  echo "script executed " . s:counter . " times now"
	endif

Note that this means that filetype plugins don't get a different set of script
variables for each buffer.  Use local buffer variables instead |b:var|.


Vimの定義済変数:				*vim-variable* *v:var*

					*v:beval_col* *beval_col-variable*
v:beval_col	The number of the column, over which the mouse pointer is.
		This is the byte index in the |v:beval_lnum| line.
		Only valid while evaluating the 'balloonexpr' option.

					*v:beval_bufnr* *beval_bufnr-variable*
v:beval_bufnr	The number of the buffer, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.

					*v:beval_lnum* *beval_lnum-variable*
v:beval_lnum	The number of the line, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.

					*v:beval_text* *beval_text-variable*
v:beval_text	The text under or after the mouse pointer.  Usually a word as
		it is useful for debugging a C program.  'iskeyword' applies,
		but a dot and "->" before the position is included.  When on a
		']' the text before it is used, including the matching '[' and
		word before it.  When on a Visual area within one line the
		highlighted text is used.
		Only valid while evaluating the 'balloonexpr' option.

					*v:beval_winnr* *beval_winnr-variable*
v:beval_winnr	The number of the window, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.

					*v:char* *char-variable*
v:char		Argument for evaluating 'formatexpr'.

			*v:charconvert_from* *charconvert_from-variable*
v:charconvert_from
		The name of the character encoding of a file to be converted.
		Only valid while evaluating the 'charconvert' option.

			*v:charconvert_to* *charconvert_to-variable*
v:charconvert_to
		The name of the character encoding of a file after conversion.
		Only valid while evaluating the 'charconvert' option.

					*v:cmdarg* *cmdarg-variable*
v:cmdarg	This variable is used for two purposes:
		1. The extra arguments given to a file read/write command.
		   Currently these are "++enc=" and "++ff=".  This variable is
		   set before an autocommand event for a file read/write
		   command is triggered.  There is a leading space to make it
		   possible to append this variable directly after the
		   read/write command.  Note: The "+cmd" argument isn't
		   included here, because it will be executed anyway.
		2. When printing a PostScript file with ":hardcopy" this is
		   the argument for the ":hardcopy" command.  This can be used
		   in 'printexpr'.

					*v:cmdbang* *cmdbang-variable*
v:cmdbang	Set like v:cmdarg for a file read/write command.  When a "!"
		was used the value is 1, otherwise it is 0.  Note that this
		can only be used in autocommands.  For user commands |<bang>|
		can be used.

 					*v:count* *count-variable*
v:count		最後に実行されたノーマルモードコマンドに渡されたコマンドの実行
		回数を返す。読出し専用。使用例: >
	:map _x :<C-U>echo "the count is " . count<CR>
<		Note: <C-U>は、カウントの後に':'をタイプした時に示される、行範
		囲指定を削除するために必要となる。
		オプション'formatexpr'を評価するためにも使われる。
		また"count"は、以前の版のVimとの互換性の為に動作する。

					*v:count1* *count1-variable*
v:count1	"v:count"と同じように、しかしカウントが指定されなかった時の省
		略値として存在する。

						*v:ctype* *ctype-variable*
v:ctype		The current locale setting for characters of the runtime
		environment.  This allows Vim scripts to be aware of the
		current locale encoding.  Technical: it's the value of
		LC_CTYPE.  When not using a locale the value is "C".
		This variable can not be set directly, use the |:language|
		command.
		See |multi-lang|.

					*v:dying* *dying-variable*
v:dying		Normally zero.  When a deadly signal is caught it's set to
		one.  When multiple signals are caught the number increases.
		Can be used in an autocommand to check if Vim didn't
		terminate normally. {only works on Unix}
		Example: >
	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif
<
					*v:errmsg* *errmsg-variable*
v:errmsg	最後に表示されたエラーメッセージ。この変数はセットすることが許
		されている。例: >
	:let errmsg = ""
	:next
	:if (errmsg != "")
	:  ...
<		また"errmsg"は、以前の版のVimとの互換性の為に動作する。

					*v:exception* *exception-variable*
v:exception	The value of the exception most recently caught and not
		finished.  See also |v:throwpoint| and |throw-variables|.
		Example: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "caught" v:exception
	:endtry
<		Output: "caught oops".

					*v:fcs_reason* *fcs_reason-variable*
v:fcs_reason	The reason why the |FileChangedShell| event was triggered.
		Can be used in an autocommand to decide what to do and/or what
		to set v:fcs_choice to.  Possible values:
			deleted		file no longer exists
			conflict	file contents, mode or timestamp was
					changed and buffer is modified
			changed		file contents has changed
			mode		mode of file changed
			time		only file timestamp changed

					*v:fcs_choice* *fcs_choice-variable*
v:fcs_choice	What should happen after a |FileChangedShell| event was
		triggered.  Can be used in an autocommand to tell Vim what to
		do with the affected buffer:
			reload		Reload the buffer (does not work if
					the file was deleted).
			ask		Ask the user what to do, as if there
					was no autocommand.  Except that when
					only the timestamp changed nothing
					will happen.
			<empty>		Nothing, the autocommand should do
					everything that needs to be done.
		The default is empty.  If another (invalid) value is used then
		Vim behaves like it is empty, there is no warning message.

					*v:fname_in* *fname_in-variable*
v:fname_in	The name of the input file.  Only valid while evaluating:
			option		used for ~
			'charconvert'	file to be converted
			'diffexpr'	original file
			'patchexpr'	original file
			'printexpr'	file to be printed
		And set to the swap file name for |SwapExists|.

					*v:fname_out* *fname_out-variable*
v:fname_out	The name of the output file.  Only valid while
		evaluating:
			option		used for ~
			'charconvert'	resulting converted file (*)
			'diffexpr'	output of diff
			'patchexpr'	resulting patched file
		(*) When doing conversion for a write command (e.g., ":w
		file") it will be equal to v:fname_in.  When doing conversion
		for a read command (e.g., ":e file") it will be a temporary
		file and different from v:fname_in.

					*v:fname_new* *fname_new-variable*
v:fname_new	The name of the new version of the file.  Only valid while
		evaluating 'diffexpr'.

					*v:fname_diff* *fname_diff-variable*
v:fname_diff	The name of the diff (patch) file.  Only valid while
		evaluating 'patchexpr'.

					*v:folddashes* *folddashes-variable*
v:folddashes	Used for 'foldtext': dashes representing foldlevel of a closed
		fold.
		Read-only in the |sandbox|. |fold-foldtext|

					*v:foldlevel* *foldlevel-variable*
v:foldlevel	Used for 'foldtext': foldlevel of closed fold.
		Read-only in the |sandbox|. |fold-foldtext|

					*v:foldend* *foldend-variable*
v:foldend	Used for 'foldtext': last line of closed fold.
		Read-only in the |sandbox|. |fold-foldtext|

					*v:foldstart* *foldstart-variable*
v:foldstart	Used for 'foldtext': first line of closed fold.
		Read-only in the |sandbox|. |fold-foldtext|

					*v:insertmode* *insertmode-variable*
v:insertmode	Used for the |InsertEnter| and |InsertChange| autocommand
		events.  Values:
			i	Insert mode
			r	Replace mode
			v	Virtual Replace mode

						*v:key* *key-variable*
v:key		Key of the current item of a |Dictionary|.  Only valid while
		evaluating the expression used with |map()| and |filter()|.
		Read-only.

						*v:lang* *lang-variable*
v:lang		The current locale setting for messages of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_MESSAGES.
		The value is system dependent.
		This variable can not be set directly, use the |:language|
		command.
		It can be different from |v:ctype| when messages are desired
		in a different language than what is used for character
		encoding.  See |multi-lang|.

						*v:lc_time* *lc_time-variable*
v:lc_time	The current locale setting for time messages of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_TIME.
		This variable can not be set directly, use the |:language|
		command.  See |multi-lang|.

						*v:lnum* *lnum-variable*
v:lnum		Line number for the 'foldexpr' |fold-expr| and 'indentexpr'
		expressions, tab page number for 'guitablabel' and
		'guitabtooltip'.  Only valid while one of these expressions is
		being evaluated.  Read-only when in the |sandbox|.  

					*v:mouse_win* *mouse_win-variable*
v:mouse_win	Window number for a mouse click obtained with |getchar()|.
		First window has number 1, like with |winnr()|.  The value is
		zero when there was no mouse button click.

					*v:mouse_lnum* *mouse_lnum-variable*
v:mouse_lnum	Line number for a mouse click obtained with |getchar()|.
		This is the text line number, not the screen line number.  The
		value is zero when there was no mouse button click.

					*v:mouse_col* *mouse_col-variable*
v:mouse_col	Column number for a mouse click obtained with |getchar()|.
		This is the screen column number, like with |virtcol()|.  The
		value is zero when there was no mouse button click.

					*v:prevcount* *prevcount-variable*
v:prevcount	The count given for the last but one Normal mode command.
		This is the v:count value of the previous command.  Useful if
		you want to cancel Visual mode and then use the count. >
			:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
<		Read-only.

					*v:profiling* *profiling-variable*
v:profiling	Normally zero.  Set to one after using ":profile start".
		See |profiling|.

					*v:progname* *progname-variable*
v:progname	Contains the name (with path removed) with which Vim was
		invoked.  Allows you to do special initialisations for "view",
		"evim" etc., or any other name you might symlink to Vim.
		Read-only.

					*v:register* *register-variable*
v:register	The name of the register supplied to the last normal mode
		command.  Empty if none were supplied. |getreg()| |setreg()|

					*v:scrollstart* *scrollstart-variable*
v:scrollstart	String describing the script or function that caused the
		screen to scroll up.  It's only set when it is empty, thus the
		first reason is remembered.  It is set to "Unknown" for a
		typed command.
		This can be used to find out why your script causes the
		hit-enter prompt.

					*v:servername* *servername-variable*
v:servername	The resulting registered |x11-clientserver| name if any.
		Read-only.

			    		*v:shell_error* *shell_error-variable*
v:shell_error	最後に実行したシェルコマンドの結果。シェルコマンドの実行時にな
		にかエラーがあったならば、非零の値を取る。問題がなければ零にな
		る。これはシェルがエラーコードをVimに通知する時のみ働く。コマ
		ンドが実行されなかった時には、値として-1が良く使われる。読出し
		専用。
		例: >
	:!mv foo bar
	:if v:shell_error
	:  echo 'could not rename "foo" to "bar"!'
	:endif
<		また"shell_error"は、以前の版のVimとの互換性の為に動作する。

					*v:statusmsg* *statusmsg-variable*
v:statusmsg	最後に表示されたステータスメッセージ。この変数はセットすること
		が許されている。

					*v:swapname* *swapname-variable*
v:swapname	Only valid when executing |SwapExists| autocommands: Name of
		the swap file found.  Read-only.

					*v:swapchoice* *swapchoice-variable*
v:swapchoice	|SwapExists| autocommands can set this to the selected choice
		for handling an existing swap file:
			'o'	Open read-only
			'e'	Edit anyway
			'r'	Recover
			'd'	Delete swapfile
			'q'	Quit
			'a'	Abort
		The value should be a single-character string.  An empty value
		results in the user being asked, as would happen when there is
		no SwapExists autocommand.  The default is empty.

					*v:swapcommand* *swapcommand-variable*
v:swapcommand	Normal mode command to be executed after a file has been
		opened.  Can be used for a |SwapExists| autocommand to have
		another Vim open the file and jump to the right place.  For
		example, when jumping to a tag the value is ":tag tagname\r".
		For ":edit +cmd file" the value is ":cmd\r".

				*v:termresponse* *termresponse-variable*
v:termresponse	The escape sequence returned by the terminal for the |t_RV|
		termcap entry.  It is set when Vim receives an escape sequence
		that starts with ESC [ or CSI and ends in a 'c', with only
		digits, ';' and '.' in between.
		When this option is set, the TermResponse autocommand event is
		fired, so that you can react to the response from the
		terminal.
		The response from a new xterm is: "<Esc>[ Pp ; Pv ; Pc c".  Pp
		is the terminal type: 0 for vt100 and 1 for vt220.  Pv is the
		patch level (since this was introduced in patch 95, it's
		always 95 or bigger).  Pc is always zero.
		{only when compiled with |+termresponse| feature}

				*v:this_session* *this_session-variable*
v:this_session	最後にロードされたか、セーブされたセッションファイルの完全な
		ファイル名。|:mksession|を参照。この変数はセットすることが許さ
		れている。それ以前にセーブされたセッションがなければ、この変数
		は空となる。
		また"this_session"は、以前の版のVimとの互換性の為に動作する。

					*v:throwpoint* *throwpoint-variable*
v:throwpoint	The point where the exception most recently caught and not
		finished was thrown.  Not set when commands are typed.  See
		also |v:exception| and |throw-variables|.
		Example: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "Exception from" v:throwpoint
	:endtry
<		Output: "Exception from test.vim, line 2"

						*v:val* *val-variable*
v:val		Value of the current item of a |List| or |Dictionary|.  Only
		valid while evaluating the expression used with |map()| and
		|filter()|.  Read-only.

				*v:version* *version-variable*
v:version	Vimのバージョン番号。メジャーバージョン番号は100倍され、マイ
		ナーバージョン番号と足されている。Version 5.0は500。Version
		5.1 (5.01)は501となる。読出し専用。また"version"は、以前の版の
		Vimとの互換性の為に動作する。
		特定のパッチが摘要されているかを調べるには|has()|を使う。例: >
			if has("patch123")
<		5.0と5.1には両方ともパッチ123が存在しているが、バージョンが違
		えば番号は同じでもパッチの内容は全く異なっている。

					*v:warningmsg* *warningmsg-variable*
v:warningmsg	最後に表示された警告メッセージ。この変数はセットすることが許さ
		れている。

==============================================================================
4. 組み込み関数						*functions*

(関数名の上でCTRL-]を使うことで、詳細な説明へ飛ぶことができる)

使用法				結果	説明		~

add( {list}, {item})		List	append {item} to |List| {list}
append( {lnum}, {string})	数値	{string}を{lnum}行目に付け加える
append( {lnum}, {list})		Number	append lines {list} below line {lnum}
argc()				数値	引数内のファイルの数
argv( {nr})			文字列	引数の第{nr}番目
argv( )				List	the argument list
browse( {save}, {title}, {initdir}, {default})
				文字列	ファイル選択ダイアログを表示
browsedir( {title}, {initdir})  String	put up a directory requester
bufexists( {expr})		数値	バッファ{expr}が存在すればTRUE
bufloaded( {expr})		数値	バッファ{expr}がロード済みならTRUE
bufname( {expr})		文字列	バッファ{expr}の名前
bufnr( {expr})			数値	バッファ{expr}の番号
bufwinnr( {nr})			数値	バッファ{nr}のウィンドウ番号
byte2line( {byte})		数値	{byte}番目のバイトの行番号
byteidx( {expr}, {nr})		Number	byte index of {nr}'th char in {expr}
call( {func}, {arglist} [, {dict}])
				any	call {func} with arguments {arglist}
changenr()			Number  current change number
char2nr( {expr})		数値	{expr}の先頭文字のASCIIコード
col( {expr})			数値	カーソルかマークのカラム番号nr
complete({startcol}, {matches})	String  set Insert mode completion
complete_add( {expr})		Number	add completion match
complete_check()		Number  check for key typed during completion
confirm( {msg}, {choices} [, {default} [, {type}]])
				数値	ユーザへの選択肢と番号
copy( {expr})			any	make a shallow copy of {expr}
count( {list}, {expr} [, {start} [, {ic}]])
				Number	 count how many {expr} are in {list}
cscope_connection( [{num} , {dbpath} [, {prepend}]])
				Number	checks existence of cscope connection
cursor( {lnum}, {col} [, {coladd}])
				Number	move cursor to {lnum}, {col}, {coladd}
cursor( {list})			Number	move cursor to position in {list}
deepcopy( {expr})		any	make a full copy of {expr}
delete( {fname})		数値	ファイル{fname}を消す
did_filetype()			数値	FileTypeのautocommandが実行されたか?
diff_filler( {lnum})		Number	diff filler lines about {lnum}
diff_hlID( {lnum}, {col})	Number	diff highlighting at {lnum}/{col}
empty( {expr})			Number	TRUE if {expr} is empty
escape( {string}, {chars})	文字列	{string}内の{chars}を'\'でエスケープ
eval( {string})			any	evaluate {string} into its value
exists( {var})			数値	変数{var}が存在したらTRUE
extend({expr1}, {expr2} [, {expr3}])
				List/Dict insert items of {expr2} into {expr1}
expand( {expr})			文字列	{expr}内の特別なキーワードを展開
feedkeys( {string} [, {mode}])	Number  add key sequence to typeahead buffer
filereadable( {file})		数値	{file}が読みこみ可能ならTRUE
filewritable( {file})		Number	TRUE if {file} is a writable file
filter( {expr}, {string})	List/Dict  remove items from {expr} where
					{string} is 0
finddir( {name}[, {path}[, {count}]])
				String	find directory {name} in {path}
findfile( {name}[, {path}[, {count}]])
				String	find file {name} in {path}
fnamemodify( {fname}, {mods})	文字列	ファイル名を変更
foldclosed( {lnum})		Number	first line of fold at {lnum} if closed
foldclosedend( {lnum})		Number	last line of fold at {lnum} if closed
foldlevel( {lnum})		Number	fold level at {lnum}
foldtext( )			String	line displayed for closed fold
foldtextresult( {lnum})		String	text for closed fold at {lnum}
foreground( )			Number	bring the Vim window to the foreground
function( {name})		Funcref reference to function {name}
garbagecollect()		none	free memory, breaking cyclic references
get( {list}, {idx} [, {def}])	any	get item {idx} from {list} or {def}
get( {dict}, {key} [, {def}])	any	get item {key} from {dict} or {def}
getbufline( {expr}, {lnum} [, {end}])
				List	lines {lnum} to {end} of buffer {expr}
getbufvar( {expr}, {varname})	any	variable {varname} in buffer {expr}
getcmdline()			String	return the current command-line
getcmdpos()			Number	return cursor position in command-line
getcmdtype()			String	return the current command-line type
getcwd()			文字列	現在の作業ディレクトリ
getfperm( {fname})		String	file permissions of file {fname}
getfsize( {fname})		Number	size in bytes of file {fname}
getfontname( [{name}])		String	name of font being used
getftime( {fname})		数値	ファイルの最終更新時間
getftype( {fname})		String	description of type of file {fname}
getline( {lnum})		文字列	現在のバッファから行の内容を取得
getline( {lnum}, {end})		List	lines {lnum} to {end} of current buffer
getloclist({nr})		List	list of location list items
getpos( {expr})			List	position of cursor, mark, etc.
getqflist()			List	list of quickfix items
getreg( [{regname} [, 1]])	String	contents of register
getregtype( [{regname}])	String	type of register
gettabwinvar( {tabnr}, {winnr}, {name})
				any	{name} in {winnr} in tab page {tabnr}
getwinposx()			数値	GUI vim windowのX座標
getwinposy()			数値	GUI vim windowのY座標
getwinvar( {nr}, {varname})	any	variable {varname} in window {nr}
glob( {expr} [, {flag}])	文字列	{expr}内のfile wildcardを展開
globpath( {path}, {expr})	String	do glob({expr}) for all dirs in {path}
has( {feature})			数値	機能{feature}がサポートならばTRUE
has_key( {dict}, {key})		Number	TRUE if {dict} has entry {key}
haslocaldir()			Number	TRUE if current window executed |:lcd|
hasmapto( {what} [, {mode} [, {abbr}]])
				Number	TRUE if mapping to {what} exists
histadd( {history},{item})	文字列	ヒストリに追加
histdel( {history} [, {item}])	文字列	ヒストリからitemを削除
histget( {history} [, {index}])	文字列	ヒストリから{index}アイテムを取得
histnr( {history})		数値	ヒストリの数
hlexists( {name})		数値	highligth group {name}が存在したらTRUE
hlID( {name})			数値	highlight group {name}のID
hostname()			文字列	vimが動作しているマシンの名前
iconv( {expr}, {from}, {to})	String	convert encoding of {expr}
indent( {lnum})			Number	indent of line {lnum}
index( {list}, {expr} [, {start} [, {ic}]])
				Number	index in {list} where {expr} appears
input( {prompt} [, {text} [, {completion}]])
				文字列	ユーザからの入力を取得
inputdialog( {p} [, {t} [, {c}]]) String  like input() but in a GUI dialog
inputlist( {textlist})		Number	let the user pick from a choice list
inputrestore()			Number	restore typeahead
inputsave()			Number	save and clear typeahead
inputsecret( {prompt} [, {text}]) String  like input() but hiding the text
insert( {list}, {item} [, {idx}]) List	insert {item} in {list} [before {idx}]
isdirectory( {directory})	数値	{directory}がディレクトリならばTRUE
islocked( {expr})		Number	TRUE if {expr} is locked
items( {dict})			List	key-value pairs in {dict}
join( {list} [, {sep}])		String	join {list} items into one String
keys( {dict})			List	keys in {dict}
len( {expr})			Number	the length of {expr}
libcall( {lib}, {func}, {arg}	文字列	ライブラリ{lib}の関数{func}をコール
libcallnr( {lib}, {func}, {arg})  Number  idem, but return a Number
line( {expr})			数値	行番号の取得
line2byte( {lnum})		数値	行{lnum}のバイトカウント
lispindent( {lnum})		Number	Lisp indent for line {lnum}
localtime()			数値	現在時刻
maparg( {name}[, {mode} [, {abbr}]])
				String	rhs of mapping {name} in mode {mode}
mapcheck( {name}[, {mode} [, {abbr}]])
				String	check for mappings matching {name}
match( {expr}, {pat}[, {start}[, {count}]])
				Number	position where {pat} matches in {expr}
matcharg( {nr})			List	arguments of |:match|
matchend( {expr}, {pat}[, {start}[, {count}]])
				Number	position where {pat} ends in {expr}
matchlist( {expr}, {pat}[, {start}[, {count}]])
				List	match and submatches of {pat} in {expr}
matchstr( {expr}, {pat}[, {start}[, {count}]])
				String	{count}'th match of {pat} in {expr}
max({list})			Number	maximum value of items in {list}
min({list})			Number	minimum value of items in {list}
mkdir({name} [, {path} [, {prot}]])
				Number	create directory {name}
mode()				String	current editing mode
nextnonblank( {lnum})		Number	line nr of non-blank line >= {lnum}
nr2char( {expr})		文字列	ASCIIコード{expr}で示されるキャラクタ
pathshorten( {expr})		String	shorten directory names in a path
prevnonblank( {lnum})		Number	line nr of non-blank line <= {lnum}
printf( {fmt}, {expr1}...)	String  format text
pumvisible()			Number  whether popup menu is visible
range( {expr} [, {max} [, {stride}]])
				List	items from {expr} to {max}
readfile({fname} [, {binary} [, {max}]])
				List	get list of lines from file {fname}
reltime( [{start} [, {end}]])	List	get time value
reltimestr( {time})		String	turn time value into a String
remote_expr( {server}, {string} [, {idvar}])
				String	send expression
remote_foreground( {server})	Number	bring Vim server to the foreground
remote_peek( {serverid} [, {retvar}])
				Number	check for reply string
remote_read( {serverid})	String	read reply string
remote_send( {server}, {string} [, {idvar}])
				String	send key sequence
remove( {list}, {idx} [, {end}])  any	remove items {idx}-{end} from {list}
remove( {dict}, {key})		any	remove entry {key} from {dict}
rename({from}, {to})		数値	{file}から{to}へファイル名変更
repeat( {expr}, {count})	String	repeat {expr} {count} times
resolve( {filename})		String	get filename a shortcut points to
reverse( {list})		List	reverse {list} in-place
search( {pattern} [, {flags}])	Number	search for {pattern}
searchdecl({name} [, {global} [, {thisblock}]])
				Number  search for variable declaration
searchpair( {start}, {middle}, {end} [, {flags} [, {skip} [, {stopline}]]])
				Number	search for other end of start/end pair
searchpairpos( {start}, {middle}, {end} [, {flags} [, {skip} [, {stopline}]]])
				List	search for other end of start/end pair
searchpos( {pattern} [, {flags} [, {stopline}]])
				List	search for {pattern}
server2client( {clientid}, {string})
				Number	send reply string
serverlist()			String	get a list of available servers
setbufvar( {expr}, {varname}, {val})	set {varname} in buffer {expr} to {val}
setcmdpos( {pos})		Number	set cursor position in command-line
setline( {lnum}, {line})	数値	行{lnum}に{line}(文字列)をセット
setloclist( {nr}, {list}[, {action}])
				Number	modify location list using {list}
setpos( {expr}, {list})		none	set the {expr} position to {list}
setqflist( {list}[, {action}])	Number	modify quickfix list using {list}
setreg( {n}, {v}[, {opt}])	Number	set register to value and type
settabwinvar( {tabnr}, {winnr}, {varname}, {val})    set {varname} in window
					{winnr} in tab page {tabnr} to {val}
setwinvar( {nr}, {varname}, {val})	set {varname} in window {nr} to {val}
shellescape( {string})		String	escape {string} for use as shell
					command argument
simplify( {filename})		String	simplify filename as much as possible
sort( {list} [, {func}])	List	sort {list}, using {func} to compare
soundfold( {word})		String	sound-fold {word}
spellbadword()			String	badly spelled word at cursor
spellsuggest( {word} [, {max} [, {capital}]])
				List	spelling suggestions
split( {expr} [, {pat} [, {keepempty}]])
				List	make |List| from {pat} separated {expr}
str2nr( {expr} [, {base}])	Number	convert string to number
strftime( {format}[, {time}])	文字列	指定されたフォーマットでの時刻
stridx( {haystack}, {needle}[, {start}])
				Number	index of {needle} in {haystack}
string( {expr})			String	String representation of {expr} value
strlen( {expr})			数値	文字列{expr}の長さ
strpart( {src}, {start}[, {len}])
				文字列	{src}内{start}から長さ{len}の部分
strridx( {haystack}, {needle} [, {start}])
				Number	last index of {needle} in {haystack}
strtrans( {expr})		文字列	文字列を表示可能に変更
submatch( {nr})			String	specific match in ":substitute"
substitute( {expr}, {pat}, {sub}, {flags})
				文字列	{expr}の{pat}を{sub}に置換え
synID( {line}, {col}, {trans})	数値	{line}と{col}のsyntax IDを取得
synIDattr( {synID}, {what} [, {mode}])
				文字列	syntax ID{synID}の属性{what}を取得
synIDtrans( {synID})		数値	{synID}の翻訳されたsyntax ID
system( {expr} [, {input}])	文字列	シェルコマンド{expr}の出力結果
tabpagebuflist( [{arg}])	List	list of buffer numbers in tab page
tabpagenr( [{arg}])		Number	number of current or last tab page
tabpagewinnr( {tabarg}[, {arg}])
				Number	number of current window in tab page
taglist( {expr})		List	list of tags matching {expr}
tagfiles()			List    tags files used
tempname()			文字列	テンポラリファイルの名前
tolower( {expr})		String	the String {expr} switched to lowercase
toupper( {expr})		String	the String {expr} switched to uppercase
tr( {src}, {fromstr}, {tostr})	String	translate chars of {src} in {fromstr}
					to chars in {tostr}
type( {name})			Number	type of variable {name}
values( {dict})			List	values in {dict}
virtcol( {expr})		数値	カーソルのスクリーンカラム位置
visualmode( [expr])		文字列	最後に使われたVisualモード
winbufnr( {nr})			数値	ウィンドウ{nr}のバッファ番号
wincol()			Number	window column of the cursor
winheight( {nr})		数値	ウィンドウ{nr}の高さ
winline()			Number	window line of the cursor
winnr()				数値	現在のウィンドウの番号
winrestcmd()			String	returns command to restore window sizes
winrestview({dict})		None	restore view of current window
winsaveview()			Dict	save view of current window
winwidth( {nr})			Number	width of window {nr}
writefile({list}, {fname} [, {binary}])
				Number	write list of lines to file {fname}


add({list}, {expr})					*add()*
		Append the item {expr} to |List| {list}.  Returns the
		resulting |List|.  Examples: >
			:let alist = add([1, 2, 3], item)
			:call add(mylist, "woodstock")
<		Note that when {expr} is a |List| it is appended as a single
		item.  Use |extend()| to concatenate |Lists|.
		Use |insert()| to add an item at another position.


append({lnum}, {expr})					*append()*
		When {expr} is a |List|: Append each item of the |List| as a
		text line below line {lnum} in the current buffer.
		Otherwise append {expr} as one text line below line {lnum} in
		the current buffer.
		{lnum} can be zero to insert a line before the first one.
		Returns 1 for failure ({lnum} out of range or out of memory),
		0 for success.  Example: >
			:let failed = append(line('$'), "# THE END")
			:let failed = append(0, ["Chapter 1", "the beginning"])

							*argc()*
argc()		結果は引数のリスト内の、ファイルの数。|arglist|を参照。

							*argv()*
argv([{nr}])	結果は引数リスト内の、{nr}番目のファイル。|arglist|を参照。
		"argv(0)"は一番最初のファイルを示す。例:
>	let i = 0
>	while i < argc()
>	  let f = substitute(argv(i), '\([. ]\)', '\\&', 'g')
>	  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
>	  let i = i + 1
>	endwhile
<		Without the {nr} argument a |List| with the whole |arglist| is
		returned.

							*browse()*
browse({save}, {title}, {initdir}, {default})
		ファイル選択ダイアログを起動。これは"has("browser")"が、非零を
		返す時(幾つかのGUIバージョンに限定)にだけ働く。
		入力フィールドの意味は:
		    {save}	非零ならば書込み用ファイルの選択
		    {title}	ダイアログのタイトル
		    {initdir}	ダイアログの始まるディレクトリ
		    {default}	ファイル名の省略値
		ダイアログがキャンセルされるか、何かエラーがあるか、もしくはブ
		ラウジングが不可能ならば、空文字列が戻ってくる。

							*browsedir()*
browsedir({title}, {initdir})
		Put up a directory requester.  This only works when
		"has("browse")" returns non-zero (only in some GUI versions).
		On systems where a directory browser is not supported a file
		browser is used.  In that case: select a file in the directory
		to be used.
		The input fields are:
		    {title}	title for the requester
		    {initdir}	directory to start browsing in
		When the "Cancel" button is hit, something went wrong, or
		browsing is not possible, an empty string is returned.

							*bufexists()*
bufexists({expr})
		結果は数値で、{expr}と呼ばれるバッファが存在すれば非零となる。
		If the {expr} argument is a number, buffer numbers are used.
		{expr}が文字列だった場合、バッファ名に正確にマッチしなければな
		らない。The name can be:
		- Relative to the current directory.
		- A full path.
		- The name of a buffer with 'filetype' set to "nofile".
		- A URL name.
		Unlisted buffers will be found.
		Note that help files are listed by their short name in the
		output of |:buffers|, but bufexists() requires using their
		long name to be able to find them.
		Use "bufexists(0)" to test for the existence of an alternate
		file name.

							*buffer_exists()*
		以前の名前: buffer_exists().

							*bufloaded()*
bufloaded({expr})
		戻り値は数値で、{expr}と呼ばれるバッファが存在しロード済み(
		ウィンドウに表示されているか、隠されているかは問わない)ならば
		結果は非零となる。引数{expr}は|bufexists()|と同じように扱われ
		る。

							*bufname()*
bufname({expr})
		戻り値はバッファの名前。バッファ名はコマンド":ls"で表示される
		ものと同様。
		{expr}が数値ならば、その番号のバッファ名が返される。0は現在の
		ウィンドウの裏バッファを意味する。{expr}が文字列ならば、バッ
		ファ名に対して正規表現マッチングを行なうパターンとなる。この
		マッチングは常に、'magic'をセットし'cpoptions'を空にした状態で
		行なわれる。複数マッチしてしまった場合には空文字列が返される。
		""や"%"は現在のバッファを意味し、"#"は裏バッファを意味する。
		A full match is preferred, otherwise a match at the start, end
		or middle of the buffer name is accepted.  If you only want a
		full match then put "^" at the start and "$" at the end of the
		pattern.
		Listed buffers are found first.  If there is a single match
		with a listed buffer, that one is returned.  Next unlisted
		buffers are searched for.
		{expr}が文字列のときに、それをバッファ番号として使いたいなら
		ば、0を足すことによって強制的に数値にすることができる:
>			echo bufname("3" + 0)
		バッファが存在しないか名前を持っていない場合には、空文字列が返
		される。
>  bufname("#")			alternate buffer name
>  bufname(3)			name of buffer 3
>  bufname("%")			name of current buffer
>  bufname("file2")		name of buffer where "file2" matches.
							*buffer_name()*
		以前の名前: buffer_name().

							*bufnr()*
bufnr({expr} [, {create}])
		結果はバッファの番号。バッファ番号はコマンド":ls"で表示される
		ものと同様。{expr}の使い方は前述のbufname()を参照。バッファが
		存在しない場合-1が返される。  Or, if the
		{create} argument is present and not zero, a new, unlisted,
		buffer is created and its number is returned.
		bufnr("$")は最後のバッファを意味する:
>  :let last_buffer = bufnr("$")
		結果は存在しているバッファのうちで、もっとも大きなバッファ番号
		となる。 Note そのバッファ番号より小さいバッファ番号を持つ(ハ
		ズの)バッファが、必ずしも総て存在するとは限らない。なぜなら
		":bdel"がバッファを消すことができるからだ。バッファが存在する
		かテストするにはbufexists()を使う。
		以前の名前: buffer_number().
							*last_buffer_nr()*
		bufnr("$")の以前の名前: last_buffer_nr().

							*bufwinnr()*
bufwinnr({expr})
		結果は数値で、バッファ{expr}に関連付けられた最初のウィンドウの
		番号。{expr}の使い方は前述のbufname()を参照。バッファ{expr}が
		存在しないか、ウィンドウが無い場合には-1が返される。例: >

	echo "A window containing buffer 1 is " . (bufwinnr(1))

<		The number can be used with |CTRL-W_w| and ":wincmd w"
		|:wincmd|.
		Only deals with the current tab page.
							*byte2line()*
byte2line({byte})
		現在のバッファの先頭から{byte}番目のキャラクタが、何行目に含ま
		れるかを返す。これには現在のバッファの'fileformat'に依存した、
		改行文字も含まれる。先頭の文字にはバイトカウント1が与えられ
		る。
		|line2byte()|と|go|と|:goto|も参照。
		{|+byte_offset|機能を有効にしてコンパイルしなければ利用できな
		い}

byteidx({expr}, {nr})					*byteidx()*
		Return byte index of the {nr}'th character in the string
		{expr}.  Use zero for the first character, it returns zero.
		This function is only useful when there are multibyte
		characters, otherwise the returned value is equal to {nr}.
		Composing characters are counted as a separate character.
		Example : >
			echo matchstr(str, ".", byteidx(str, 3))
<		will display the fourth character.  Another way to do the
		same: >
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		If there are less than {nr} characters -1 is returned.
		If there are exactly {nr} characters the length of the string
		is returned.

call({func}, {arglist} [, {dict}])			*call()* *E699*
		Call function {func} with the items in |List| {arglist} as
		arguments.
		{func} can either be a |Funcref| or the name of a function.
		a:firstline and a:lastline are set to the cursor line.
		Returns the return value of the called function.
		{dict} is for functions with the "dict" attribute.  It will be
		used to set the local variable "self". |Dictionary-function|

changenr()						*changenr()*
		Return the number of the most recent change.  This is the same
		number as what is displayed with |:undolist| and can be used
		with the |:undo| command.
		When a change was made it is the number of that change.  After
		redo it is the number of the redone change.  After undo it is
		one less than the number of the undone change.

							*char2nr()*
char2nr({expr})
		{expr}の最初の文字のASCIIコードを返す。例:
>			char2nr(" ")		returns 32
>			char2nr("ABC")		returns 65
<		The current 'encoding' is used.  Example for "utf-8": >
			char2nr("á")		returns 225
			char2nr("á"[0])		returns 195
<		nr2char() does the opposite.

cindent({lnum})						*cindent()*
		Get the amount of indent for line {lnum} according the C
		indenting rules, as with 'cindent'.
		The indent is counted in spaces, the value of 'tabstop' is
		relevant.  {lnum} is used just like in |getline()|.
		When {lnum} is invalid or Vim was not compiled the |+cindent|
		feature, -1 is returned.
		See |C-indenting|.

							*col()*
col({expr})	
		戻り値は数値で、{expr}で与えられるファイル上でのカラム番号。有
		効な位置は:
		    .	    現在の位置
		    $	    the end of the cursor line (the result is the
			    number of characters in the cursor line plus one)
		    'x	    マークxの位置(マークが設定されていない場合0)
		To get the line number use |line()|.  To get both use
		|getpos()|.
		For the screen column position use |virtcol()|.
		Note 現在のファイルのマークしか使えないことに注意。
		例:
>			col(".")		カーソルのカラム
			col("$")		length of cursor line plus one
>			col("'t")		マークtのカラム
>			col("'" . markname)	マークmarknameのカラム
		先頭のカラムは1になる。返された0はエラーを示す。
		For an uppercase mark the column may actually be in another
		buffer.
		For the cursor position, when 'virtualedit' is active, the
		column is one higher if the cursor is after the end of the
		line.  This can be used to obtain the column in Insert mode: >
			:imap <F2> <C-O>:let save_ve = &ve<CR>
				\<C-O>:set ve=all<CR>
				\<C-O>:echo col(".") . "\n" <Bar>
				\let &ve = save_ve<CR>
<
complete({startcol}, {matches})			*complete()* *E785*
		Set the matches for Insert mode completion.
		Can only be used in Insert mode.  You need to use a mapping
		with CTRL-R = |i_CTRL-R|.  It does not work after CTRL-O or
		with an expression mapping.
		{startcol} is the byte offset in the line where the completed
		text start.  The text up to the cursor is the original text
		that will be replaced by the matches.  Use col('.') for an
		empty string.  "col('.') - 1" will replace one character by a
		match.
		{matches} must be a |List|.  Each |List| item is one match.
		See |complete-items| for the kind of items that are possible.
		Note that the after calling this function you need to avoid
		inserting anything that would completion to stop.
		The match can be selected with CTRL-N and CTRL-P as usual with
		Insert mode completion.  The popup menu will appear if
		specified, see |ins-completion-menu|.
		Example: >
	inoremap <F5> <C-R>=ListMonths()<CR>

	func! ListMonths()
	  call complete(col('.'), ['January', 'February', 'March',
		\ 'April', 'May', 'June', 'July', 'August', 'September',
		\ 'October', 'November', 'December'])
	  return ''
	endfunc
<		This isn't very useful, but it shows how it works.  Note that
		an empty string is returned to avoid a zero being inserted.

complete_add({expr})				*complete_add()*
		Add {expr} to the list of matches.  Only to be used by the
		function specified with the 'completefunc' option.
		Returns 0 for failure (empty string or out of memory),
		1 when the match was added, 2 when the match was already in
		the list.
		See |complete-functions| for an explanation of {expr}.  It is
		the same as one item in the list that 'omnifunc' would return.

complete_check()				*complete_check()*
		Check for a key typed while looking for completion matches.
		This is to be used when looking for matches takes some time.
		Returns non-zero when searching for matches is to be aborted,
		zero otherwise.
		Only to be used by the function specified with the
		'completefunc' option.


							*confirm()*
confirm({msg}, {choices} [, {default} [, {type}]])
		confirm()はユーザに選択させるためのダイアログを提供する。戻り
		値は選択した番号になる。最初の選択肢が1である。
		Note: confirm()は、ダイアログサポートを有効にしてコンパイルし
		た時にだけ動作する。|+dialog_con|と|+dialog_gui|を参照。
		ダイアログには{msg}に加えて{choices}の選択肢が表示される。
		{msg}は文字列で'\n'を改行として使用できる。幾つかのシステムで
		は、長すぎる行は自動的に折り返される。
		{choices}は文字列で、個々の選択肢は'\n'によって区切られる。
		例:
>			confirm("Save changes?", "&Yes\n&No\n&Cancel")
		'&'の後の文字は選択肢のショートカットキーになる。この場合
		"Cancel"を選択するのに'c'をタイプすることができる。ショート
		カットキーは最初の文字である必要は無い:
>			confirm("file has been modified", "&Save\nSave &All")
		コンソールでは、デフォルトのショートカットキーとして、各選択肢
		の最初の文字が使われる。
		オプションの引数{default}は<CR>キーを叩いた時に選択される選択
		肢の番号を指定する。最初の選択肢をデフォルトにするならば1を使
		用する。デフォルトを設定したくないのならば0を使用する。
		{default}を省略した場合、0が使用される。
		オプションの引数{type}はダイアログのタイプを与える。これは
		Win32 GUI版でアイコンを指定するのに使う。"Error", "Question",
		"Info", "Warning", "Generic"のうちどれか一つを指定する。以上の
		うちの先頭の文字だけで指定できる。{type}が省略された場合、
		"Generic"が使用される。
		ユーザが<Esc>やCTRL-Cや、その他の割りこみキーでダイアログを中
		断した場合、confirm()は0を返す。

		例:
>   :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
>   :if choice == 0
>   :	echo "make up your mind!"
>   :elseif choice == 3
>   :	echo "tasteful"
>   :else
>   :	echo "I prefer bananas myself."
>   :endif
		GUIのダイアログではボタンが使用される。ボタンの配置は
		'guioptions'の'v'フラグに依存する。もしも'v'フラグが含まれてい
		るのなら、ボタンは常に垂直に配置される。そうでなければ水平に配
		置しようと試みられる。水平配置がうまくマッチしない場合は、垂直
		配置が使われる。幾つかのシステムでは常に水平配置が使われる。

							*copy()*
copy({expr})	Make a copy of {expr}.  For Numbers and Strings this isn't
		different from using {expr} directly.
		When {expr} is a |List| a shallow copy is created.  This means
		that the original |List| can be changed without changing the
		copy, and vise versa.  But the items are identical, thus
		changing an item changes the contents of both |Lists|.  Also
		see |deepcopy()|.

count({comp}, {expr} [, {ic} [, {start}]])			*count()*
		Return the number of times an item with value {expr} appears
		in |List| or |Dictionary| {comp}.
		If {start} is given then start with the item with this index.
		{start} can only be used with a |List|.
		When {ic} is given and it's non-zero then case is ignored.


							*cscope_connection()*
cscope_connection([{num} , {dbpath} [, {prepend}]])
		Checks for the existence of a |cscope| connection.  If no
		parameters are specified, then the function returns:
			0, if cscope was not available (not compiled in), or
			   if there are no cscope connections;
			1, if there is at least one cscope connection.

		If parameters are specified, then the value of {num}
		determines how existence of a cscope connection is checked:

		{num}	Description of existence check
		-----	------------------------------
		0	Same as no parameters (e.g., "cscope_connection()").
		1	Ignore {prepend}, and use partial string matches for
			{dbpath}.
		2	Ignore {prepend}, and use exact string matches for
			{dbpath}.
		3	Use {prepend}, use partial string matches for both
			{dbpath} and {prepend}.
		4	Use {prepend}, use exact string matches for both
			{dbpath} and {prepend}.

		Note: All string comparisons are case sensitive!

		Examples.  Suppose we had the following (from ":cs show"): >

  # pid    database name			prepend path
  0 27664  cscope.out				/usr/local
<
		Invocation					Return Val ~
		----------					---------- >
		cscope_connection()					1
		cscope_connection(1, "out")				1
		cscope_connection(2, "out")				0
		cscope_connection(3, "out")				0
		cscope_connection(3, "out", "local")			1
		cscope_connection(4, "out")				0
		cscope_connection(4, "out", "local")			0
		cscope_connection(4, "cscope.out", "/usr/local")	1
<
cursor({lnum}, {col} [, {off}])				*cursor()*
cursor({list})
		Positions the cursor at the column (byte count) {col} in the
		line {lnum}.  The first column is one.
		When there is one argument {list} this is used as a |List|
		with two or three items {lnum}, {col} and {off}.  This is like
		the return value of |getpos()|, but without the first item.
		Does not change the jumplist.
		If {lnum} is greater than the number of lines in the buffer,
		the cursor will be positioned at the last line in the buffer.
		If {lnum} is zero, the cursor will stay in the current line.
		If {col} is greater than the number of bytes in the line,
		the cursor will be positioned at the last character in the
		line.
		If {col} is zero, the cursor will stay in the current column.
		When 'virtualedit' is used {off} specifies the offset in
		screen columns from the start of the character.  E.g., a
		position within a <Tab> or after the last character.


deepcopy({expr}[, {noref}])				*deepcopy()* *E698*
		Make a copy of {expr}.  For Numbers and Strings this isn't
		different from using {expr} directly.
		When {expr} is a |List| a full copy is created.  This means
		that the original |List| can be changed without changing the
		copy, and vise versa.  When an item is a |List|, a copy for it
		is made, recursively.  Thus changing an item in the copy does
		not change the contents of the original |List|.
		When {noref} is omitted or zero a contained |List| or
		|Dictionary| is only copied once.  All references point to
		this single copy.  With {noref} set to 1 every occurrence of a
		|List| or |Dictionary| results in a new copy.  This also means
		that a cyclic reference causes deepcopy() to fail.
								*E724*
		Nesting is possible up to 100 levels.  When there is an item
		that refers back to a higher level making a deep copy with
		{noref} set to 1 will fail.
		Also see |copy()|.

							*delete()*
delete({fname})	{fname}という名前のファイルを削除する。戻り値は数値で、削除に
		成功したら0、失敗したら1が返る。
		Use |remove()| to delete an item from a |List|.

							*did_filetype()*
did_filetype()	autocommandが実行されFileTypeイベントが一度でも起こっていれ
		ば、非零が返る。スクリプトのFileTypeイベントが、複数回呼び出さ
		れるのを回避するのに使える。 |FileType|

diff_filler({lnum})					*diff_filler()*
		Returns the number of filler lines above line {lnum}.
		These are the lines that were inserted at this point in
		another diff'ed window.  These filler lines are shown in the
		display but don't exist in the buffer.
		{lnum} is used like with |getline()|.  Thus "." is the current
		line, "'m" mark m, etc.
		Returns 0 if the current window is not in diff mode.

diff_hlID({lnum}, {col})				*diff_hlID()*
		Returns the highlight ID for diff mode at line {lnum} column
		{col} (byte index).  When the current line does not have a
		diff change zero is returned.
		{lnum} is used like with |getline()|.  Thus "." is the current
		line, "'m" mark m, etc.
		{col} is 1 for the leftmost column, {lnum} is 1 for the first
		line.
		The highlight ID can be used with |synIDattr()| to obtain
		syntax information about the highlighting.

empty({expr})						*empty()*
		Return the Number 1 if {expr} is empty, zero otherwise.
		A |List| or |Dictionary| is empty when it does not have any
		items.  A Number is empty when its value is zero.
		For a long |List| this is much faster then comparing the
		length with zero.

escape({string}, {chars})				*escape()*
		{string}内に現れる{chars}のキャラクタをバックスラッシュでエス
		ケープする。例:
>			:echo escape('c:\program files\vim', ' \')
		結果:
>			c:\\program\ files\\vim

<							*eval()*
eval({string})	Evaluate {string} and return the result.  Especially useful to
		turn the result of |string()| back into the original value.
		This works for Numbers, Strings and composites of them.
		Also works for |Funcref|s that refer to existing functions.

eventhandler()						*eventhandler()*
		Returns 1 when inside an event handler.  That is that Vim got
		interrupted while waiting for the user to type a character,
		e.g., when dropping a file on Vim.  This means interactive
		commands cannot be used.  Otherwise zero is returned.

executable({expr})					*executable()*
		This function checks if an executable with the name {expr}
		exists.  {expr} must be the name of the program without any
		arguments.
		executable() uses the value of $PATH and/or the normal
		searchpath for programs.		*PATHEXT*
		On MS-DOS and MS-Windows the ".exe", ".bat", etc. can
		optionally be included.  Then the extensions in $PATHEXT are
		tried.  Thus if "foo.exe" does not exist, "foo.exe.bat" can be
		found.  If $PATHEXT is not set then ".exe;.com;.bat;.cmd" is
		used.  A dot by itself can be used in $PATHEXT to try using
		the name without an extension.  When 'shell' looks like a
		Unix shell, then the name is also tried without adding an
		extension.
		On MS-DOS and MS-Windows it only checks if the file exists and
		is not a directory, not if it's really executable.
		On MS-Windows an executable in the same directory as Vim is
		always found.  Since this directory is added to $PATH it
		should also work to execute it |win32-PATH|.
		The result is a Number:
			1	exists
			0	does not exist
			-1	not implemented on this system

							*exists()*
exists({expr})	結果は数値で、変数{expr}が存在すれば1となり、そうでなければ0と
		なる。引数{expr}は文字列で次のうちいずれかである。
			&option-name	Vimオプション
			$ENVNAME	環境変数(空文字列と比較することで、判
					定が成される)
			*funcname	組み込み関数(|functions|参照)かユーザ
					が定義した関数(|user-functions|参照)
			varname		内部変数(|internal-variables|)
					Also works
					for |curly-braces-names|, |Dictionary|
					entries, |List| items, etc.  Beware
					that this may cause functions to be
					invoked cause an error message for an
					invalid expression.  
			:cmdname	Ex command: built-in command, user
					command or command modifier |:command|.
					Returns:
					1  for match with start of a command
					2  full match with a command
					3  matches several user commands
					To check for a supported command
					always check the return value to be 2.
			:2match		The |:2match| command.
			:3match		The |:3match| command.
			#event		autocommand defined for this event
			#event#pattern	autocommand defined for this event and
					pattern (the pattern is taken
					literally and compared to the
					autocommand patterns character by
					character)
			#group		autocommand group exists
			#group#event	autocommand defined for this group and
					event.
			#group#event#pattern
					autocommand defined for this group,
					event and pattern.
			##event		autocommand for this event is
					supported.
		For checking for a supported feature use |has()|.

		例:
			exists("&shortname")
			exists("$HOSTNAME")
			exists("*strftime")
			exists("*s:MyFunc")
			exists("bufcount")
			exists(":Make")
			exists("#CursorHold")
			exists("#BufReadPre#*.gz")
			exists("#filetypeindent")
			exists("#filetypeindent#FileType")
			exists("#filetypeindent#FileType#*")
			exists("##ColorScheme")
		シンボルである&/$/*と名前の間には、空白文字があってはならな
		い。That may become more strict in
		the future, thus don't count on it!
		Working example: >
			exists(":make")
<		NOT working example: >
			exists(":make install")

<		Note that the argument must be a string, not the name of the
		variable itself.  For example: >
			exists(bufcount)
<		This doesn't check for existence of the "bufcount" variable,
		but gets the value of "bufcount", and checks if that exists.

							*expand()*
expand({expr} [, {flag}])
		ワイルドカードと{expr}内の特殊なキーワードを展開する。戻り値は
		文字列。

		複数の候補があった場合、それらは文字<NL>で区切られる。[注意:
		バージョン5.0では空白文字が用いられ、スペースを含むファイル名
		について問題を引き起こしていた]

		展開が失敗した場合、結果は空文字列となる。また存在しないファイ
		ル名というのは、結果の文字列には含まれない。

		{expr}が'%'か'#'か'<'で始まる場合には、展開は|cmdline-special|
		のように、変換子を受け付け、それらに関連付けられた変換が施され
		る。ここに簡単な概略を示す:

			%		現在のファイル名
			#		裏バッファのファイル名
			#n		n番の裏バッファのファイル名
			<cfile>		カーソルのしたのファイル名
			<afile>		autocmdのファイル名
			<abuf>		autocmdのバッファ名
			<sfile>		取り込み(source)中のファイル名
			<cword>		カーソル下の単語(word)
			<cWORD>		カーソル下の単語(WORD)
		変換子:
			:p		フルパス名を展開
			:h		ヘッド(ディレクトリ)
			:t		テイル(ファイル名だけ)
			:r		拡張子が削除される
			:e		拡張子だけ

		例:
>			:let &tags = expand("%:p:h") . "/tags"
		'%'や'#'や'<'で始まる文字列を展開する時には、それに続くテキス
		トは無視されることに注意。従ってこれは正しくない:
>			:let doesntwork = expand("%:h.bak")
		こうすると良い:
>			:let doeswork = expand("%:h") . ".bak"
		"<cfile>"やそれらを展開する時には、戻り値が完全な展開をされな
		い参照名であることにも注意が必要。もしも"<cfile>"が"~/.cshrc"
		であった場合、"~/"を展開してホームディレクトリにするために、も
		う一度expand()を呼び出す必要がある:
>			:echo expand(expand("<cfile>"))

		変数と変換子の間には空白文字があってはならない。関数
		|fnamemodify()|が通常のファイル名の変換には使用可能である。

		'%'や'#'を名前が未定義の現在や裏バッファのファイルに適用した場
		合、空文字列が使用される。"%:p"を名無しのバッファに使用した場
		合、結果はカレントディレクトリに'/'が付加されたものになる。

		'%'や'#'や'<'で始まらない{expr}は、コマンドラインのファイル名
		と同じように展開される。オプションの{flag}が使用され、その値が
		非ゼロでない時以外は'suffixes'と'wildignore'が使用される。
		The "**" item can be used to
		search in a directory tree.  For example, to find all "README"
		files in the current directory and below: >
			:echo expand("**/README")
< 
		Expand()は、シェルの持っている変数や環境変数を展開することがで
		きる。しかしシェルが起動されなければならないので、遅くなる。
		|expr-env-expand|を参照。

		存在するファイルを探すには|glob()|を参照。外部コマンドの「生
		の」実行結果を扱うには|system()|を参照。

extend({expr1}, {expr2} [, {expr3}])			*extend()*
		{expr1} and {expr2} must be both |Lists| or both
		|Dictionaries|.

		If they are |Lists|: Append {expr2} to {expr1}.
		If {expr3} is given insert the items of {expr2} before item
		{expr3} in {expr1}.  When {expr3} is zero insert before the
		first item.  When {expr3} is equal to len({expr1}) then
		{expr2} is appended.
		Examples: >
			:echo sort(extend(mylist, [7, 5]))
			:call extend(mylist, [2, 3], 1)
<		Use |add()| to concatenate one item to a list.  To concatenate
		two lists into a new list use the + operator: >
			:let newlist = [1, 2, 3] + [4, 5]
<
		If they are |Dictionaries|:
		Add all entries from {expr2} to {expr1}.
		If a key exists in both {expr1} and {expr2} then {expr3} is
		used to decide what to do:
		{expr3} = "keep": keep the value of {expr1}
		{expr3} = "force": use the value of {expr2}
		{expr3} = "error": give an error message		*E737*
		When {expr3} is omitted then "force" is assumed.

		{expr1} is changed when {expr2} is not empty.  If necessary
		make a copy of {expr1} first.
		{expr2} remains unchanged.
		Returns {expr1}.


feedkeys({string} [, {mode}])				*feedkeys()*
		Characters in {string} are queued for processing as if they
		come from a mapping or were typed by the user.  They are added
		to the end of the typeahead buffer, thus if a mapping is still
		being executed these characters come after them.
		The function does not wait for processing of keys contained in
		{string}.
		To include special keys into {string}, use double-quotes
		and "\..." notation |expr-quote|. For example,
		feedkeys("\<CR>") simulates pressing of the <Enter> key. But
		feedkeys('\<CR>') pushes 5 characters.
		If {mode} is absent, keys are remapped.
		{mode} is a String, which can contain these character flags:
		'm'	Remap keys. This is default.
		'n'	Do not remap keys.
		't'	Handle keys as if typed; otherwise they are handled as
			if coming from a mapping.  This matters for undo,
			opening folds, etc.
		Return value is always 0.

							*filereadable()*
filereadable({file})
		結果は数値で、{file}というファイルが存在し、読みこむことが可能
		ならばTRUEとなる。ファイル{file}が存在しないかディレクトリだっ
		た場合には、結果はFALSEとなる。引数{file}は文字列として使えれ
		ばどのような表現でもよい。
		If you don't care about the file being readable you can use
		|glob()|.
							*file_readable()*
		以前の名前: file_readable().

filewritable({file})					*filewritable()*
		The result is a Number, which is 1 when a file with the
		name {file} exists, and can be written.  If {file} doesn't
		exist, or is not writable, the result is 0.  If (file) is a
		directory, and we can write to it, the result is 2.


filter({expr}, {string})					*filter()*
		{expr} must be a |List| or a |Dictionary|.
		For each item in {expr} evaluate {string} and when the result
		is zero remove the item from the |List| or |Dictionary|.
		Inside {string} |v:val| has the value of the current item.
		For a |Dictionary| |v:key| has the key of the current item.
		Examples: >
			:call filter(mylist, 'v:val !~ "OLD"')
<		Removes the items where "OLD" appears. >
			:call filter(mydict, 'v:key >= 8')
<		Removes the items with a key below 8. >
			:call filter(var, 0)
<		Removes all the items, thus clears the |List| or |Dictionary|.

		Note that {string} is the result of expression and is then
		used as an expression again.  Often it is good to use a
		|literal-string| to avoid having to double backslashes.

		The operation is done in-place.  If you want a |List| or
		|Dictionary| to remain unmodified make a copy first: >
			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')

<		Returns {expr}, the |List| or |Dictionary| that was filtered.
		When an error is encountered while evaluating {string} no
		further items in {expr} are processed.


finddir({name}[, {path}[, {count}]])				*finddir()*
		Find directory {name} in {path}.  Supports both downwards and
		upwards recursive directory searches.  See |file-searching|
		for the syntax of {path}.
		Returns the path of the first found match.  When the found
		directory is below the current directory a relative path is
		returned.  Otherwise a full path is returned.
		If {path} is omitted or empty then 'path' is used.
		If the optional {count} is given, find {count}'s occurrence of
		{name} in {path} instead of the first one.
		When {count} is negative return all the matches in a |List|.
		This is quite similar to the ex-command |:find|.
		{only available when compiled with the +file_in_path feature}

findfile({name}[, {path}[, {count}]])				*findfile()*
		Just like |finddir()|, but find a file instead of a directory.
		Uses 'suffixesadd'.
		Example: >
			:echo findfile("tags.vim", ".;")
<		Searches from the directory of the current file upwards until
		it finds the file "tags.vim".

							*fnamemodify()*
fnamemodify({fname}, {mods})
		ファイル名{fname}を{mods}にしたがって変更する。{mods}はコマン
		ドラインで使われるのと同様な文字列である。詳細は
		|filename-modifiers|を参照。
		例:
>			:echo fnamemodify("main.c", ":p:h")
		結果:
>			/home/mool/vim/vim/src/
<		Note: Environment variables and "~" don't work in {fname}, use
		|expand()| first then.


foldclosed({lnum})					*foldclosed()*
		The result is a Number.  If the line {lnum} is in a closed
		fold, the result is the number of the first line in that fold.
		If the line {lnum} is not in a closed fold, -1 is returned.

foldclosedend({lnum})					*foldclosedend()*
		The result is a Number.  If the line {lnum} is in a closed
		fold, the result is the number of the last line in that fold.
		If the line {lnum} is not in a closed fold, -1 is returned.

foldlevel({lnum})					*foldlevel()*
		The result is a Number, which is the foldlevel of line {lnum}
		in the current buffer.  For nested folds the deepest level is
		returned.  If there is no fold at line {lnum}, zero is
		returned.  It doesn't matter if the folds are open or closed.
		When used while updating folds (from 'foldexpr') -1 is
		returned for lines where folds are still to be updated and the
		foldlevel is unknown.  As a special case the level of the
		previous line is usually available.

							*foldtext()*
foldtext()	Returns a String, to be displayed for a closed fold.  This is
		the default function used for the 'foldtext' option and should
		only be called from evaluating 'foldtext'.  It uses the
		|v:foldstart|, |v:foldend| and |v:folddashes| variables.
		The returned string looks like this: >
			+-- 45 lines: abcdef
<		The number of dashes depends on the foldlevel.  The "45" is
		the number of lines in the fold.  "abcdef" is the text in the
		first non-blank line of the fold.  Leading white space, "//"
		or "/*" and the text from the 'foldmarker' and 'commentstring'
		options is removed.
		{not available when compiled without the |+folding| feature}

foldtextresult({lnum})					*foldtextresult()*
		Returns the text that is displayed for the closed fold at line
		{lnum}.  Evaluates 'foldtext' in the appropriate context.
		When there is no closed fold at {lnum} an empty string is
		returned.
		{lnum} is used like with |getline()|.  Thus "." is the current
		line, "'m" mark m, etc.
		Useful when exporting folded text, e.g., to HTML.
		{not available when compiled without the |+folding| feature}

							*foreground()*
foreground()	Move the Vim window to the foreground.  Useful when sent from
		a client to a Vim server. |remote_send()|
		On Win32 systems this might not work, the OS does not always
		allow a window to bring itself to the foreground.  Use
		|remote_foreground()| instead.
		{only in the Win32, Athena, Motif and GTK GUI versions and the
		Win32 console version}


function({name})					*function()* *E700*
		Return a |Funcref| variable that refers to function {name}.
		{name} can be a user defined function or an internal function.


garbagecollect()					*garbagecollect()*
		Cleanup unused |Lists| and |Dictionaries| that have circular
		references.  There is hardly ever a need to invoke this
		function, as it is automatically done when Vim runs out of
		memory or is waiting for the user to press a key after
		'updatetime'.  Items without circular references are always
		freed when they become unused.
		This is useful if you have deleted a very big |List| and/or
		|Dictionary| with circular references in a script that runs
		for a long time.

get({list}, {idx} [, {default}])			*get()*
		Get item {idx} from |List| {list}.  When this item is not
		available return {default}.  Return zero when {default} is
		omitted.
get({dict}, {key} [, {default}])
		Get item with key {key} from |Dictionary| {dict}.  When this
		item is not available return {default}.  Return zero when
		{default} is omitted.

							*getbufline()*
getbufline({expr}, {lnum} [, {end}])
		Return a |List| with the lines starting from {lnum} to {end}
		(inclusive) in the buffer {expr}.  If {end} is omitted, a
		|List| with only the line {lnum} is returned.

		For the use of {expr}, see |bufname()| above.

		For {lnum} and {end} "$" can be used for the last line of the
		buffer.  Otherwise a number must be used.

		When {lnum} is smaller than 1 or bigger than the number of
		lines in the buffer, an empty |List| is returned.

		When {end} is greater than the number of lines in the buffer,
		it is treated as {end} is set to the number of lines in the
		buffer.  When {end} is before {lnum} an empty |List| is
		returned.

		This function works only for loaded buffers.  For unloaded and
		non-existing buffers, an empty |List| is returned.

		Example: >
			:let lines = getbufline(bufnr("myfile"), 1, "$")

getbufvar({expr}, {varname})				*getbufvar()*
		The result is the value of option or local buffer variable
		{varname} in buffer {expr}.  Note that the name without "b:"
		must be used.
		This also works for a global or buffer-local option, but it
		doesn't work for a global variable, window-local variable or
		window-local option.
		For the use of {expr}, see |bufname()| above.
		When the buffer or variable doesn't exist an empty string is
		returned, there is no error message.
		Examples: >
			:let bufmodified = getbufvar(1, "&mod")
			:echo "todo myvar = " . getbufvar("todo", "myvar")
<
getchar([expr])						*getchar()*
		Get a single character from the user or input stream.
		If [expr] is omitted, wait until a character is available.
		If [expr] is 0, only get a character when one is available.
			Return zero otherwise.
		If [expr] is 1, only check if a character is available, it is
			not consumed.  Return zero if no character available.

		Without {expr} and when {expr} is 0 a whole character or
		special key is returned.  If it is an 8-bit character, the
		result is a number.  Use nr2char() to convert it to a String.
		Otherwise a String is returned with the encoded character.
		For a special key it's a sequence of bytes starting with 0x80
		(decimal: 128).  This is the same value as the string
		"\<Key>", e.g., "\<Left>".  The returned value is also a
		String when a modifier (shift, control, alt) was used that is
		not included in the character.

		When {expr} is 1 only the first byte is returned.  For a
		one-byte character it is the character itself as a number.
		Use nr2char() to convert it to a String.

		When the user clicks a mouse button, the mouse event will be
		returned.  The position can then be found in |v:mouse_col|,
		|v:mouse_lnum| and |v:mouse_win|.  This example positions the
		mouse as it would normally happen: >
			let c = getchar()
		  	if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win . "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " . v:mouse_col . "|"
			endif
<
		There is no prompt, you will somehow have to make clear to the
		user that a character has to be typed.
		There is no mapping for the character.
		Key codes are replaced, thus when the user presses the <Del>
		key you get the code for the <Del> key, not the raw character
		sequence.  Examples: >
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<		This example redefines "f" to ignore case: >
			:nmap f :call FindChar()<CR>
			:function FindChar()
			:  let c = nr2char(getchar())
			:  while col('.') < col('$') - 1
			:    normal l
			:    if getline('.')[col('.') - 1] ==? c
			:      break
			:    endif
			:  endwhile
			:endfunction

getcharmod()						*getcharmod()*
		The result is a Number which is the state of the modifiers for
		the last obtained character with getchar() or in another way.
		These values are added together:
			2	shift
			4	control
			8	alt (meta)
			16	mouse double click
			32	mouse triple click
			64	mouse quadruple click
			128	Macintosh only: command
		Only the modifiers that have not been included in the
		character itself are obtained.  Thus Shift-a results in "A"
		with no modifier.

getcmdline()						*getcmdline()*
		Return the current command-line.  Only works when the command
		line is being edited, thus requires use of |c_CTRL-\_e| or
		|c_CTRL-R_=|.
		Example: >
			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<		Also see |getcmdtype()|, |getcmdpos()| and |setcmdpos()|.

getcmdpos()						*getcmdpos()*
		Return the position of the cursor in the command line as a
		byte count.  The first column is 1.
		Only works when editing the command line, thus requires use of
		|c_CTRL-\_e| or |c_CTRL-R_=|.  Returns 0 otherwise.
		Also see |getcmdtype()|, |setcmdpos()| and |getcmdline()|.

getcmdtype()						*getcmdtype()*
		Return the current command-line type. Possible return values
		are:
		    :	normal Ex command
		    >	debug mode command |debug-mode|
		    /	forward search command
		    ?	backward search command
		    @	|input()| command
		    -	|:insert| or |:append| command
		Only works when editing the command line, thus requires use of
		|c_CTRL-\_e| or |c_CTRL-R_=|.  Returns an empty string
		otherwise.
		Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.

							*getcwd()*
getcwd()	結果は文字列で、現在のディレクトリ名。

getfsize({fname})					*getfsize()*
		The result is a Number, which is the size in bytes of the
		given file {fname}.
		If {fname} is a directory, 0 is returned.
		If the file {fname} can't be found, -1 is returned.

getfontname([{name}])					*getfontname()*
		Without an argument returns the name of the normal font being
		used.  Like what is used for the Normal highlight group
		|hl-Normal|.
		With an argument a check is done whether {name} is a valid
		font name.  If not then an empty string is returned.
		Otherwise the actual font name is returned, or {name} if the
		GUI does not support obtaining the real name.
		Only works when the GUI is running, thus not in your vimrc or
		gvimrc file.  Use the |GUIEnter| autocommand to use this
		function just after the GUI has started.
		Note that the GTK 2 GUI accepts any font name, thus checking
		for a valid name does not work.

getfperm({fname})					*getfperm()*
		The result is a String, which is the read, write, and execute
		permissions of the given file {fname}.
		If {fname} does not exist or its directory cannot be read, an
		empty string is returned.
		The result is of the form "rwxrwxrwx", where each group of
		"rwx" flags represent, in turn, the permissions of the owner
		of the file, the group the file belongs to, and other users.
		If a user does not have a given permission the flag for this
		is replaced with the string "-".  Example: >
			:echo getfperm("/etc/passwd")
<		This will hopefully (from a security point of view) display
		the string "rw-r--r--" or even "rw-------".

							*getftime()*
getftime({fname})
		結果は{fname}で与えられたファイルの、最終更新時間を示す数値。
		1970年1月1日からの経過時間(病)で、strftime()に渡すことができる
		だろう。|localtime()|と|strftime()|も参照。
		ファイル{fname}が見つからなかった場合には-1を返す。

getftype({fname})					*getftype()*
		The result is a String, which is a description of the kind of
		file of the given file {fname}.
		If {fname} does not exist an empty string is returned.
		Here is a table over different kinds of files and their
		results:
			Normal file		"file"
			Directory		"dir"
			Symbolic link		"link"
			Block device		"bdev"
			Character device	"cdev"
			Socket			"socket"
			FIFO			"fifo"
			All other		"other"
		Example: >
			getftype("/home")
<		Note that a type such as "link" will only be returned on
		systems that support it.  On some systems only "dir" and
		"file" are returned.

							*getline()*
getline({lnum} [, {end}])
		結果は現在のバッファの{lnum}行目の内容(文字列)。例:
>			getline(1)
		{lnum}が数字ではない文字で始まる文字列であった場合、line()に
		よってその文字列が数字に変換される。よって、カーソルのある行の
		文字列を取得するには:
>			getline(".")
		{lnum}が1より小さいかバッファの行数よりも大きい数値の場合、空
		文字列が返される。

		When {end} is given the result is a |List| where each item is
		a line from the current buffer in the range {lnum} to {end},
		including line {end}.
		{end} is used in the same way as {lnum}.
		Non-existing lines are silently omitted.
		When {end} is before {lnum} an empty |List| is returned.
		Example: >
			:let start = line('.')
			:let end = search("^$") - 1
			:let lines = getline(start, end)

<		To get lines from another buffer see |getbufline()|

getloclist({nr})					*getloclist()*
		Returns a list with all the entries in the location list for
		window {nr}. When {nr} is zero the current window is used.
		For a location list window, the displayed location list is
		returned.  For an invalid window number {nr}, an empty list is
		returned. Otherwise, same as getqflist().

getqflist()						*getqflist()*
		Returns a list with all the current quickfix errors.  Each
		list item is a dictionary with these entries:
			bufnr	number of buffer that has the file name, use
				bufname() to get the name
			lnum	line number in the buffer (first line is 1)
			col	column number (first column is 1)
			vcol	non-zero: "col" is visual column
				zero: "col" is byte index
			nr	error number
			pattern	search pattern used to locate the error
			text	description of the error
			type	type of the error, 'E', '1', etc.
			valid	non-zero: recognized error message

		When there is no error list or it's empty an empty list is
		returned. Quickfix list entries with non-existing buffer
		number are returned with "bufnr" set to zero.

		Useful application: Find pattern matches in multiple files and
		do something with them: >
			:vimgrep /theword/jg *.c
			:for d in getqflist()
			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
			:endfor

getreg([{regname} [, 1]])				*getreg()*
		The result is a String, which is the contents of register
		{regname}.  Example: >
			:let cliptext = getreg('*')
<		getreg('=') returns the last evaluated value of the expression
		register.  (For use in maps.)
		getreg('=', 1) returns the expression itself, so that it can
		be restored with |setreg()|.  For other registers the extra
		argument is ignored, thus you can always give it.
		If {regname} is not specified, |v:register| is used.


getregtype([{regname}])					*getregtype()*
		The result is a String, which is type of register {regname}.
		The value will be one of:
		    "v"			for |characterwise| text
		    "V"			for |linewise| text
		    "<CTRL-V>{width}"	for |blockwise-visual| text
		    0			for an empty or unknown register
		<CTRL-V> is one character with value 0x16.
		If {regname} is not specified, |v:register| is used.

gettabwinvar({tabnr}, {winnr}, {varname})		*gettabwinvar()*
		Get the value of window-local variable {varname} in window
		{winnr} in tab page {tabnr}.
		When {varname} starts with "&" get the value of a window-local
		option.
		Tabs are numbered starting with one.  For the current tabpage
		use |getwinvar()|.
		When {winnr} is zero the current window is used.
		This also works for a global option, buffer-local option and
		window-local option, but it doesn't work for a global variable
		or buffer-local variable.
		When {varname} is empty a dictionary with all window-local
		variables is returned.
		Note that {varname} must be the name without "w:".
		Examples: >
			:let list_is_on = gettabwinvar(1, 2, '&list')
			:echo "myvar = " . gettabwinvar(3, 1, 'myvar')
<

							*getwinposx()*
getwinposx()	結果はGUIのVimウィンドウの左端の、デスクトップ上でのX座標値(数
		値)。情報が存在しない(コンソールの)場合は-1となる。

							*getwinposy()*
getwinposy()	結果はGUIのVimウィンドウの上端の、デスクトップ上でのY座標値(数
		値)。情報が存在しない(コンソールの)場合は-1となる。

getwinvar({winnr}, {varname})				*getwinvar()*
		Like |gettabwinvar()| for the current tabpage.
		Examples: >
			:let list_is_on = getwinvar(2, '&list')
			:echo "myvar = " . getwinvar(1, 'myvar')

							*glob()*
glob({expr})	Expand the file wildcards in {expr}.  See |wildcards| for the
		use of special characters.
		The result is a String.
		{expr}内のファイル名のワイルドカードを展開する。結果は文字列。
		結果が複数存在する場合、各々が文字<NL>によって区切られる。
		展開が失敗した場合、結果は空文字列。結果には、存在しないファイ
		ル名は含まれない。

		多くのシステムではbackticks(「`」という文字のこと)を、外部コマ
		ンドの実行結果からファイル名を取得するために使用できる。例:
>			:let tagfiles = glob("`find . -name tags -print`")
>			:let &tags = substitute(tagfiles, "\n", ",", "g")
		backticks内のプログラムの実行結果は、一行に一つずつの項目が含
		まれてなければならない。項目内のスペースは許容される。
		
		特殊なVimの変数を展開するためには|expand()|を参照。外部コマン
		ドの生の出力を得るためには|system()|を参照。

globpath({path}, {expr})				*globpath()*
		Perform glob() on all directories in {path} and concatenate
		the results.  Example: >
			:echo globpath(&rtp, "syntax/c.vim")
<		{path} is a comma-separated list of directory names.  Each
		directory name is prepended to {expr} and expanded like with
		glob().  A path separator is inserted when needed.
		To add a comma inside a directory name escape it with a
		backslash.  Note that on MS-Windows a directory may have a
		trailing backslash, remove it if you put a comma after it.
		If the expansion fails for one of the directories, there is no
		error message.
		The 'wildignore' option applies: Names matching one of the
		patterns in 'wildignore' will be skipped.

		The "**" item can be used to search in a directory tree.
		For example, to find all "README.txt" files in the directories
		in 'runtimepath' and below: >
			:echo globpath(&rtp, "**/README.txt")
<
							*has()*
has({feature})	結果は機能{feature}がサポートされる場合1、されない場合0とな
		る。引数{feature}は文字列。下記の|feature-list|を参照。

has_key({dict}, {key})					*has_key()*
		The result is a Number, which is 1 if |Dictionary| {dict} has
		an entry with key {key}.  Zero otherwise.

haslocaldir()						*haslocaldir()*
		The result is a Number, which is 1 when the current
                window has set a local path via |:lcd|, and 0 otherwise.

hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
		The result is a Number, which is 1 if there is a mapping that
		contains {what} in somewhere in the rhs (what it is mapped to)
		and this mapping exists in one of the modes indicated by
		{mode}.
		When {abbr} is there and it is non-zero use abbreviations
		instead of mappings.  Don't forget to specify Insert and/or
		Command-line mode.
		Both the global mappings and the mappings local to the current
		buffer are checked for a match.
		If no matching mapping is found 0 is returned.
		The following characters are recognized in {mode}:
			n	Normal mode
			v	Visual mode
			o	Operator-pending mode
			i	Insert mode
			l	Language-Argument ("r", "f", "t", etc.)
			c	Command-line mode
		When {mode} is omitted, "nvo" is used.

		This function is useful to check if a mapping already exists
		to a function in a Vim script.  Example: >
			:if !hasmapto('\ABCdoit')
			:   map <Leader>d \ABCdoit
			:endif
<		This installs the mapping to "\ABCdoit" only if there isn't
		already a mapping to "\ABCdoit".
							*histadd()*
histadd({history}, {item})
		文字列{item}を履歴{history}に追加する。履歴{history}は以下のう
		ちどれか一つから選択:			*hist-names*
			"cmd"	 or ":"	  コマンドライン履歴
			"search" or "/"   検索パターン履歴
			"expr"   or "="   タイプされた表現の履歴
			"input"  or "@"	  input()の履歴
		{item}が履歴内に既に存在する場合、それが最新の項目の位置へシフ
		トされる。結果は数値:操作が成功した場合1、そうでなければ0

		例:
>			:call histadd("input", strftime("%Y %b %d"))
>			:let date=input("Enter date: ")

							*histdel()*
histdel({history} [, {item}])
		{history}の内容を削除する。例えば総てのエントリを消すこともで
		きる。{history}の部分に可能な値は|hist-names|を参照。

		パラメータ{item}が文字列として与えられた場合、これは正規表現と
		して扱われる。その表現にマッチする総てのエントリがhistoryから
		削除される(複数あっても)。
		{item}が数値ならば、インデックスとして解釈される。インデックス
		については|:history-indexing|を参照。関連するエントリ(訳注:The
		respective entry)も、存在すれば削除される。

		結果は数値: 削除に成功すれば1を、そうでなければ0が返る。

		例:
		式レジスタの履歴を削除する:
>			:call histdel("expr")

		検索履歴から、"*"で始まるエントリを総て削除する:
>			:call histdel("/", '^\*')

		次の3つは等価である:
>			:call histdel("search", histnr("search"))
>			:call histdel("search", -1)
>			:call histdel("search", '^'.histget("search", -1).'$')

		最後の検索パターンを削除し、一つ前のパターンを"n"コマンド(次の
		マッチへ移動)と'hlsearch'の為に設定する:
>			:call histdel("search", -1)
>			:let @/ = histget("search", -1)


							*histget()*
histget({history} [, {index}])
		結果は{history}の第{index}エントリーを表わす文字列。{history}
		の部分に可能な値は|hist-names|を、{index}については
		|:history-indexing|を参照。指定されたエントリが存在しない場合
		は空文字列が返される。{index}が省略された場合には、履歴中の最
		新のエントリが戻り値として使用される。

		例:
			2つ前に行なわれた検索をやり直す:
>			:execute '/' . histget("search", -2)

			|:history|によって出力される{num}番目のエントリを、再
			度実行するための":H {num}"というコマンドを定義する。
>			:command -nargs=1 H execute histget("cmd",0+<args>)

							*histnr()*
histnr({history})
		結果は数値で{history}の現在のエントリー数。{history}の部分に可
		能な値は|hist-names|を参照。エラーが起こった場合、-1が返され
		る。

		例:
>			:let inp_index = histnr("expr")

							*hlexists()*
hlexists({name})
		結果は数値で、{name}という名のハイライトグループが存在すれば、
		非ゼロの値が返される。これはなんらかの方法でそのグループが既に
		定義されている時にのみ起こる。これの為に実際に何らかのハイライ
		ティングアイテムが設定されている必要はなく、単にシンタックスの
		アイテムとしても使われるだろう。
							*highlight_exists()*
		以前の名前: highlight_exists().

							*hlID()*
hlID({name})	結果は数値で、{name}という名前のハイライトグループのID番号。そ
		のハイライトグループが存在しない場合は0が返される。
		これはハイライトグループについての情報を獲得するために使用され
		る。例えば"Comment"グループの背景色を取得するにはこのようにす
		る:
>	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")
							*highlightID()*
		以前の名前: highlightID()

							*hostname()*
hostname()
		結果は文字列で、現在Vimが実行されているマシンの名前。名前が256
		文字を超える場合、超えた部分は切り捨てられる。

iconv({expr}, {from}, {to})				*iconv()*
		The result is a String, which is the text {expr} converted
		from encoding {from} to encoding {to}.
		When the conversion fails an empty string is returned.
		The encoding names are whatever the iconv() library function
		can accept, see ":!man 3 iconv".
		Most conversions require Vim to be compiled with the |+iconv|
		feature.  Otherwise only UTF-8 to latin1 conversion and back
		can be done.
		This can be used to display messages with special characters,
		no matter what 'encoding' is set to.  Write the message in
		UTF-8 and use: >
			echo iconv(utf8_str, "utf-8", &enc)
<		Note that Vim uses UTF-8 for all Unicode encodings, conversion
		from/to UCS-2 is automatically changed to use UTF-8.  You
		cannot use UCS-2 in a string anyway, because of the NUL bytes.
		{only available when compiled with the +multi_byte feature}

							*indent()*
indent({lnum})	The result is a Number, which is indent of line {lnum} in the
		current buffer.  The indent is counted in spaces, the value
		of 'tabstop' is relevant.  {lnum} is used just like in
		|getline()|.
		When {lnum} is invalid -1 is returned.


index({list}, {expr} [, {start} [, {ic}]])			*index()*
		Return the lowest index in |List| {list} where the item has a
		value equal to {expr}.
		If {start} is given then start looking at the item with index
		{start} (may be negative for an item relative to the end).
		When {ic} is given and it is non-zero, ignore case.  Otherwise
		case must match.
		-1 is returned when {expr} is not found in {list}.
		Example: >
			:let idx = index(words, "the")
			:if index(numbers, 123) >= 0


input({prompt} [, {text} [, {completion}]])		*input()*
		結果は文字列で、ユーザがコマンドラインに入力したものが返され
		る。引数はプロンプト用文字列であり、プロンプトが必要なければ空
		文字列でかまわない。新しい行から入力させるために'\n'をプロンプ
		トに使用することができる。ハイライトセット|:echohl|はプロンプ
		トにも適用される。入力はコマンドラインと同様に行え、幾つかの編
		集コマンドやキーマップもそのまま使用できる。input()に入力され
		た文字列には、他の履歴とは独立した履歴が与えられる。
		NOTE: この関数はGUIモードしか持たないバージョン(例、Win32 GUI)
		のVimでは、スタートアップファイルの中で使用することはできな
		い。

		例:
>	:if input("Coffee or beer? ") == "beer"
>	:  echo "Cheers!"
>	:endif

inputlist({textlist})					*inputlist()*
		{textlist} must be a |List| of strings.  This |List| is
		displayed, one string per line.  The user will be prompted to
		enter a number, which is returned.
		The user can also select an item by clicking on it with the
		mouse.  For the first string 0 is returned.  When clicking
		above the first item a negative number is returned.  When
		clicking on the prompt one more than the length of {textlist}
		is returned.
		Make sure {textlist} has less then 'lines' entries, otherwise
		it won't work.  It's a good idea to put the entry number at
		the start of the string.  And put a prompt in the first item.
		Example: >
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])

inputrestore()						*inputrestore()*
		Restore typeahead that was saved with a previous inputsave().
		Should be called the same number of times inputsave() is
		called.  Calling it more often is harmless though.
		Returns 1 when there is nothing to restore, 0 otherwise.

inputsave()						*inputsave()*
		Preserve typeahead (also from mappings) and clear it, so that
		a following prompt gets input from the user.  Should be
		followed by a matching inputrestore() after the prompt.  Can
		be used several times, in which case there must be just as
		many inputrestore() calls.
		Returns 1 when out of memory, 0 otherwise.

inputsecret({prompt} [, {text}])			*inputsecret()*
		This function acts much like the |input()| function with but
		two exceptions:
		a) the user's response will be displayed as a sequence of
		asterisks ("*") thereby keeping the entry secret, and
		b) the user's response will not be recorded on the input
		|history| stack.
		The result is a String, which is whatever the user actually
		typed on the command-line in response to the issued prompt.
		NOTE: Command-line completion is not supported.

insert({list}, {item} [, {idx}])			*insert()*
		Insert {item} at the start of |List| {list}.
		If {idx} is specified insert {item} before the item with index
		{idx}.  If {idx} is zero it goes before the first item, just
		like omitting {idx}.  A negative {idx} is also possible, see
		|list-index|.  -1 inserts just before the last item.
		Returns the resulting |List|.  Examples: >
			:let mylist = insert([2, 3, 5], 1)
			:call insert(mylist, 4, -1)
			:call insert(mylist, 6, len(mylist))
<		The last example can be done simpler with |add()|.
		Note that when {item} is a |List| it is inserted as a single
		item.  Use |extend()| to concatenate |Lists|.

							*isdirectory()*
isdirectory({directory})
		結果は数値で、{directory}という名前のディレクトリが存在すれば
		TRUEとなる。{directory}が存在しないか、存在したとしてもディレ
		クトリではなかった場合には、FALSEが返される。文字列として解釈
		できるのならば{directory}の表現はどのようなものであってもかま
		わない。

islocked({expr})					*islocked()* *E786*
		The result is a Number, which is non-zero when {expr} is the
		name of a locked variable.
		{expr} must be the name of a variable, |List| item or
		|Dictionary| entry, not the variable itself!  Example: >
			:let alist = [0, ['a', 'b'], 2, 3]
			:lockvar 1 alist
			:echo islocked('alist')		" 1
			:echo islocked('alist[1]')	" 0

<		When {expr} is a variable that does not exist you get an error
		message.  Use |exists()| to check for existence.

items({dict})						*items()*
		Return a |List| with all the key-value pairs of {dict}.  Each
		|List| item is a list with two items: the key of a {dict}
		entry and the value of this entry.  The |List| is in arbitrary
		order.


join({list} [, {sep}])					*join()*
		Join the items in {list} together into one String.
		When {sep} is specified it is put in between the items.  If
		{sep} is omitted a single space is used.
		Note that {sep} is not added at the end.  You might want to
		add it there too: >
			let lines = join(mylist, "\n") . "\n"
<		String items are used as-is.  |Lists| and |Dictionaries| are
		converted into a string like with |string()|.
		The opposite function is |split()|.

keys({dict})						*keys()*
		Return a |List| with all the keys of {dict}.  The |List| is in
		arbitrary order.

							*len()* *E701*
len({expr})	The result is a Number, which is the length of the argument.
		When {expr} is a String or a Number the length in bytes is
		used, as with |strlen()|.
		When {expr} is a |List| the number of items in the |List| is
		returned.
		When {expr} is a |Dictionary| the number of entries in the
		|Dictionary| is returned.
		Otherwise an error is given.

							*libcall()*
libcall({libname}, {funcname}, {argument})
		ランタイムライブラリ{libname}の関数{funcname}を、引数
		{argument}として呼び出す。結果には、呼び出した関数から返された
		文字列が返される。もしも引数が数値ならば、関数にはint型の引数
		が1つ渡される。引数が文字列の場合には、関数にはヌル終端記号を
		持つ文字列が引数として渡される。呼び出した関数がNULLを返した場
		合には、Vimには空文字列""が戻される。

		libcall()によってVimを最コンパイルすることなく'plug-in'と呼ば
		れる独自の拡張を行なうことができる用になる。それは(直接)システ
		ムの関数を呼ぶ、ということではない。システム関数を呼んだらVim
		がクラッシュするかもしれない。

		Win32では、あなたが書いた関数をDLLに置かなければならず、また通
		常のC呼出し規約を使用しなければならない(WindowsのシステムDLLが
		使うPascalではない)。関数は正確に1つのパラメータ、char型ポイン
		タもしくはint型を取らなければならず、戻り値としてchar型ポイン
		タかNULLを返さなければならない。返されるchar型ポインタは、関数
		終了後も有効なポインタ(例えばDLL内の静的なデータ)を指さなけれ
		ばならない。(malloc等で)割り当てられたメモリを保持していた場
		合、それはリークしてしまう。DLL内のスタティックバッファを用い
		る方法は動くかもしれないが、使用済みDLLがメモリから削除される
		と同時に解放されてしまう。

		警告: もしも関数が有効ではないポインタを返すと、Vimはクラッ
		シュしてしまう。関数が数値を返してしまった場合、Vimはそれをポ
		インタとして扱ってしまうので、やはりクラッシュが起こる。
		Win32のシステムでは、{libname}はDLLのファイル名の拡張子".DLL"
		を付けてはならない。通常の(パスの通った)場所にDLLがない場合に
		は、フルパスで指定する必要がある。
		{Win32バージョン限定の機能}

							*libcallnr()*
libcallnr({libname}, {funcname}, {argument})
		Just like libcall(), but used for a function that returns an
		int instead of a string.
		{only in Win32 on some Unix versions, when the |+libcall|
		feature is present}
		Example (not very useful...): >
			:call libcallnr("libc.so", "printf", "Hello World!\n")
			:call libcallnr("libc.so", "sleep", 10)
<
							*line()*
line({expr})	結果は数値で、{expr}で与えられた位置のファイル内での行番号。受
		け付けられる位置指定は次の通り:
		    .	    カーソルの位置
		    $	    現在のバッファの最後の位置
		    'x	    マークxの位置(マークが設定されていない場合、0が返
			    る)
		    w0	    first line visible in current window
		    w$	    last line visible in current window
		Note that a mark in another file can be used.  The line number
		then applies to another buffer.
		To get the column number use |col()|.  To get both use
		|getpos()|.
		例:
>			line(".")		カーソルの行番号
>			line("'t")		マークtの位置の行番号
>			line("'" . marker)	マークmarkerの位置の行番号
							*last-position-jump*
		このautocommandはファイルを開いた時に、最後に開かれていた時の
		行へ自動的にジャンプするものである。これは'"マークがセットされ
		ている時にのみ有効である:
>	:au BufReadPost * if line("'\"") | exe "normal '\"" | endif

							*line2byte()*
line2byte({lnum})
		バッファの先頭から、{lnum}行目までのバイト数を返す。これには現
		在のバッファのオプション'fileformat'に従った、end-of-line(行終
		端)文字も含まれている。最初の行においては1が返る。
		次のようにすることで最終行を含むバイトサイズを獲得することがで
		きる:
>			line2byte(line("$") + 1)
		これはファイルの大きさプラス1になる。
		{lnum}が無効であるか、|+byte_offset|機能がコンパイル時に無効に
		されている場合、-1が返される。
		|byte2line()|、|go|及び|:goto|も参照。

lispindent({lnum})					*lispindent()*
		Get the amount of indent for line {lnum} according the lisp
		indenting rules, as with 'lisp'.
		The indent is counted in spaces, the value of 'tabstop' is
		relevant.  {lnum} is used just like in |getline()|.
		When {lnum} is invalid or Vim was not compiled the
		|+lispindent| feature, -1 is returned.

							*localtime()*
localtime()
		現在の時刻、1970年1月1日からの経過秒数を返す。|strftime()|と
		|getftime()|も参照。

map({expr}, {string})					*map()*
		{expr} must be a |List| or a |Dictionary|.
		Replace each item in {expr} with the result of evaluating
		{string}.
		Inside {string} |v:val| has the value of the current item.
		For a |Dictionary| |v:key| has the key of the current item.
		Example: >
			:call map(mylist, '"> " . v:val . " <"')
<		This puts "> " before and " <" after each item in "mylist".

		Note that {string} is the result of an expression and is then
		used as an expression again.  Often it is good to use a
		|literal-string| to avoid having to double backslashes.  You
		still have to double ' quotes

		The operation is done in-place.  If you want a |List| or
		|Dictionary| to remain unmodified make a copy first: >
			:let tlist = map(copy(mylist), ' & . "\t"')

<		Returns {expr}, the |List| or |Dictionary| that was filtered.
		When an error is encountered while evaluating {string} no
		further items in {expr} are processed.


maparg({name}[, {mode} [, {abbr}]])			*maparg()*
		モード{mode}におけるキーマップ{name}のrhsを返す。{name}という
		キーマップが存在しない場合、空文字列が返される。{mode}には次の
		文字が使用可能:
			"n"	ノーマル
			"v"	ビジュアル
			"o"	モーション待ち (Operator-pending)
			"i"	インサート
			"c"	コマンドライン
			""	ノーマル、ビジュアル、及びモーション待ち
		{mode}が省略された場合、""が使用される。
		When {abbr} is there and it is non-zero use abbreviations
		instead of mappings.
		{name}には":map"コマンドで使用可能な、特殊なキー名が指定でき
		る。結果の文字列内の特殊文字は、":map"コマンドでリスト表示した
		時のように変換される。
		The mappings local to the current buffer are checked first,
		then the global mappings.  
		This function can be used to map a key even when it's already
		mapped, and have it do the original mapping too.  Sketch: >
			exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')


mapcheck({name}[, {mode} [, {abbr}]])			*mapcheck()*
		モード{mode}におけるキーマップ{name}が存在するかチェックする。
		{name}に指定できる特殊文字は|maparg()|を参照。
		When {abbr} is there and it is non-zero use abbreviations
		instead of mappings.
		{name}に対応するキーマップが存在しない時には、空文字列が返され
		る。結果が一つならばマップされたrhsが返される。複数見つかった
		場合には、それらのうちどれか一つのrhsが返される。
		この関数はマッピングが曖昧にならないかチェックするために使うこ
		とができる。例:
>	if mapcheck("_vv") == ""
>	   map _vv :set guifont=7x13<CR>
>	endif
		"_vv"というマッピングは"_v"とか"_vvv"といったマッピングと衝突
		する可能性がある。


match({expr}, {pat}[, {start}[, {count}]])			*match()*
		When {expr} is a |List| then this returns the index of the
		first item where {pat} matches.  Each item is used as a
		String, |Lists| and |Dictionaries| are used as echoed.
		Otherwise, {expr} is used as a String.  The result is a
		Number, which gives the index (byte offset) in {expr} where
		{pat} matches.
		A match at the first character or |List| item returns zero.
		If there is no match -1 is returned.
		Example: >
			:echo match("testing", "ing")	" results in 4
			:echo match([1, 'x'], '\a')	" results in 1
<		See |string-match| for how {pat} is used.
								*strpbrk()*
		Vim doesn't have a strpbrk() function.  But you can do: >
			:let sepidx = match(line, '[.,;: \t]')
<								*strcasestr()*
		Vim doesn't have a strcasestr() function.  But you can add
		"\c" to the pattern to ignore case: >
			:let idx = match(haystack, '\cneedle')
<
		If {start} is given, the search starts from byte index
		{start} in a String or item {start} in a |List|.
		The result, however, is still the index counted from the
		first character/item.  Example: >
			:echo match("testing", "ing", 2)
<		result is again "4". >
			:echo match("testing", "ing", 4)
<		result is again "4". >
			:echo match("testing", "t", 2)
<		result is "3".
		For a String, if {start} > 0 then it is like the string starts
		{start} bytes later, thus "^" will match at {start}.  Except
		when {count} is given, then it's like matches before the
		{start} byte are ignored (this is a bit complicated to keep it
		backwards compatible).
		For a String, if {start} < 0, it will be set to 0.  For a list
		the index is counted from the end.
		If {start} is out of range ({start} > strlen({expr}) for a
		String or {start} > len({expr}) for a |List|) -1 is returned.

		When {count} is given use the {count}'th match.  When a match
		is found in a String the search for the next one starts one
		character further.  Thus this example results in 1: >
			echo match("testing", "..", 0, 2)
<		In a |List| the search continues in the next item.
		Note that when {count} is added the way {start} works changes,
		see above.

		See |pattern| for the patterns that are accepted.
		The 'ignorecase' option is used to set the ignore-caseness of
		the pattern.  'smartcase' is NOT used.  The matching is always
		done like 'magic' is set and 'cpoptions' is empty.


matcharg({nr})							*matcharg()*
		Selects the {nr} match item, as set with a |:match|,
		|:2match| or |:3match| command.
		Return a |List| with two elements:
			The name of the highlight group used
			The pattern used.
		When {nr} is not 1, 2 or 3 returns an empty |List|.
		When there is no match item set returns ['', ''].
		This is usef to save and restore a |:match|.


							*matchend()*
matchend({expr}, {pat})
		match()と同じだが、返されるのはマッチした部分文字列の終了後の
		インデックスである。例:
>			:echo matchend("testing", "ing")
		結果は"7"。
							*strspn()* *strcspn()*
		Vim doesn't have a strspn() or strcspn() function, but you can
		do it with matchend(): >
			:let span = matchend(line, '[a-zA-Z]')
			:let span = matchend(line, '[^a-zA-Z]')
<		Except that -1 is returned when there are no matches.

		The {start}, if given, has the same meaning as for match(). >
			:echo matchend("testing", "ing", 2)
<		results in "7". >
			:echo matchend("testing", "ing", 5)
<		result is "-1".
		When {expr} is a |List| the result is equal to match().

matchlist({expr}, {pat}[, {start}[, {count}]])			*matchlist()*
		Same as match(), but return a |List|.  The first item in the
		list is the matched string, same as what matchstr() would
		return.  Following items are submatches, like "\1", "\2", etc.
		in |:substitute|.  When an optional submatch didn't match an
		empty string is used.  Example: >
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
<		Results in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
		When there is no match an empty list is returned.

matchstr({expr}, {pat}[, {start}[, {count}]])			*matchstr()*
		match()と同じだが、返されるのはマッチした文字列。例:
>			:echo matchstr("testing", "ing")
		結果は"ing"。
		マッチしなければ""が返される。
		The {start}, if given, has the same meaning as for match(). >
			:echo matchstr("testing", "ing", 2)
<		results in "ing". >
			:echo matchstr("testing", "ing", 5)
<		result is "".
		When {expr} is a |List| then the matching item is returned.
		The type isn't changed, it's not necessarily a String.

							*max()*
max({list})	Return the maximum value of all items in {list}.
		If {list} is not a list or one of the items in {list} cannot
		be used as a Number this results in an error.
		An empty |List| results in zero.

							*min()*
min({list})	Return the minimum value of all items in {list}.
		If {list} is not a list or one of the items in {list} cannot
		be used as a Number this results in an error.
		An empty |List| results in zero.

							*mkdir()* *E739*
mkdir({name} [, {path} [, {prot}]])
		Create directory {name}.
		If {path} is "p" then intermediate directories are created as
		necessary.  Otherwise it must be "".
		If {prot} is given it is used to set the protection bits of
		the new directory.  The default is 0755 (rwxr-xr-x: r/w for
		the user readable for others).  Use 0700 to make it unreadable
		for others.
		This function is not available in the |sandbox|.
		Not available on all systems.  To check use: >
			:if exists("*mkdir")
<
							*mode()*
mode()		Return a string that indicates the current mode:
			n	Normal
			v	Visual by character
			V	Visual by line
			CTRL-V	Visual blockwise
			s	Select by character
			S	Select by line
			CTRL-S	Select blockwise
			i	Insert
			R	Replace
			c	Command-line
			r	Hit-enter prompt
		This is useful in the 'statusline' option.  In most other
		places it always returns "c" or "n".

nextnonblank({lnum})					*nextnonblank()*
		Return the line number of the first line at or below {lnum}
		that is not blank.  Example: >
			if getline(nextnonblank(1)) =~ "Java"
<		When {lnum} is invalid or there is no non-blank line at or
		below it, zero is returned.
		See also |prevnonblank()|.

							*nr2char()*
nr2char({expr})
		結果はアスキーコード{expr}を持つ1文字からなる文字列となる。例:
>			nr2char(64)		"@"が返される
>			nr2char(32)		" "が返される
<		The current 'encoding' is used.  Example for "utf-8": >
			nr2char(300)		returns I with bow character
<		Note that a NUL character in the file is specified with
		nr2char(10), because NULs are represented with newline
		characters.  nr2char(0) is a real NUL and terminates the
		string, thus results in an empty string.

							*getpos()*
getpos({expr})	Get the position for {expr}.  For possible values of {expr}
		see |line()|.
		The result is a |List| with four numbers:
		    [bufnum, lnum, col, off]
		"bufnum" is zero, unless a mark like '0 or 'A is used, then it
		is the buffer number of the mark.
		"lnum" and "col" are the position in the buffer.  The first
		column is 1.
		The "off" number is zero, unless 'virtualedit' is used.  Then
		it is the offset in screen columns from the start of the
		character.  E.g., a position within a <Tab> or after the last
		character.
		This can be used to save and restore the cursor position: >
			let save_cursor = getpos(".")
			MoveTheCursorAround
			call setpos('.', save_cursor)
<		Also see |setpos()|.

pathshorten({expr})					*pathshorten()*
		Shorten directory names in the path {expr} and return the
		result.  The tail, the file name, is kept as-is.  The other
		components in the path are reduced to single letters.  Leading
		'~' and '.' characters are kept.  Example: >
			:echo pathshorten('~/.vim/autoload/myfile.vim')
<			~/.v/a/myfile.vim ~
		It doesn't matter if the path exists or not.

prevnonblank({lnum})					*prevnonblank()*
		Return the line number of the first line at or above {lnum}
		that is not blank.  Example: >
			let ind = indent(prevnonblank(v:lnum - 1))
<		When {lnum} is invalid or there is no non-blank line at or
		above it, zero is returned.
		Also see |nextnonblank()|.


printf({fmt}, {expr1} ...)				*printf()*
		Return a String with {fmt}, where "%" items are replaced by
		the formatted form of their respective arguments.  Example: >
			printf("%4d: E%d %.30s", lnum, errno, msg)
<		May result in:
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~

		Often used items are:
		  %s	string
		  %6s	string right-aligned in 6 bytes
		  %.9s  string truncated to 9 bytes
		  %c    single byte
		  %d    decimal number
		  %5d   decimal number padded with spaces to 5 characters
		  %x    hex number
		  %04x  hex number padded with zeros to at least 4 characters
		  %X    hex number using upper case letters
		  %o    octal number
		  %%    the % character itself

		Conversion specifications start with '%' and end with the
		conversion type.  All other characters are copied unchanged to
		the result.

		The "%" starts a conversion specification.  The following
		arguments appear in sequence:

			%  [flags]  [field-width]  [.precision]  type

		flags
			Zero or more of the following flags:

		    #	      The value should be converted to an "alternate
			      form".  For c, d, and s conversions, this option
			      has no effect.  For o conversions, the precision
			      of the number is increased to force the first
			      character of the output string to a zero (except
			      if a zero value is printed with an explicit
			      precision of zero).
			      For x and X conversions, a non-zero result has
			      the string "0x" (or "0X" for X conversions)
			      prepended to it.

		    0 (zero)  Zero padding.  For all conversions the converted
			      value is padded on the left with zeros rather
			      than blanks.  If a precision is given with a
			      numeric conversion (d, o, x, and X), the 0 flag
			      is ignored.

		    -	      A negative field width flag; the converted value
			      is to be left adjusted on the field boundary.
			      The converted value is padded on the right with
			      blanks, rather than on the left with blanks or
			      zeros.  A - overrides a 0 if both are given.

		    ' ' (space)  A blank should be left before a positive
			      number produced by a signed conversion (d).

		    +	      A sign must always be placed before a number
			      produced by a signed conversion.  A + overrides
			      a space if both are used.

		field-width
			An optional decimal digit string specifying a minimum
			field width.  If the converted value has fewer bytes
			than the field width, it will be padded with spaces on
			the left (or right, if the left-adjustment flag has
			been given) to fill out the field width.

		.precision
			An optional precision, in the form of a period '.'
			followed by an optional digit string.  If the digit
			string is omitted, the precision is taken as zero.
			This gives the minimum number of digits to appear for
			d, o, x, and X conversions, or the maximum number of
			bytes to be printed from a string for s conversions.

		type
			A character that specifies the type of conversion to
			be applied, see below.

		A field width or precision, or both, may be indicated by an
		asterisk '*' instead of a digit string.  In this case, a
		Number argument supplies the field width or precision.  A
		negative field width is treated as a left adjustment flag
		followed by a positive field width; a negative precision is
		treated as though it were missing.  Example: >
			:echo printf("%d: %.*s", nr, width, line)
<		This limits the length of the text used from "line" to
		"width" bytes.

		The conversion specifiers and their meanings are:

		doxX    The Number argument is converted to signed decimal
			(d), unsigned octal (o), or unsigned hexadecimal (x
			and X) notation.  The letters "abcdef" are used for
			x conversions; the letters "ABCDEF" are used for X
			conversions.
			The precision, if any, gives the minimum number of
			digits that must appear; if the converted value
			requires fewer digits, it is padded on the left with
			zeros.
			In no case does a non-existent or small field width
			cause truncation of a numeric field; if the result of
			a conversion is wider than the field width, the field
			is expanded to contain the conversion result.

		c	The Number argument is converted to a byte, and the
			resulting character is written.

		s	The text of the String argument is used.  If a
			precision is specified, no more bytes than the number
			specified are used.

		%	A '%' is written.  No argument is converted.  The
			complete conversion specification is "%%".

		Each argument can be Number or String and is converted
		automatically to fit the conversion specifier.  Any other
		argument type results in an error message.

							*E766* *E767*
		The number of {exprN} arguments must exactly match the number
		of "%" items.  If there are not sufficient or too many
		arguments an error is given.  Up to 18 arguments can be used.


pumvisible()						*pumvisible()*
		Returns non-zero when the popup menu is visible, zero
		otherwise.  See |ins-completion-menu|.
		This can be used to avoid some things that would remove the
		popup menu.

							*E726* *E727*
range({expr} [, {max} [, {stride}]])				*range()*
		Returns a |List| with Numbers:
		- If only {expr} is specified: [0, 1, ..., {expr} - 1]
		- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]
		- If {stride} is specified: [{expr}, {expr} + {stride}, ...,
		  {max}] (increasing {expr} with {stride} each time, not
		  producing a value past {max}).
		When the maximum is one before the start the result is an
		empty list.  When the maximum is more than one before the
		start this is an error.
		Examples: >
			range(4)		" [0, 1, 2, 3]
			range(2, 4)		" [2, 3, 4]
			range(2, 9, 3)		" [2, 5, 8]
			range(2, -2, -1)	" [2, 1, 0, -1, -2]
			range(0)		" []
			range(2, 0)		" error!
<
							*readfile()*
readfile({fname} [, {binary} [, {max}]])
		Read file {fname} and return a |List|, each line of the file
		as an item.  Lines broken at NL characters.  Macintosh files
		separated with CR will result in a single long line (unless a
		NL appears somewhere).
		When {binary} is equal to "b" binary mode is used:
		- When the last line ends in a NL an extra empty list item is
		  added.
		- No CR characters are removed.
		Otherwise:
		- CR characters that appear before a NL are removed.
		- Whether the last line ends in a NL or not does not matter.
		All NUL characters are replaced with a NL character.
		When {max} is given this specifies the maximum number of lines
		to be read.  Useful if you only want to check the first ten
		lines of a file: >
			:for line in readfile(fname, '', 10)
			:  if line =~ 'Date' | echo line | endif
			:endfor
<		When {max} is negative -{max} lines from the end of the file
		are returned, or as many as there are.
		When {max} is zero the result is an empty list.
		Note that without {max} the whole file is read into memory.
		Also note that there is no recognition of encoding.  Read a
		file into a buffer if you need to.
		When the file can't be opened an error message is given and
		the result is an empty list.
		Also see |writefile()|.

reltime([{start} [, {end}]])				*reltime()*
		Return an item that represents a time value.  The format of
		the item depends on the system.  It can be passed to
		|reltimestr()| to convert it to a string.
		Without an argument it returns the current time.
		With one argument is returns the time passed since the time
		specified in the argument.
		With two arguments it returns the time passed between {start}
		and {end}.
		The {start} and {end} arguments must be values returned by
		reltime().
		{only available when compiled with the +reltime feature}

reltimestr({time})				*reltimestr()*
		Return a String that represents the time value of {time}.
		This is the number of seconds, a dot and the number of
		microseconds.  Example: >
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
<		Note that overhead for the commands will be added to the time.
		The accuracy depends on the system.
		Leading spaces are used to make the string align nicely.  You
		can use split() to remove it. >
			echo split(reltimestr(reltime(start)))[0]
<		Also see |profiling|.
		{only available when compiled with the +reltime feature}

							*remote_expr()* *E449*
remote_expr({server}, {string} [, {idvar}])
		Send the {string} to {server}.  The string is sent as an
		expression and the result is returned after evaluation.
		The result must be a String or a |List|.  A |List| is turned
		into a String by joining the items with a line break in
		between (not at the end), like with join(expr, "\n").
		If {idvar} is present, it is taken as the name of a
		variable and a {serverid} for later use with
		remote_read() is stored there.
		See also |clientserver| |RemoteReply|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Note: Any errors will cause a local error message to be issued
		and the result will be the empty string.
		Examples: >
			:echo remote_expr("gvim", "2+2")
			:echo remote_expr("gvim1", "b:current_syntax")
<

remote_foreground({server})				*remote_foreground()*
		Move the Vim server with the name {server} to the foreground.
		This works like: >
			remote_expr({server}, "foreground()")
<		Except that on Win32 systems the client does the work, to work
		around the problem that the OS doesn't always allow the server
		to bring itself to the foreground.
		Note: This does not restore the window if it was minimized,
		like foreground() does.
		This function is not available in the |sandbox|.
		{only in the Win32, Athena, Motif and GTK GUI versions and the
		Win32 console version}


remote_peek({serverid} [, {retvar}])		*remote_peek()*
		Returns a positive number if there are available strings
		from {serverid}.  Copies any reply string into the variable
		{retvar} if specified.  {retvar} must be a string with the
		name of a variable.
		Returns zero if none are available.
		Returns -1 if something is wrong.
		See also |clientserver|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Examples: >
			:let repl = ""
			:echo "PEEK: ".remote_peek(id, "repl").": ".repl

remote_read({serverid})				*remote_read()*
		Return the oldest available reply from {serverid} and consume
		it.  It blocks until a reply is available.
		See also |clientserver|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Example: >
			:echo remote_read(id)
<
							*remote_send()* *E241*
remote_send({server}, {string} [, {idvar}])
		Send the {string} to {server}.  The string is sent as input
		keys and the function returns immediately.  At the Vim server
		the keys are not mapped |:map|.
		If {idvar} is present, it is taken as the name of a variable
		and a {serverid} for later use with remote_read() is stored
		there.
		See also |clientserver| |RemoteReply|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Note: Any errors will be reported in the server and may mess
		up the display.
		Examples: >
		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").
		 \ remote_read(serverid)

		:autocmd NONE RemoteReply *
		 \ echo remote_read(expand("<amatch>"))
		:echo remote_send("gvim", ":sleep 10 | echo ".
		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
<
remove({list}, {idx} [, {end}])				*remove()*
		Without {end}: Remove the item at {idx} from |List| {list} and
		return it.
		With {end}: Remove items from {idx} to {end} (inclusive) and
		return a list with these items.  When {idx} points to the same
		item as {end} a list with one item is returned.  When {end}
		points to an item before {idx} this is an error.
		See |list-index| for possible values of {idx} and {end}.
		Example: >
			:echo "last item: " . remove(mylist, -1)
			:call remove(mylist, 0, 9)
remove({dict}, {key})
		Remove the entry from {dict} with key {key}.  Example: >
			:echo "removed " . remove(dict, "one")
<		If there is no {key} in {dict} this is an error.

		Use |delete()| to remove a file.


rename({from}, {to})					*rename()*
		ファイルの名前を{from}から{to}へ変える。ファイルシステムを越え
		てファイルを移動するのにも使用できる。結果は数値で、成功すれば
		0、失敗すれば非ゼロになる。
		This function is not available in the |sandbox|.

repeat({expr}, {count})					*repeat()*
		Repeat {expr} {count} times and return the concatenated
		result.  Example: >
			:let separator = repeat('-', 80)
<		When {count} is zero or negative the result is empty.
		When {expr} is a |List| the result is {expr} concatenated
		{count} times.  Example: >
			:let longlist = repeat(['a', 'b'], 3)
<		Results in ['a', 'b', 'a', 'b', 'a', 'b'].


resolve({filename})					*resolve()* *E655*
		On MS-Windows, when {filename} is a shortcut (a .lnk file),
		returns the path the shortcut points to in a simplified form.
		On Unix, repeat resolving symbolic links in all path
		components of {filename} and return the simplified result.
		To cope with link cycles, resolving of symbolic links is
		stopped after 100 iterations.
		On other systems, return the simplified {filename}.
		The simplification step is done as by |simplify()|.
		resolve() keeps a leading path component specifying the
		current directory (provided the result is still a relative
		path name) and also keeps a trailing path separator.

							*reverse()*
reverse({list})	Reverse the order of items in {list} in-place.  Returns
		{list}.
		If you want a list to remain unmodified make a copy first: >
			:let revlist = reverse(copy(mylist))

search({pattern} [, {flags} [, {stopline}]])			*search()*
		Search for regexp pattern {pattern}.  The search starts at the
		cursor position (you can use |cursor()| to set it).

		{flags} is a String, which can contain these character flags:
		'b'	search backward instead of forward
		'c'     accept a match at the cursor position
		'e'	move to the End of the match
		'n'	do Not move the cursor
		'p'	return number of matching sub-pattern (see below)
		's'	set the ' mark at the previous location of the cursor
		'w'	wrap around the end of the file
		'W'	don't wrap around the end of the file
		If neither 'w' or 'W' is given, the 'wrapscan' option applies.

		If the 's' flag is supplied, the ' mark is set, only if the
		cursor is moved. The 's' flag cannot be combined with the 'n'
		flag.

		'ignorecase', 'smartcase' and 'magic' are used.

		When the {stopline} argument is given then the search stops
		after searching this line.  This is useful to restrict the
		search to a range of lines.  Examples: >
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
<		When {stopline} is used and it is not zero this also implies
		that the search does not wrap around the end of the file.

		If there is no match a 0 is returned and the cursor doesn't
		move.  No error message is given.
		When a match has been found its line number is returned.
							*search()-sub-match*
		With the 'p' flag the returned value is one more than the
		first sub-match in \(\).  One if none of them matched but the
		whole pattern did match.
		To get the column number too use |searchpos()|.

		The cursor will be positioned at the match, unless the 'n'
		flag is used.

		Example (goes over all files in the argument list): >
		    :let n = 1
		    :while n <= argc()	    " loop over all files in arglist
		    :  exe "argument " . n
		    :  " start at the last char in the file and wrap for the
		    :  " first search to find match at start of file
		    :  normal G$
		    :  let flags = "w"
		    :  while search("foo", flags) > 0
		    :    s/foo/bar/g
		    :	 let flags = "W"
		    :  endwhile
		    :  update		    " write the file if modified
		    :  let n = n + 1
		    :endwhile
<
		Example for using some flags: >
		    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
<		This will search for the keywords "if", "else", and "endif"
		under or after the cursor.  Because of the 'p' flag, it
		returns 1, 2, or 3 depending on which keyword is found, or 0
		if the search fails.  With the cursor on the first word of the
		line:
		    if (foo == 0) | let foo = foo + 1 | endif ~
		the function returns 1.  Without the 'c' flag, the function
		finds the "endif" and returns 3.  The same thing happens
		without the 'e' flag if the cursor is on the "f" of "if".
		The 'n' flag tells the function not to move the cursor.


searchdecl({name} [, {global} [, {thisblock}]])			*searchdecl()*
		Search for the declaration of {name}.

		With a non-zero {global} argument it works like |gD|, find
		first match in the file.  Otherwise it works like |gd|, find
		first match in the function.

		With a non-zero {thisblock} argument matches in a {} block
		that ends before the cursor position are ignored.  Avoids
		finding variable declarations only valid in another scope.

		Moves the cursor to the found match.
		Returns zero for success, non-zero for failure.
		Example: >
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif
<
							*searchpair()*
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [, {stopline}]]])
		Search for the match of a nested start-end pair.  This can be
		used to find the "endif" that matches an "if", while other
		if/endif pairs in between are ignored.
		The search starts at the cursor.  The default is to search
		forward, include 'b' in {flags} to search backward.
		If a match is found, the cursor is positioned at it and the
		line number is returned.  If no match is found 0 or -1 is
		returned and the cursor doesn't move.  No error message is
		given.

		{start}, {middle} and {end} are patterns, see |pattern|.  They
		must not contain \( \) pairs.  Use of \%( \) is allowed.  When
		{middle} is not empty, it is found when searching from either
		direction, but only when not in a nested start-end pair.  A
		typical use is: >
			searchpair('\<if\>', '\<else\>', '\<endif\>')
<		By leaving {middle} empty the "else" is skipped.

		{flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with
		|search()|.  Additionally:
		'r'	Repeat until no more matches found; will find the
			outer pair
		'm'	return number of Matches instead of line number with
			the match; will be > 1 when 'r' is used.

		When a match for {start}, {middle} or {end} is found, the
		{skip} expression is evaluated with the cursor positioned on
		the start of the match.  It should return non-zero if this
		match is to be skipped.  E.g., because it is inside a comment
		or a string.
		When {skip} is omitted or empty, every match is accepted.
		When evaluating {skip} causes an error the search is aborted
		and -1 returned.

		For {stopline} see |search()|.

		The value of 'ignorecase' is used.  'magic' is ignored, the
		patterns are used like it's on.

		The search starts exactly at the cursor.  A match with
		{start}, {middle} or {end} at the next character, in the
		direction of searching, is the first one found.  Example: >
			if 1
			  if 2
			  endif 2
			endif 1
<		When starting at the "if 2", with the cursor on the "i", and
		searching forwards, the "endif 2" is found.  When starting on
		the character just before the "if 2", the "endif 1" will be
		found.  That's because the "if 2" will be found first, and
		then this is considered to be a nested if/endif from "if 2" to
		"endif 2".
		When searching backwards and {end} is more than one character,
		it may be useful to put "\zs" at the end of the pattern, so
		that when the cursor is inside a match with the end it finds
		the matching start.

		Example, to find the "endif" command in a Vim script: >

	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')

<		The cursor must be at or after the "if" for which a match is
		to be found.  Note that single-quote strings are used to avoid
		having to double the backslashes.  The skip expression only
		catches comments at the start of a line, not after a command.
		Also, a word "en" or "if" halfway a line is considered a
		match.
		Another example, to search for the matching "{" of a "}": >

	:echo searchpair('{', '', '}', 'bW')

<		This works when the cursor is at or before the "}" for which a
		match is to be found.  To reject matches that syntax
		highlighting recognized as strings: >

	:echo searchpair('{', '', '}', 'bW',
	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
<
							*searchpairpos()*
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [, {stopline}]]])
		Same as searchpair(), but returns a |List| with the line and
		column position of the match. The first element of the |List|
		is the line number and the second element is the byte index of
		the column position of the match.  If no match is found,
		returns [0, 0].
>
			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
<
		See |match-parens| for a bigger and more useful example.

searchpos({pattern} [, {flags} [, {stopline}]])		*searchpos()*
		Same as |search()|, but returns a |List| with the line and
		column position of the match. The first element of the |List|
		is the line number and the second element is the byte index of
		the column position of the match. If no match is found,
		returns [0, 0].
		Example: >
	:let [lnum, col] = searchpos('mypattern', 'n')

<		When the 'p' flag is given then there is an extra item with
		the sub-pattern match number |search()-sub-match|.  Example: >
	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
<		In this example "submatch" is 2 when a lowercase letter is
		found |/\l|, 3 when an uppercase letter is found |/\u|.

server2client( {clientid}, {string})			*server2client()*
		Send a reply string to {clientid}.  The most recent {clientid}
		that sent a string can be retrieved with expand("<client>").
		{only available when compiled with the |+clientserver| feature}
		Note:
		This id has to be stored before the next command can be
		received.  I.e. before returning from the received command and
		before calling any commands that waits for input.
		See also |clientserver|.
		Example: >
			:echo server2client(expand("<client>"), "HELLO")
<
serverlist()					*serverlist()*
		Return a list of available server names, one per line.
		When there are no servers or the information is not available
		an empty string is returned.  See also |clientserver|.
		{only available when compiled with the |+clientserver| feature}
		Example: >
			:echo serverlist()
<
setbufvar({expr}, {varname}, {val})			*setbufvar()*
		Set option or local variable {varname} in buffer {expr} to
		{val}.
		This also works for a global or local window option, but it
		doesn't work for a global or local window variable.
		For a local window option the global value is unchanged.
		For the use of {expr}, see |bufname()| above.
		Note that the variable name without "b:" must be used.
		Examples: >
			:call setbufvar(1, "&mod", 1)
			:call setbufvar("todo", "myvar", "foobar")
<		This function is not available in the |sandbox|.

setcmdpos({pos})					*setcmdpos()*
		Set the cursor position in the command line to byte position
		{pos}.  The first position is 1.
		Use |getcmdpos()| to obtain the current position.
		Only works while editing the command line, thus you must use
		|c_CTRL-\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For
		|c_CTRL-\_e| and |c_CTRL-R_CTRL-R| with '=' the position is
		set after the command line is set to the expression.  For
		|c_CTRL-R_=| it is set after evaluating the expression but
		before inserting the resulting text.
		When the number is too big the cursor is put at the end of the
		line.  A number smaller than one has undefined results.
		Returns 0 when successful, 1 when not editing the command
		line.

setline({lnum}, {line})					*setline()*
		Set line {lnum} of the current buffer to {line}.
		{lnum} is used like with |getline()|.
		When {lnum} is just below the last line the {line} will be
		added as a new line.
		If this succeeds, 0 is returned.  If this fails (most likely
		because {lnum} is invalid) 1 is returned.  Example: >
			:call setline(5, strftime("%c"))
<		When {line} is a |List| then line {lnum} and following lines
		will be set to the items in the list.  Example: >
			:call setline(5, ['aaa', 'bbb', 'ccc'])
<		This is equivalent to: >
			:for [n, l] in [[5, 6, 7], ['aaa', 'bbb', 'ccc']]
			:  call setline(n, l)
			:endfor
<		Note: The '[ and '] marks are not set.

setloclist({nr}, {list} [, {action}])			*setloclist()*
		Create or replace or add to the location list for window {nr}.
		When {nr} is zero the current window is used. For a location
		list window, the displayed location list is modified.  For an
		invalid window number {nr}, -1 is returned.
		Otherwise, same as setqflist().

							*setpos()*
setpos({expr}, {list})
		Set the position for {expr}.  Possible values:
			.	the cursor
			'x	mark x

		{list} must be a |List| with four numbers:
		    [bufnum, lnum, col, off]

		"bufnum" is the buffer number.  Zero can be used for the
		current buffer.  Setting the cursor is only possible for
		the current buffer.  To set a mark in another buffer you can
		use the |bufnr()| function to turn a file name into a buffer
		number.
		Does not change the jumplist.

		"lnum" and "col" are the position in the buffer.  The first
		column is 1.  Use a zero "lnum" to delete a mark.

		The "off" number is only used when 'virtualedit' is set. Then
		it is the offset in screen columns from the start of the
		character.  E.g., a position within a <Tab> or after the last
		character.

		Also see |getpos()|

		This does not restore the preferred column for moving
		vertically.  See |winrestview()| for that.


setqflist({list} [, {action}])				*setqflist()*
		Create or replace or add to the quickfix list using the items
		in {list}.  Each item in {list} is a dictionary.
		Non-dictionary items in {list} are ignored.  Each dictionary
		item can contain the following entries:

		    bufnr	buffer number; must be the number of a valid
		    		buffer
		    filename	name of a file; only used when "bufnr" is not
		    		present or it is invalid.
		    lnum	line number in the file
		    pattern	search pattern used to locate the error
		    col		column number
		    vcol	when non-zero: "col" is visual column
				when zero: "col" is byte index
		    nr		error number
		    text	description of the error
		    type	single-character error type, 'E', 'W', etc.

		The "col", "vcol", "nr", "type" and "text" entries are
		optional.  Either "lnum" or "pattern" entry can be used to
		locate a matching error line.
		If the "filename" and "bufnr" entries are not present or
		neither the "lnum" or "pattern" entries are present, then the
		item will not be handled as an error line.
		If both "pattern" and "lnum" are present then "pattern" will
		be used.
		Note that the list is not exactly the same as what
		|getqflist()| returns.

		If {action} is set to 'a', then the items from {list} are
		added to the existing quickfix list. If there is no existing
		list, then a new list is created. If {action} is set to 'r',
		then the items from the current quickfix list are replaced
		with the items from {list}. If {action} is not present or is
		set to ' ', then a new list is created.

		Returns zero for success, -1 for failure.

		This function can be used to create a quickfix list
		independent of the 'errorformat' setting.  Use a command like
		":cc 1" to jump to the first position.


							*setreg()*
setreg({regname}, {value} [,{options}])
		Set the register {regname} to {value}.
		If {options} contains "a" or {regname} is upper case,
		then the value is appended.
		{options} can also contains a register type specification:
		    "c" or "v"	      |characterwise| mode
		    "l" or "V"	      |linewise| mode
		    "b" or "<CTRL-V>" |blockwise-visual| mode
		If a number immediately follows "b" or "<CTRL-V>" then this is
		used as the width of the selection - if it is not specified
		then the width of the block is set to the number of characters
		in the longest line (counting a <Tab> as 1 character).

		If {options} contains no register settings, then the default
		is to use character mode unless {value} ends in a <NL>.
		Setting the '=' register is not possible.
		Returns zero for success, non-zero for failure.

		Examples: >
			:call setreg(v:register, @*)
			:call setreg('*', @%, 'ac')
			:call setreg('a', "1\n2\n3", 'b5')

<		This example shows using the functions to save and restore a
		register. >
			:let var_a = getreg('a', 1)
			:let var_amode = getregtype('a')
			    ....
			:call setreg('a', var_a, var_amode)

<		You can also change the type of a register by appending
		nothing: >
			:call setreg('a', '', 'al')

settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
		Set option or local variable {varname} in window {winnr} to
		{val}.
		Tabs are numbered starting with one.  For the current tabpage
		use |setwinvar()|.
		When {winnr} is zero the current window is used.
		This also works for a global or local buffer option, but it
		doesn't work for a global or local buffer variable.
		For a local buffer option the global value is unchanged.
		Note that the variable name without "w:" must be used.
		Vim briefly goes to the tab page {tabnr}, this may trigger
		TabLeave and TabEnter autocommands.
		Examples: >
			:call settabwinvar(1, 1, "&list", 0)
			:call settabwinvar(3, 2, "myvar", "foobar")
<		This function is not available in the |sandbox|.

setwinvar({nr}, {varname}, {val})			*setwinvar()*
		Like |settabwinvar()| for the current tab page.
		Examples: >
			:call setwinvar(1, "&list", 0)
			:call setwinvar(2, "myvar", "foobar")

shellescape({string})					*shellescape()*
		Escape {string} for use as shell command argument.
		On MS-Windows and MS-DOS, when 'shellslash' is not set, it
		will enclose {string} double quotes and double all double
		quotes within {string}.
		For other systems, it will enclose {string} in single quotes
		and replace all "'" with "'\''".
		Example: >
			:echo shellescape('c:\program files\vim')
<		results in:
			"c:\program files\vim" ~
		Example usage: >
			:call system("chmod +x -- " . shellescape(expand("%")))


simplify({filename})					*simplify()*
		Simplify the file name as much as possible without changing
		the meaning.  Shortcuts (on MS-Windows) or symbolic links (on
		Unix) are not resolved.  If the first path component in
		{filename} designates the current directory, this will be
		valid for the result as well.  A trailing path separator is
		not removed either.
		Example: >
			simplify("./dir/.././/file/") == "./file/"
<		Note: The combination "dir/.." is only removed if "dir" is
		a searchable directory or does not exist.  On Unix, it is also
		removed when "dir" is a symbolic link within the same
		directory.  In order to resolve all the involved symbolic
		links before simplifying the path name, use |resolve()|.


sort({list} [, {func}])					*sort()* *E702*
		Sort the items in {list} in-place.  Returns {list}.  If you
		want a list to remain unmodified make a copy first: >
			:let sortedlist = sort(copy(mylist))
<		Uses the string representation of each item to sort on.
		Numbers sort after Strings, |Lists| after Numbers.
		For sorting text in the current buffer use |:sort|.
		When {func} is given and it is one then case is ignored.
		When {func} is a |Funcref| or a function name, this function
		is called to compare items.  The function is invoked with two
		items as argument and must return zero if they are equal, 1 if
		the first one sorts after the second one, -1 if the first one
		sorts before the second one.  Example: >
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			let sortedlist = sort(mylist, "MyCompare")
<

							*soundfold()*
soundfold({word})
		Return the sound-folded equivalent of {word}.  Uses the first
		language in 'spellang' for the current window that supports
		soundfolding.  'spell' must be set.  When no sound folding is
		possible the {word} is returned unmodified.
		This can be used for making spelling suggestions.  Note that
		the method can be quite slow.

							*spellbadword()*
spellbadword([{sentence}])
		Without argument: The result is the badly spelled word under
		or after the cursor.  The cursor is moved to the start of the
		bad word.  When no bad word is found in the cursor line the
		result is an empty string and the cursor doesn't move.

		With argument: The result is the first word in {sentence} that
		is badly spelled.  If there are no spelling mistakes the
		result is an empty string.

		The return value is a list with two items:
		- The badly spelled word or an empty string.
		- The type of the spelling error:
			"bad"		spelling mistake
			"rare"		rare word
			"local"		word only valid in another region
			"caps"		word should start with Capital
		Example: >
			echo spellbadword("the quik brown fox")
<			['quik', 'bad'] ~

		The spelling information for the current window is used.  The
		'spell' option must be set and the value of 'spelllang' is
		used.

							*spellsuggest()*
spellsuggest({word} [, {max} [, {capital}]])
		Return a |List| with spelling suggestions to replace {word}.
		When {max} is given up to this number of suggestions are
		returned.  Otherwise up to 25 suggestions are returned.

		When the {capital} argument is given and it's non-zero only
		suggestions with a leading capital will be given.  Use this
		after a match with 'spellcapcheck'.

		{word} can be a badly spelled word followed by other text.
		This allows for joining two words that were split.  The
		suggestions also include the following text, thus you can
		replace a line.

		{word} may also be a good word.  Similar words will then be
		returned.  {word} itself is not included in the suggestions,
		although it may appear capitalized.

		The spelling information for the current window is used.  The
		'spell' option must be set and the values of 'spelllang' and
		'spellsuggest' are used.


split({expr} [, {pattern} [, {keepempty}]])			*split()*
		Make a |List| out of {expr}.  When {pattern} is omitted or
		empty each white-separated sequence of characters becomes an
		item.
		Otherwise the string is split where {pattern} matches,
		removing the matched characters.
		When the first or last item is empty it is omitted, unless the
		{keepempty} argument is given and it's non-zero.
		Other empty items are kept when {pattern} matches at least one
		character or when {keepempty} is non-zero.
		Example: >
			:let words = split(getline('.'), '\W\+')
<		To split a string in individual characters: >
			:for c in split(mystring, '\zs')
<		If you want to keep the separator you can also use '\zs': >
			:echo split('abc:def:ghi', ':\zs')
<			['abc:', 'def:', 'ghi'] ~
		Splitting a table where the first element can be empty: >
			:let items = split(line, ':', 1)
<		The opposite function is |join()|.


str2nr( {expr} [, {base}])				*str2nr()*
		Convert string {expr} to a number.
		{base} is the conversion base, it can be 8, 10 or 16.
		When {base} is omitted base 10 is used.  This also means that
		a leading zero doesn't cause octal conversion to be used, as
		with the default String to Number conversion.
		When {base} is 16 a leading "0x" or "0X" is ignored.  With a
		different base the result will be zero.
		Text after the number is silently ignored.

							*strftime()*
strftime({format} [, {time}])
		結果は文字列で、{format}に従って日付や時間がフォーマットされた
		ものになる。{time}が与えられた場合にはそれを使うが、省略された
		場合には現在時刻を使用する。受け付け可能な文字列{format}は使用
		するシステムに依存するので、ポータブルとは言えない。フォーマッ
		トについてはCの関数strftime()のマニュアルを参照。結果は最大80
		文字に制限される。|localtime()|と|getftime()|も参照。例:
>		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997
>		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25
>		  :echo strftime("%y%m%d %T")	   970427 11:53:55
>		  :echo strftime("%H:%M")	   11:55
>		  :echo strftime("%c", getftime("file.c"))
>						   file.cの更新時刻を表示

<		Not available on all systems.  To check use: >
			:if exists("*strftime")

stridx({haystack}, {needle} [, {start}])		*stridx()*
		The result is a Number, which gives the byte index in
		{haystack} of the first occurrence of the String {needle}.
		If {start} is specified, the search starts at index {start}.
		This can be used to find a second match: >
			:let comma1 = stridx(line, ",")
			:let comma2 = stridx(line, ",", comma1 + 1)
<		The search is done case-sensitive.
		For pattern searches use |match()|.
		-1 is returned if the {needle} does not occur in {haystack}.
		See also |strridx()|.
		Examples: >
		  :echo stridx("An Example", "Example")	     3
		  :echo stridx("Starting point", "Start")    0
		  :echo stridx("Starting point", "start")   -1
<						*strstr()* *strchr()*
		stridx() works similar to the C function strstr().  When used
		with a single character it works similar to strchr().

							*string()*
string({expr})	Return {expr} converted to a String.  If {expr} is a Number,
		String or a composition of them, then the result can be parsed
		back with |eval()|.
			{expr} type	result ~
			String		'string'
			Number		123
			Funcref		function('name')
			List		[item, item]
			Dictionary	{key: value, key: value}
		Note that in String values the ' character is doubled.
		Also see |strtrans()|.

							*strlen()*
strlen({expr})	結果は数値で、文字列{expr}の長さ。
		If you want to count the number of multi-byte characters (not
		counting composing characters) use something like this: >

			:let len = strlen(substitute(str, ".", "x", "g"))
<
		If the argument is a Number it is first converted to a String.
		For other types an error is given.
		Also see |len()|.


							*strpart()*
strpart({src}, {start}, {len})
		結果は文字列で、{src}の{start}番目の文字から始まる、長さ{len}
		の部分文字列。存在しない文字を含むように範囲を指定しても、エ
		ラーにはならない。単に文字が省略されるだけである。
>			strpart("abcdefg", 3, 2)    == "de"
>			strpart("abcdefg", -2, 4)   == "ab"
>			strpart("abcdefg", 5, 4)    == "fg"
		注意: 文字列の最初の文字を指定するためには、{start}は0でなけれ
		ばならない。カーソルのある位置から3文字を取得する例:
>			strpart(getline("."), col(".") - 1, 3)

strridx({haystack}, {needle} [, {start}])			*strridx()*
		The result is a Number, which gives the byte index in
		{haystack} of the last occurrence of the String {needle}.
		When {start} is specified, matches beyond this index are
		ignored.  This can be used to find a match before a previous
		match: >
			:let lastcomma = strridx(line, ",")
			:let comma2 = strridx(line, ",", lastcomma - 1)
<		The search is done case-sensitive.
		For pattern searches use |match()|.
		-1 is returned if the {needle} does not occur in {haystack}.
		If the {needle} is empty the length of {haystack} is returned.
		See also |stridx()|.  Examples: >
		  :echo strridx("an angry armadillo", "an")	     3
<							*strrchr()*
		When used with a single character it works similar to the C
		function strrchr().

							*strtrans()*
strtrans({expr})
		結果は文字列で、{expr}内の表示不可能な文字を|'isprint'|で指定
		される、表示可能な文字に変換したもの。ウィンドウに表示すること
		ができるようになる。例:
>			echo strtrans(@a)
		これはレジスタの中の改行を、改行として表示する変わりに"^@"と表
		示する。

submatch({nr})						*submatch()*
		Only for an expression in a |:substitute| command.  Returns
		the {nr}'th submatch of the matched text.  When {nr} is 0
		the whole matched text is returned.
		Example: >
			:s/\d\+/\=submatch(0) + 1/
<		This finds the first number in the line and adds one to it.
		A line break is included as a newline character.

							*substitute()*
substitute({expr}, {pat}, {sub}, {flags})
		結果は文字列で、{expr}内で最初に{pat}にマッチした部分を{sub}に
		置換えたコピーになる。これはコマンド":substitute"(一切のフラグ
		無し)のように働く。しかしマッチングは常にオプション'magic'が設
		定され、オプション'cpoptions'は空にして実行される(スクリプトを
		ポータブルにするため)。加えて{sub}内の"~"は前回の{sub}に置換さ
		れることはない。
		{sub}内の幾つかのコードには|sub-replaced-special|の特殊な意味
		があることに注意。例えば、何かの文字列をリテラルの"\n"に置換え
		るためには、"\\\\n"か'\\n'を使う必要がある。
		{pat}が{expr}の何処にもマッチしなければ、{expr}が何の変更も受
		けずに返される。
		{flags}が"g"であれば{expr}内の{pat}にマッチする総ての部分が置
		換される。それを希望しない場合には{flags}は""にすべきである。
		例:
>			:let &path = substitute(&path, ",\\=[^,]*$", "", "")
		これはオプション'path'の最後のコンポーネントを削除する。
>			:echo substitute("testing", ".*", "\\U\\0", "")
		結果は"TESTING"。

synID({lnum}, {col}, {trans})				*synID()*
		結果は数値で、現在のウィンドウ内での位置{lnum}と{col}の位置の
		シンタックスID。
		シンタックスIDは|synIDattr()|と|synIDtrans()|に渡すことで、テ
		キストについてのシンタックス情報を取得するのに使用できる。
		
		最左のカラムを指定するには{col}に1を、最初の行を指定するには
		{line}に1を指定する。'synmaxcol' applies, in a longer line
		zero is returned.

		{trans}が非ゼロならば、透過属性のアイテムは省略され、実際に表
		示されているアイテムが評価対象になる。これは実際に有効になって
		いるカラーを知りたい時に役に立つ。{trans}がゼロならば、透過属
		性のアイテムが返される。これはどのシンタックスアイテムが有効に
		なっているかを知りたい時に役に立つ(例:カッコの中とか)。
		警告: この関数は非常に遅い。ファイルを順方向に走査する時にだけ
		ベストなスピードが得られる。

		例(カーソルの下のシンタックスアイテムの名前を表示する):
>			:echo synIDattr(synID(line("."), col("."), 1), "name")

							*synIDattr()*
synIDattr({synID}, {what} [, {mode}])
		結果は文字列で、{synID}の属性{what}の内容を示す。これはシン
		タックスアイテムの情報を取得するのに使用できる。
		{mode}には取得したいモードの属性に応じて、"gui"か"cterm"か
		"term"が指定できる。{mode}が省略されるか、無効な値が指定された
		場合、現在有効になっているハイライトモードが使用される(GUI、
		cterm、termのどれか)
		ハイライトグループにリンクされた属性を取得するにはsynIDtrans()
		を使用する。
		{what}		結果
		"name"		シンタックスアイテムの名前
		"fg"		前景色(GUI:カラー名、cterm:文字列としてのカ
				ラー番号、term空文字列)
		"bg"		背景色("fg"同様)
		"fg#"		"fg"同様だが、"#RRGGBB"のフォーマットで
		"bg#"		"bg"同様だが、"#RRGGBB"のフォーマットで
		"bold"		太字なら"1"
		"italic"	斜体なら"1"
		"reverse"	反転なら"1"
		"inverse"	反転(原文inverse)なら"1"(reverseと等価)
		"underline"	下線付きなら"1"
		"undercurl"	"1" if undercurled

		GUIではなく、ctermモードが要求されていない場合、"fg#"は"fg"と
		同じに、"bg#"は"bg"と同じになる。

		例(カーソルの下のシンタックスアイテムの名前を表示する):
>	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")

							*synIDtrans()*
synIDtrans({synID})
		結果は数値で、{synID}をシンタックスIDに変換したもの。キャラク
		タをハイライト表示しているシンタックスグループのIDである。
		":highlight link"によって与えられるハイライトのリンクはこれに
		従っている。

system({expr} [, {input}])				*system()* *E677*
		シェルコマンド{expr}の実行結果を得る。
		{input}が与えられた場合は、この文字列はファイルに書き出され、
		コマンドの標準入力として渡される。この文字列はそのまま(as-is)
		書き出され、正しい改行文字を使うよう自分自身で気を付けなければ
		ならない。パイプは使われない。
		注意: {expr}内の改行はコマンドを失敗させるだろう。
		'shellquote'と'shellxquote'に入っている文字は問題を引き起こす
		かもしれない。
		対話的なコマンドを使用することはできない。
		結果は文字列。例: >

			:let files = system("ls")

<		システムに依存しないような結果にするために、シェルの出力にはマッ
		キントッシュにおいては<CR>を<NL>に変換し、DOS系のシステムにお
		いては<CR><NL>を<NL>に変換するフィルタを作用させている。
		実行されるコマンドはいくつかのオプションを適用して構成される:
	'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir' {tmp} 'shellxquote'
		({tmp}は自動的に生成されるファイル名)
		UnixとOS/2ではコマンドの連結ができるように{expr}の両側に波括弧
		が置かれる。

		コマンドは「coocked」モードで実行される。そのためCTRL-Cでコマ
		ンドを中断できる(少なくともUnixでは)。

		エラーコードは|v:shell_error|に格納される。
		この関数は|restrict-mode|では失敗する。

		Note that any wrong value in the options mentioned above may
		make the function fail.  It has also been reported to fail
		when using a security agent application.
		Unlike ":!cmd" there is no automatic check for changed files.
		Use |:checktime| to force a check.

tabpagebuflist([{arg}])					*tabpagebuflist()*
		The result is a |List|, where each item is the number of the
		buffer associated with each window in the current tab page.
		{arg} specifies the number of tab page to be used.  When
		omitted the current tab page is used.
		When {arg} is invalid the number zero is returned.
		To get a list of all buffers in all tabs use this: >
			tablist = []
			for i in range(tabpagenr('$'))
			   call extend(tablist, tabpagebuflist(i + 1))
			endfor
<		Note that a buffer may appear in more than one window.


tabpagenr([{arg}])					*tabpagenr()*
		The result is a Number, which is the number of the current
		tab page.  The first tab page has number 1.
		When the optional argument is "$", the number of the last tab
		page is returned (the tab page count).
		The number can be used with the |:tab| command.


tabpagewinnr({tabarg}, [{arg}])				*tabpagewinnr()*
		Like |winnr()| but for tab page {arg}.
		{tabarg} specifies the number of tab page to be used.
		{arg} is used like with |winnr()|:
		- When omitted the current window number is returned.  This is
		  the window which will be used when going to this tab page.
		- When "$" the number of windows is returned.
		- When "#" the previous window nr is returned.
		Useful examples: >
		    tabpagewinnr(1)	    " current window of tab page 1
		    tabpagewinnr(4, '$')    " number of windows in tab page 4
<		When {tabarg} is invalid zero is returned.

							*tagfiles()*
tagfiles()	Returns a |List| with the file names used to search for tags
		for the current buffer.  This is the 'tags' option expanded.


taglist({expr})							*taglist()*
		Returns a list of tags matching the regular expression {expr}.
		Each list item is a dictionary with at least the following
		entries:
			name		Name of the tag.
			filename	Name of the file where the tag is
					defined.  It is either relative to the
					current directory or a full path.
			cmd		Ex command used to locate the tag in
					the file.
			kind		Type of the tag.  The value for this
					entry depends on the language specific
					kind values.  Only available when
					using a tags file generated by
					Exuberant ctags or hdrtag.
			static		A file specific tag.  Refer to
					|static-tag| for more information.
		More entries may be present, depending on the content of the
		tags file: access, implementation, inherits and signature.
		Refer to the ctags documentation for information about these
		fields.  For C code the fields "struct", "class" and "enum"
		may appear, they give the name of the entity the tag is
		contained in.

		The ex-command 'cmd' can be either an ex search pattern, a
		line number or a line number followed by a byte number.

		If there are no matching tags, then an empty list is returned.

		To get an exact tag match, the anchors '^' and '$' should be
		used in {expr}.  Refer to |tag-regexp| for more information
		about the tag search regular expression pattern.

		Refer to |'tags'| for information about how the tags file is
		located by Vim. Refer to |tags-file-format| for the format of
		the tags file generated by the different ctags tools.

						*tempname()* *temp-file-name*
tempname()
		結果は文字列で、存在しないファイルのファイル名を示す。これはテ
		ンポラリファイルの名前として使用可能である。少なくとも連続26回
		の呼出しまでは違う名前を生成することが保証される。例:
>			let tmpfile = tempname()
>			exe "redir > " . tmpfile

tolower({expr})						*tolower()*
		The result is a copy of the String given, with all uppercase
		characters turned into lowercase (just like applying |gu| to
		the string).

toupper({expr})						*toupper()*
		The result is a copy of the String given, with all lowercase
		characters turned into uppercase (just like applying |gU| to
		the string).

tr({src}, {fromstr}, {tostr})				*tr()*
		The result is a copy of the {src} string with all characters
		which appear in {fromstr} replaced by the character in that
		position in the {tostr} string.  Thus the first character in
		{fromstr} is translated into the first character in {tostr}
		and so on.  Exactly like the unix "tr" command.
		This code also deals with multibyte characters properly.

		Examples: >
			echo tr("hello there", "ht", "HT")
<		returns "Hello THere" >
			echo tr("<blob>", "<>", "{}")
<		returns "{blob}"

							*type()*
type({expr})	The result is a Number, depending on the type of {expr}:
			Number:	    0
			String:	    1
			Funcref:    2
			List:	    3
			Dictionary: 4
		To avoid the magic numbers it should be used this way: >
			:if type(myvar) == type(0)
			:if type(myvar) == type("")
			:if type(myvar) == type(function("tr"))
			:if type(myvar) == type([])
			:if type(myvar) == type({})

values({dict})						*values()*
		Return a |List| with all the values of {dict}.  The |List| is
		in arbitrary order.


							*virtcol()*
virtcol({expr})
		結果は数値で、{expr}で与えられるファイルの位置の、スクリーン上
		での列の位置を示す。返る値は、指定された位置にあるキャラクタの
		末尾が、スクリーン座標(の列)でどこに存在するかである。<Tab>(タ
		ブ文字)が指定した位置にあった場合には、戻り値はそのタブの最後
		のカラム(列)位置になる。具体的に、'ts'が8に設定された状態でカ
		ラム1に<Tab>があった場合、戻ってくる値は8になる。
		For the use of {expr} see |col()|.  Additionally you can use
		[lnum, col]: a |List| with the line and column number.  When
		"lnum" or "col" is out of range then virtcol() returns zero.
		When 'virtualedit' is used it can be [lnum, col, off], where
		"off" is the offset in screen columns from the start of the
		character.  E.g., a position within a <Tab> or after the last
		character.
		可能な位置指定:
		    .	    カーソルの位置
		    'x	    マークxの位置(マークが設定されていない場合、0が返
			    る)
		現在のファイルに対して設定されているマークだけが使用可能なこと
		に注意。
		例: >
  virtcol(".")	    "foo^Lbar"の"^L"の位置にカーソル、戻り値5
  virtcol("$")	   with text "foo^Lbar", returns 9
  virtcol("'t")    "    there"の'h'に'tを設定、戻り値6
<		最初の列は1となる。0はエラーとして返される。
		A more advanced example that echoes the maximum length of
		all lines: >
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))

							*visualmode()*
visualmode()
		結果は文字列で、最後に使われたVisualモードを教えてくれる。初期
		状態では単に空文字列を返すだけだが、一度でもVisualモードが使わ
		れた場合、その種類によって"v"か"V"か"<CTRL-V>"(CTRL-Vのキャラ
		クタが1文字で)返される。これはそれぞれキャラクタ選択、行選択、
		ブロック選択を意味している。
		例:
>			exe "normal " . visualmode()
		これは最後に使われたのと同じVisualモードに入る。また、スクリプ
		トの動作を、最後に使われたVisualモードに応じて変更したい場合に
		も便利だろう。

							*winbufnr()*
winbufnr({nr})	結果は数値で、{nr}番目のウィンドウに関連付けられているバッファ
		の番号。{nr}が0の場合、現在のウィンドウに関連付けられている
		バッファの番号が返る。{nr}で存在しないウィンドウを指定した場合
		には-1が返る。
		例:
>  echo "The file in the current window is " . bufname(winbufnr(0))

							*wincol()*
wincol()	The result is a Number, which is the virtual column of the
		cursor in the window.  This is counting screen cells from the
		left side of the window.  The leftmost column is one.

							*winheight()*
winheight({nr})
		結果は数値で、{nr}で示されるウィンドウの高さ(行数)を示す。{nr}
		が0ならば、現在のウィンドウの高さが返る。{nr}というウィンドウ
		が存在しない場合、-1が返る。存在しているウィンドウは、絶対に0
		かそれ以上の高さを持っている。
		例:
>  echo "The current window has " . winheight(0) . " lines."

							*winline()*
winline()	The result is a Number, which is the screen line of the cursor
		in the window.  This is counting screen lines from the top of
		the window.  The first line is one.
		If the cursor was moved the view on the file will be updated
		first, this may cause a scroll.

							*winnr()*
winnr()		結果は現在のウィンドウを示す数値。最上位のウィンドウは1であ
		る。
		When the optional argument is "$", the number of the
		last window is returned (the window count).
		When the optional argument is "#", the number of the last
		accessed window is returned (where |CTRL-W_p| goes to).
		If there is no previous window or it is in another tab page 0
		is returned.
		The number can be used with |CTRL-W_w| and ":wincmd w"
		|:wincmd|.
		Also see |tabpagewinnr()|.

							*winrestcmd()*
winrestcmd()	Returns a sequence of |:resize| commands that should restore
		the current window sizes.  Only works properly when no windows
		are opened or closed and the current window and tab page is
		unchanged.
		Example: >
			:let cmd = winrestcmd()
			:call MessWithWindowSizes()
			:exe cmd
<
							*winrestview()*
winrestview({dict})
		Uses the |Dictionary| returned by |winsaveview()| to restore
		the view of the current window.
		If you have changed the values the result is unpredictable.
		If the window size changed the result won't be the same.

							*winsaveview()*
winsaveview()	Returns a |Dictionary| that contains information to restore
		the view of the current window.  Use |winrestview()| to
		restore the view.
		This is useful if you have a mapping that jumps around in the
		buffer and you want to go back to the original view.
		This does not save fold information.  Use the 'foldenable'
		option to temporarily switch off folding, so that folds are
		not opened when moving around.
		The return value includes:
			lnum		cursor line number
			col		cursor column
			coladd		cursor column offset for 'virtualedit'
			curswant	column for vertical movement
			topline		first line in the window
			topfill		filler lines, only in diff mode
			leftcol		first column displayed
			skipcol		columns skipped
		Note that no option values are saved.


winwidth({nr})						*winwidth()*
		The result is a Number, which is the width of window {nr}.
		When {nr} is zero, the width of the current window is
		returned.  When window {nr} doesn't exist, -1 is returned.
		An existing window always has a width of zero or more.
		Examples: >
  :echo "The current window has " . winwidth(0) . " columns."
  :if winwidth(0) <= 50
  :  exe "normal 50\<C-W>|"
  :endif
<
							*writefile()*
writefile({list}, {fname} [, {binary}])
		Write |List| {list} to file {fname}.  Each list item is
		separated with a NL.  Each list item must be a String or
		Number.
		When {binary} is equal to "b" binary mode is used: There will
		not be a NL after the last list item.  An empty item at the
		end does cause the last line in the file to end in a NL.
		All NL characters are replaced with a NUL character.
		Inserting CR characters needs to be done before passing {list}
		to writefile().
		An existing file is overwritten, if possible.
		When the write fails -1 is returned, otherwise 0.  There is an
		error message if the file can't be created or when writing
		fails.
		Also see |readfile()|.
		To copy a file byte for byte: >
			:let fl = readfile("foo", "b")
			:call writefile(fl, "foocopy", "b")
<
							*feature-list*
機能は大別して3つの系統に分けられる:
1.  コンパイル時に|+feature-list|とした時にだけサポートされる機能。例: >
		:if has("cindent")
2.  ある状態の時にだけサポートされる機能。例: >
		:if has("gui_running")
<							*has-patch*
3.  Included patches.  First check |v:version| for the version of Vim.
    Then the "patch123" feature means that patch 123 has been included for
    this version.  Example (checking version 6.2.148 or later): >
	:if v:version > 602 || v:version == 602 && has("patch148")
<   Note that it's possible for patch 147 to be omitted even though 148 is
    included.


all_builtin_terms	総ての組込みターミナルを有効にしてコンパイル
amiga			AMIGAバージョン
arabic			Compiled with Arabic support |Arabic|.
arp			ARPをサポート (Amiga)
autocmd			autocommandsをサポート。|autocommand|
balloon_eval		Compiled with |balloon-eval| support.
balloon_multiline	GUI supports multiline balloons.
beos			BeOSバージョン
browse			|:browse|をサポートし、browseが恐らく動作する
builtin_terms		幾つかの組込みターミナルが有効
byte_offset		'statusline'において'o'がサポートされる
cindent			'cindent'をサポート
clientserver		Compiled with remote invocation support |clientserver|.
clipboard		'clipboard'をサポート
cmdline_compl		|cmdline-completion| コマンドライン補完をサポート
cmdline_hist		Compiled with |cmdline-history| support.
cmdline_info		'showcmd'と'ruler'をサポート
comments		|'comments'|をサポート
cryptv			暗号化をサポート |encryption|
cscope			|cscope|をサポート
compatible		Vi互換度を非常に高めてコンパイルされている
debug			デバッグバージョンである
dialog_con		コンソールダイアログのサポート
dialog_gui		GUIダイアログのサポート
diff			Compiled with |vimdiff| and 'diff' support.
digraphs		digraphsをサポート
dnd			Compiled with support for the "~ register |quote_~|.
dos32			32ビットDOSバージョン (DJGPP)
dos16			16ビットDOSバージョン
ebcdic			Compiled on a machine with ebcdic character set.
emacs_tags		Emacs式のタグファイルをサポート
eval			式評価をサポート。もちろん常に真。
ex_extra		拡張EXコマンドをサポート |+ex_extra|.
extra_search		|'incsearch'|と|'hlsearch'|をサポート
farsi			|farsi|をサポート
file_in_path		|gf|と|<cfile>|をサポート
filterpipe		When 'shelltemp' is off pipes are used for shell
			read/write/filter commands
find_in_path		includeファイル内の検索をサポート |+find_in_path|
fname_case		ファイル名の大文字小文字が区別される(Amiga,MS-DOS,
			そしてWindowsでは区別されないので偽)
folding			Compiled with |folding| support.
footer			Compiled with GUI footer support. |gui-footer|
fork			system()の代わりにfork()/exec()を用いている
gettext			Compiled with message translation |multi-lang|
gui			GUIが有効である
gui_athena		AthenaのGUIが有効である
gui_gtk			GTK+のGUIが有効である
gui_gtk2		Compiled with GTK+ 2 GUI (gui_gtk is also defined).
gui_mac			マッキントッシュのGUIが有効である
gui_motif		MotifのGUIが有効である
gui_photon		Compiled with Photon GUI.
gui_win32		Win32のGUIが有効である
gui_win32s		Win32sのGUIが有効である (Windows 3.1)
gui_running		VimがGUIモードで起動している、もしくは間もなくする
hangul_input		ハングル入力サポート
insert_expand		インサートモード時にCTRL-Xの展開がサポートされる
jumplist		Compiled with |jumplist| support.
keymap			Compiled with 'keymap' support.
langmap			'langmap'サポート
libcall			Compiled with |libcall()| support.
linebreak		'linebreak', 'breakat'そして'showbreak'をサポート
lispindent		lisp式のインデントをサポート
listcmds		Compiled with commands for the buffer list |:files|
			and the argument list |arglist|.
localmap		Compiled with local mappings and abbr. |:map-local|
mac			マッキントッシュバージョン
macunix			Macintosh version of Vim, using Unix files (OS-X).
menu			|:menu|をサポート
mksession		|:mksession|をサポート
modify_fname		ファイル名変換子をサポート |filename-modifiers|
mouse			マウスをサポート
mouseshape		Compiled with support for 'mouseshape'.
mouse_dec		DECのターミナルマウスをサポート
mouse_gpm		gpmをサポート (Linuxのコンソールマウス)
mouse_netterm		nettermのマウスをサポート
mouse_pterm		Compiled with support for qnx pterm mouse.
mouse_xterm		xtermのマウスをサポート
multi_byte		中国語・日本語・韓国語その他の言語をサポート
multi_byte_ime		IMEによる入力をサポート
multi_lang		Compiled with support for multiple languages.
mzscheme		Compiled with MzScheme interface |mzscheme|.
netbeans_intg		Compiled with support for |netbeans|.
netbeans_enabled	Compiled with support for |netbeans| and it's used.
ole			Win32にてOLEオートメーションをサポート
os2			OS/2バージョン
osfiletype		osfiletypesをサポート |+osfiletype|
path_extra		Compiled with up/downwards search in 'path' and 'tags'
perl			Perlインターフェースをサポート
postscript		Compiled with PostScript file printing.
python			Pythonインターフェースをサポート
qnx			QNX version of Vim.
quickfix		|quickfix|をサポート
reltime			Compiled with |reltime()| support.
rightleft		'rightleft'をサポート
ruby			Compiled with Ruby interface |ruby|.
scrollbind		'scrollbind'をサポート
showcmd			'showcmd'をサポート
signs			Compiled with |:sign| support.
smartindent		'smartindent'をサポート
sniff			SniFFインターフェースをサポート
statusline		'statusline', 'rulerformat'そして'titlestring'と
			'iconstring'の特殊フォーマットをサポート
sun_workshop		Compiled with support for Sun |workshop|.
spell			Compiled with spell checking support |spell|.
syntax			シンタックスハイライティングをサポート
syntax_items		現在のバッファに有効なシンタックスが設定されている
system			fork()/exec()の代わりにsystem()が使用されている
tag_binary		タグファイル内のバイナリサーチ |tag-binary-search|
tag_old_static		旧式の静的tagsをサポート |tag-old-static|
tag_any_white		タグファイル内の空白文字をサポート
			files |tag-any-white|.
tcl			TCLインターフェースをサポート
terminfo		termcapの代わりにterminfoをサポート
termresponse		Compiled with support for |t_RV| and |v:termresponse|.
textobjects		|text-objects|をサポート
tgetent			tgetentをサポート。termcapかterminfoファイルが使用可能
title			ウィンドウタイトルをサポート |'title'|.
toolbar			Compiled with support for |gui-toolbar|.
unix			UNIXバージョン
user_commands		ユーザ定義コマンドをサポート
viminfo			viminfoをサポート
vim_starting            Vimの初期化プロセス中は真となる
vertsplit		Compiled with vertically split windows |:vsplit|.
virtualedit		Compiled with 'virtualedit' option.
visual			Compiled with Visual mode.
visualextra		拡張Visualモードをサポート |blockwise-operators|
vms			VMSバージョン
vreplace		Compiled with |gR| and |gr| commands.
wildignore		Compiled with 'wildignore' option.
wildmenu		オプション'wildmenu'を指定してコンパイル
wildignore		オプション'wildignore'を指定してコンパイル
windows			Compiled with support for more than one window.
winaltkeys		オプション'winaltkeys'を指定してコンパイル
win16			Win16バージョン(Windows 3.1)
win32			Win32バージョン(Windows 95/NT)
win32unix		Win32 version of Vim, using Unix files (Cygwin)
win95			Win32 version for MS-Windows 95/98/ME.
writebackup		オプション'writebackup'が起動時にonになる
xfontset		X fontsetをサポート |xfontset|
xim			XIMをサポート |xim|
xsmp			Compiled with X session management support.
xsmp_interact		Compiled with interactive X session management support.
xterm_clipboard		xtermのクリップボードサポート
xterm_save		xtermのスクリーンの保存復帰をサポート
x11			X11をサポート

							*string-match*
Matching a pattern in a String

A regexp pattern as explained at |pattern| is normally used to find a match in
the buffer lines.  When a pattern is used to find a match in a String, almost
everything works in the same way.  The difference is that a String is handled
like it is one line.  When it contains a "\n" character, this is not seen as a
line break for the pattern.  It can be matched with a "\n" in the pattern, or
with ".".  Example: >
	:let a = "aaaa\nxxxx"
	:echo matchstr(a, "..\n..")
	aa
	xx
	:echo matchstr(a, "a.x")
	a
	x

Don't forget that "^" will only match at the first character of the String and
"$" at the last character of the string.  They don't match after or before a
"\n".

==============================================================================
5. 関数定義						*user-functions*

新しい関数を定義することができる。これらは組込み関数と同様に呼び出すことができ
る。関数は一連のExコマンドを実行する。ノーマルモードコマンドはコマンド
|:normal|によって実行できる。

関数名は組込み関数との混同を避ける為、大文字で始まらなければならない。他のスク
リプトで同じ関数名を使用してしまうことを避ける為に、露骨に短い名前は避けるべき
である。関数名を例えば"HTMLcolor()"のように、スクリプトの名前から始めるという
のは良い習慣である。

It's also possible to use curly braces, see |curly-braces-names|.  And the
|autoload| facility is useful to define a function only when it's called.

							*local-function*
A function local to a script must start with "s:".  A local script function
can only be called from within the script and from functions, user commands
and autocommands defined in the script.  It is also possible to call the
function from a mappings defined in the script, but then |<SID>| must be used
instead of "s:" when the mapping is expanded outside of the script.

					*:fu* *:function* *E128* *E129* *E123*
:fu[nction]		総ての関数と、その引数を表示する。

:fu[nction] {name}	関数{name}を表示する。
			{name} can also be a |Dictionary| entry that is a
			|Funcref|: >
				:function dict.init

:fu[nction] /{pattern}	List functions with a name matching {pattern}.
			Example that lists all functions ending with "File": >
				:function /File$
<
							*:function-verbose*
When 'verbose' is non-zero, listing a function will also display where it was
last defined. Example: >

    :verbose function SetFileTypeSH
	function SetFileTypeSH(name)
	    Last set from /usr/share/vim/vim-7.0/filetype.vim
<
See |:verbose-cmd| for more information.

							*E124* *E125*
:fu[nction][!] {name}([arguments]) [range] [abort] [dict]
			{name}という名前で新しい関数を定義する。関数名はアル
			ファベットと数字と'_'からなり、アルファベットの大文字
			で始まらなければならない。
			引数は、与えられた名前によって定義される。関数のなかで
			は"a:name"("a:"を引数に接頭)のようにして参照することが
			できる。
			引数はカンマで区切ることで、最大20まで与えることができ
			る。最後の引数を"..."にすることで、可変長の引数を使用
			できる。関数の中では"a:1"や"a:2"のようにして可変長の引
			数にアクセスできる。"a:0"は可変長引数が幾つあるかを示
			している(0であること、つまり引数がそれ以上ないこともあ
			る)。
			"..."が使われていない時は、引数の数は名前付きの引数の
			個数を示す。"..."を使った時には引数の数は大きくなるだ
			ろう。
			関数を引数無しで定義することも可能である。その時でも()
			は付けなければならない。
			関数の本体は、宣言の次の行から始まり、対応する
			|:endfunction|までになる。関数の中で別の関数を定義する
			ことも可能である。
			この名前で定義される関数が既に定義済みで[!]が使用され
			なかった場合、エラーとなる。[!]が使用されていれば、そ
			れまで存在していた関数は、速やかに新しいものへ置換えら
			れる。
			引数[range]を追加した場合、関数は「領域」を管理するこ
			とができる。「領域」は"a:firstline"と"a:lastline"に
			よって渡される。[range]がなかった場合、":call"が「領
			域」を指定されて実行されると、1行1行について、カーソル
			をその行の先頭に置いた状態で関数を呼び出すことになる。
			|function-range-example|を参照。
			引数[abort]を追加すると、関数の実行中にエラーに遭遇し
			次第、即関数は中断される。
			関数の実行によって、最後に使用されたサーチパターン、及
			びredoコマンドの"."の内容は変更されない。

								*E127* *E122*
			When a function by this name already exists and [!] is
			not used an error message is given.  When [!] is used,
			an existing function is silently replaced.  Unless it
			is currently being executed, that is an error.

			For the {arguments} see |function-argument|.

						*a:firstline* *a:lastline*
			When the [range] argument is added, the function is
			expected to take care of a range itself.  The range is
			passed as "a:firstline" and "a:lastline".  If [range]
			is excluded, ":{range}call" will call the function for
			each line in the range, with the cursor on the start
			of each line.  See |function-range-example|.

			When the [abort] argument is added, the function will
			abort as soon as an error is detected.

			When the [dict] argument is added, the function must
			be invoked through an entry in a |Dictionary|.  The
			local variable "self" will then be set to the
			dictionary.  See |Dictionary-function|.

			The last used search pattern and the redo command "."
			will not be changed by the function.

					*:endf* *:endfunction* *E126* *E193*
:endf[unction]		関数定義の終了。このコマンド1つで1行とすること。他のコ
			マンドをいっしょに書いてはならない。

					*:delf* *:delfunction* *E130* *E131*
:delf[unction] {name}	関数{name}を削除する。
			{name} can also be a |Dictionary| entry that is a
			|Funcref|: >
				:delfunc dict.init
<			This will remove the "init" entry from "dict".  The
			function is deleted if there are no more references to
			it.
							*:retu* *:return* *E133*
:retu[rn] [expr]	関数から戻る。"[expr]"が与えられた場合、それは評価され
			関数の戻り値として呼出し側に渡される。"[expr]"が与えら
			れない場合、数値0が呼出し側に渡される。
			関数内に実行されない命令があるかどうかはチェックされな
			いことに留意すること。つまり、たとえ":return"命令の後
			に何か命令があったとしても、警告も何も与えられない。

			If the ":return" is used after a |:try| but before the
			matching |:finally| (if present), the commands
			following the ":finally" up to the matching |:endtry|
			are executed first.  This process applies to all
			nested ":try"s inside the function.  The function
			returns at the outermost ":endtry".

						*function-argument* *a:var*
An argument can be defined by giving its name.  In the function this can then
be used as "a:name" ("a:" for argument).
					*a:0* *a:1* *a:000* *E740* *...*
Up to 20 arguments can be given, separated by commas.  After the named
arguments an argument "..." can be specified, which means that more arguments
may optionally be following.  In the function the extra arguments can be used
as "a:1", "a:2", etc.  "a:0" is set to the number of extra arguments (which
can be 0).  "a:000" is set to a |List| that contains these arguments.  Note
that "a:1" is the same as "a:000[0]".
								*E742*
The a: scope and the variables in it cannot be changed, they are fixed.
However, if a |List| or |Dictionary| is used, you can changes their contents.
Thus you can pass a |List| to a function and have the function add an item to
it.  If you want to make sure the function cannot change a |List| or
|Dictionary| use |:lockvar|.

When not using "...", the number of arguments in a function call must be equal
to the number of named arguments.  When using "...", the number of arguments
may be larger.

It is also possible to define a function without any arguments.  You must
still supply the () then.  The body of the function follows in the next lines,
until the matching |:endfunction|.  It is allowed to define another function
inside a function body.

							*local-variables*
関数の中で変数を使うこともできる。これらは関数から戻ると消滅するローカル変数と
して振舞う。グローバル変数にアクセスするためには"g:"を付ける必要がある。

例: >
  :function Table(title, ...)
  :  echohl Title
  :  echo a:title
  :  echohl None
  :  echo a:0 . " items:"
  :  for s in a:000
  :    echon ' ' . s
  :  endfor
  :endfunction 

この関数は次のように呼ぶことが出きる: >
  let lines = Table("Table", "line1", "line2")
  let lines = Table("Empty Table")

一つ以上の値を返したい場合には、グローバル変数の名前を渡すようにする: >
  :function Compute(n1, n2)
  :  if a:n2 == 0
  :    return ["fail", 0]
  :  endif
  :  return ["ok", a:n1 / a:n2]
  :endfunction

この関数は次のように呼ぶことができる: >
  :let [success, div] = Compute(102, 6)
  :if success == "ok"
  :  echo div
  :endif
<

						*:cal* *:call* *E107* *E117*
:[range]cal[l] {name}([arguments])
		関数を呼び出す。関数の名前と引数は|:function|によって指定され
		るものである。引数は最大20まで使用可能。戻り値は破棄される。
		「領域」を受け付ける関数に「領域」を指定しなかった場合、関数は
		カーソルの現在位置について一度だけ呼び出される。
		「領域」を受け付けない関数に「領域」を指定した場合、その領域の
		一行ずつについて関数が呼び出される。その時カーソルは当該行の先
		頭に設定される。カーソルは「領域」の最下行の左端になる(恐らく
		最後の関数呼出しの結果、動いた先である)。引数は各呼出しについ
		て繰り返し評価される。それは次の例で確かめることができる:
						*function-range-example*  >
	:function Mynumber(arg)
	:  echo line(".") . " " . a:arg
	:endfunction
	:1,5call Mynumber(getline("."))
<
		"a:firstline"と"a:lastline"はとにかく定義されるので、「領域」
		の最初や最後で何か違った事をするのにも用いることができる。

		「領域」自身を扱っている関数の例:

>	:function Cont() range
>	:  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '
>	:endfunction
>	:4,8call Cont()

		この関数は「領域」の最初の行を除いた総ての行の先頭に、継続のた
		めの文字"\"を挿入する。


		When the function returns a composite value it can be further
		dereferenced, but the range will not be used then.  Example: >
	:4,8call GetDict().method()
<		Here GetDict() gets the range but method() does not.

								*E132*
関数の再帰的な使用はオプション|'maxfuncdepth'|によって制限することができる。

AUTOMATICALLY LOADING FUNCTIONS ~
							*autoload-functions*
When using many or large functions, it's possible to automatically define them
only when they are used.  There are two methods: with an autocommand and with
the "autoload" directory in 'runtimepath'.


Using an autocommand ~

This is introduced in the user manual, section |41.14|.

The autocommand is useful if you have a plugin that is a long Vim script file.
You can define the autocommand and quickly quit the script with |:finish|.
That makes Vim startup faster.  The autocommand should then load the same file
again, setting a variable to skip the |:finish| command.

Use the FuncUndefined autocommand event with a pattern that matches the
function(s) to be defined.  Example: >

	:au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim

The file "~/vim/bufnetfuncs.vim" should then define functions that start with
"BufNet".  Also see |FuncUndefined|.


Using an autoload script ~
							*autoload* *E746*
This is introduced in the user manual, section |41.15|.

Using a script in the "autoload" directory is simpler, but requires using
exactly the right file name.  A function that can be autoloaded has a name
like this: >

	:call filename#funcname()

When such a function is called, and it is not defined yet, Vim will search the
"autoload" directories in 'runtimepath' for a script file called
"filename.vim".  For example "~/.vim/autoload/filename.vim".  That file should
then define the function like this: >

	function filename#funcname()
	   echo "Done!"
	endfunction

The file name and the name used before the # in the function must match
exactly, and the defined function must have the name exactly as it will be
called.

It is possible to use subdirectories.  Every # in the function name works like
a path separator.  Thus when calling a function: >

	:call foo#bar#func()

Vim will look for the file "autoload/foo/bar.vim" in 'runtimepath'.

This also works when reading a variable that has not been set yet: >

	:let l = foo#bar#lvar

However, when the autoload script was already loaded it won't be loaded again
for an unknown variable.

When assigning a value to such a variable nothing special happens.  This can
be used to pass settings to the autoload script before it's loaded: >

	:let foo#bar#toggle = 1
	:call foo#bar#func()

Note that when you make a mistake and call a function that is supposed to be
defined in an autoload script, but the script doesn't actually define the
function, the script will be sourced every time you try to call the function.
And you will get an error message every time.

Also note that if you have two script files, and one calls a function in the
other and vise versa, before the used function is defined, it won't work.
Avoid using the autoload functionality at the toplevel.

Hint: If you distribute a bunch of scripts you can pack them together with the
|vimball| utility.  Also read the user manual |distribute-script|.

==============================================================================
6. Curly braces names					*curly-braces-names*

Wherever you can use a variable, you can use a "curly braces name" variable.
This is a regular variable name with one or more expressions wrapped in braces
{} like this: >
	my_{adjective}_variable

When Vim encounters this, it evaluates the expression inside the braces, puts
that in place of the expression, and re-interprets the whole as a variable
name.  So in the above example, if the variable "adjective" was set to
"noisy", then the reference would be to "my_noisy_variable", whereas if
"adjective" was set to "quiet", then it would be to "my_quiet_variable".

One application for this is to create a set of variables governed by an option
value.  For example, the statement >
	echo my_{&background}_message

would output the contents of "my_dark_message" or "my_light_message" depending
on the current value of 'background'.

You can use multiple brace pairs: >
	echo my_{adverb}_{adjective}_message
..or even nest them: >
	echo my_{ad{end_of_word}}_message
where "end_of_word" is either "verb" or "jective".

However, the expression inside the braces must evaluate to a valid single
variable name, e.g. this is invalid: >
	:let foo='a + b'
	:echo c{foo}d
.. since the result of expansion is "ca + bd", which is not a variable name.

						*curly-braces-function-names*
You can call and define functions by an evaluated name in a similar way.
Example: >
	:let func_end='whizz'
	:call my_func_{func_end}(parameter)

This would call the function "my_func_whizz(parameter)".

==============================================================================
7. Commands						*expression-commands*

:let {var-name} = {expr1}				*:let*
			内部変数{var-name}に式{expr1}の結果をセットする。変数
			の型は{expr1}によって決定される。{var-name}という変数
			がまだ存在しない場合、新たに作成される。

:let {var-name}[{idx}] = {expr1}			*E689*
			Set a list item to the result of the expression
			{expr1}.  {var-name} must refer to a list and {idx}
			must be a valid index in that list.  For nested list
			the index can be repeated.
			This cannot be used to add an item to a list.

							*E711* *E719*
:let {var-name}[{idx1}:{idx2}] = {expr1}		*E708* *E709* *E710*
			Set a sequence of items in a |List| to the result of
			the expression {expr1}, which must be a list with the
			correct number of items.
			{idx1} can be omitted, zero is used instead.
			{idx2} can be omitted, meaning the end of the list.
			When the selected range of items is partly past the
			end of the list, items will be added.

					*:let+=* *:let-=* *:let.=* *E734*
:let {var} += {expr1}	Like ":let {var} = {var} + {expr1}".
:let {var} -= {expr1}	Like ":let {var} = {var} - {expr1}".
:let {var} .= {expr1}	Like ":let {var} = {var} . {expr1}".
			These fail if {var} was not set yet and when the type
			of {var} and {expr1} don't fit the operator.


:let ${env-name} = {expr1}			*:let-environment* *:let-$*
			環境変数{env-name}に式{expr1}の結果をセットする。型は
			常に文字列。
:let ${env-name} .= {expr1}
			Append {expr1} to the environment variable {env-name}.
			If the environment variable didn't exist yet this
			works like "=".

:let @{reg-name} = {expr1}			*:let-register* *:let-@*
			式{expr1}の結果をレジスタ{reg-name}に書きこむ。
			{reg-name}は単一の文字でかつ、書きこむことのできるレジ
			スタでなければならない(|registers|を参照)。"@@"は名前
			無しレジスタとして使用でき、"@/"はサーチパターンとして
			使用できる。
			{expr1}の結果が<CR>か<NL>で終了していた場合、レジスタ
			は行単位で設定され、そうでなければキャラクタ単位で設定
			される。
			次のコマンドにより最後に検索したパターンをクリアするこ
			とができる: >
				:let @/ = ""
<			This is different from searching for an empty string,
			that would match everywhere.

:let @{reg-name} .= {expr1}
			Append {expr1} to register {reg-name}.  If the
			register was empty it's like setting it to {expr1}.

  A String or Number value is
			always converted to the type of the option.
			For an option local to a window or buffer the effect
			is just like using the |:set| command: both the local
			value and the global value are changed.
			Example: >
				:let &path = &path . ',/usr/local/include'

:let &{option-name} .= {expr1}
			For a string option: Append {expr1} to the value.
			Does not insert a comma like |:set+=|.

:let &{option-name} += {expr1}
:let &{option-name} -= {expr1}
			For a number or boolean option: Add or subtract
			{expr1}.

:let &l:{option-name} = {expr1}
:let &l:{option-name} .= {expr1}
:let &l:{option-name} += {expr1}
:let &l:{option-name} -= {expr1}
			Like above, but only set the local value of an option
			(if there is one).  Works like |:setlocal|.

:let &g:{option-name} = {expr1}
:let &g:{option-name} .= {expr1}
:let &g:{option-name} += {expr1}
:let &g:{option-name} -= {expr1}
			Like above, but only set the global value of an option
			(if there is one).  Works like |:setglobal|.

:let [{name1}, {name2}, ...] = {expr1}		*:let-unpack* *E687* *E688*
			{expr1} must evaluate to a |List|.  The first item in
			the list is assigned to {name1}, the second item to
			{name2}, etc.
			The number of names must match the number of items in
			the |List|.
			Each name can be one of the items of the ":let"
			command as mentioned above.
			Example: >
				:let [s, item] = GetItem(s)
<			Detail: {expr1} is evaluated first, then the
			assignments are done in sequence.  This matters if
			{name2} depends on {name1}.  Example: >
				:let x = [0, 1]
				:let i = 0
				:let [i, x[i]] = [1, 2]
				:echo x
<			The result is [0, 2].

:let [{name1}, {name2}, ...] .= {expr1}
:let [{name1}, {name2}, ...] += {expr1}
:let [{name1}, {name2}, ...] -= {expr1}
			Like above, but append/add/subtract the value for each
			|List| item.

:let [{name}, ..., ; {lastname}] = {expr1}
			Like |:let-unpack| above, but the |List| may have more
			items than there are names.  A list of the remaining
			items is assigned to {lastname}.  If there are no
			remaining items {lastname} is set to an empty list.
			Example: >
				:let [a, b; rest] = ["aval", "bval", 3, 4]
<
:let [{name}, ..., ; {lastname}] .= {expr1}
:let [{name}, ..., ; {lastname}] += {expr1}
:let [{name}, ..., ; {lastname}] -= {expr1}
			Like above, but append/add/subtract the value for each
			|List| item.
							*E106*
:let {var-name}	..	List the value of variable {var-name}.  Multiple
			variable names may be given.  Special names recognized
			here:				*E738*
			  g:	global variables
			  b:	local buffer variables
			  w:	local window variables
			  t:	local tab page variables
			  s:	script-local variables
			  l:	local function variables
			  v:	Vim variables.

:let			List the values of all variables.  The type of the
			variable is indicated before the value:
			    <nothing>	String
				#	Number
				*	Funcref


:unl[et][!] {name} ...				*:unlet* *:unl* *E108* *E795*
			Remove the internal variable {name}.  Several variable
			names can be given, they are all removed.  The name
			may also be a |List| or |Dictionary| item.
			With [!] no error message is given for non-existing
			variables.
			One or more items from a |List| can be removed: >
				:unlet list[3]	  " remove fourth item
				:unlet list[3:]   " remove fourth item to last
<			One item from a |Dictionary| can be removed at a time: >
				:unlet dict['two']
				:unlet dict.two

:lockv[ar][!] [depth] {name} ...			*:lockvar* *:lockv*
			Lock the internal variable {name}.  Locking means that
			it can no longer be changed (until it is unlocked).
			A locked variable can be deleted: >
				:lockvar v
				:let v = 'asdf'		" fails!
				:unlet v
<							*E741*
			If you try to change a locked variable you get an
			error message: "E741: Value of {name} is locked"

			[depth] is relevant when locking a |List| or
			|Dictionary|.  It specifies how deep the locking goes:
				1	Lock the |List| or |Dictionary| itself,
					cannot add or remove items, but can
					still change their values.
				2	Also lock the values, cannot change
					the items.  If an item is a |List| or
					|Dictionary|, cannot add or remove
					items, but can still change the
					values.
				3	Like 2 but for the |List| /
					|Dictionary| in the |List| /
					|Dictionary|, one level deeper.
			The default [depth] is 2, thus when {name} is a |List|
			or |Dictionary| the values cannot be changed.
								*E743*
			For unlimited depth use [!] and omit [depth].
			However, there is a maximum depth of 100 to catch
			loops.

			Note that when two variables refer to the same |List|
			and you lock one of them, the |List| will also be
			locked when used through the other variable.
			Example: >
				:let l = [0, 1, 2, 3]
				:let cl = l
				:lockvar l
				:let cl[1] = 99		" won't work!
<			You may want to make a copy of a list to avoid this.
			See |deepcopy()|.


:unlo[ckvar][!] [depth] {name} ...			*:unlockvar* *:unlo*
			Unlock the internal variable {name}.  Does the
			opposite of |:lockvar|.



:if {expr1}						*:if* *:endif* *:en*
:en[dif]		{expr1}が非ゼロと評価された場合に、対応する":else"か
			":endif"までの命令を実行する。

			バージョン4.5から5.0まで間のVimは、":if"と":endif"の間
			の総てのExコマンドは無視する。この2つのコマンドは将来
			の拡張性を、下位互換と同時に提供するためのものである。
			ネスティング(入れ子)が可能である。":else"や":elseif"は
			無視され、"else"部分は一切実行されないことに注意。

			あなたはこれを、旧バージョンとの互換性を保ったまま使用
			することができる: >
				:if version >= 500
				:  version-5-specific-commands
				:endif
<			The commands still need to be parsed to find the
			"endif".  Sometimes an older Vim has a problem with a
			new command.  For example, ":silent" is recognized as
			a ":substitute" command.  In that case ":execute" can
			avoid problems: >
				:if version >= 600
				:  execute "silent 1,$delete"
				:endif
<
			NOTE: The ":append" and ":insert" commands don't work
			properly in between ":if" and ":endif".


							*:else* *:el*
:el[se]			対応する":if"ブロックが実行されなかった場合には、これ
			に対応する":else"か":endif"までのコマンドが実行され
			る。

							*:elseif* *:elsei*
:elsei[f] {expr1}	":else" ":if"の省略形。":endif"を付け加える(入れ子にす
			る)手間を省くことができる。

:wh[ile] {expr1}			*:while* *:endwhile* *:wh* *:endw*
						*E170* *E585* *E588* *E733*
:endw[hile]		{expr1}が非ゼロとして評価される間、":while"と
			":endwhile"の間のコマンドを繰り返し実行する。
			ループの内側でエラーが生じた場合、endwhileの直後から実
			行が再開される。
			例: >
				:let lnum = 1
				:while lnum <= line("$")
				   :call FixLine(lnum)
				   :let lnum = lnum + 1
				:endwhile
< 
		注意: ":append"や":insert"コマンドは":while"ループの内側では正
		しく動かない。

:for {var} in {list}					*:for* *E690* *E732*
:endfo[r]						*:endfo* *:endfor*
			Repeat the commands between ":for" and ":endfor" for
			each item in {list}.  Variable {var} is set to the
			value of each item.
			When an error is detected for a command inside the
			loop, execution continues after the "endfor".
			Changing {list} inside the loop affects what items are
			used.  Make a copy if this is unwanted: >
				:for item in copy(mylist)
<			When not making a copy, Vim stores a reference to the
			next item in the list, before executing the commands
			with the current item.  Thus the current item can be
			removed without effect.  Removing any later item means
			it will not be found.  Thus the following example
			works (an inefficient way to make a list empty): >
				:for item in mylist
				   :call remove(mylist, 0)
				:endfor
<			Note that reordering the list (e.g., with sort() or
			reverse()) may have unexpected effects.
			Note that the type of each list item should be
			identical to avoid errors for the type of {var}
			changing.  Unlet the variable at the end of the loop
			to allow multiple item types.

:for {var} in {list}					*:for* *E690* *E732*
:endfo[r]						*:endfo* *:endfor*
			Repeat the commands between ":for" and ":endfor" for
			each item in {list}.  Variable {var} is set to the
			value of each item.
			When an error is detected for a command inside the
			loop, execution continues after the "endfor".
			Changing {list} inside the loop affects what items are
			used.  Make a copy if this is unwanted: >
				:for item in copy(mylist)
<			When not making a copy, Vim stores a reference to the
			next item in the list, before executing the commands
			with the current item.  Thus the current item can be
			removed without effect.  Removing any later item means
			it will not be found.  Thus the following example
			works (an inefficient way to make a list empty): >
				:for item in mylist
				   :call remove(mylist, 0)
				:endfor
<			Note that reordering the list (e.g., with sort() or
			reverse()) may have unexpected effects.
			Note that the type of each list item should be
			identical to avoid errors for the type of {var}
			changing.  Unlet the variable at the end of the loop
			to allow multiple item types.

:for [{var1}, {var2}, ...] in {listlist}
:endfo[r]
			Like ":for" above, but each item in {listlist} must be
			a list, of which each item is assigned to {var1},
			{var2}, etc.  Example: >
				:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]
				   :echo getline(lnum)[col]
				:endfor
<
						*:continue* *:con* *E586*
:con[tinue]		When used inside a ":while" or ":for" loop, jumps back
			to the start of the loop.
			If it is used after a |:try| inside the loop but
			before the matching |:finally| (if present), the
			commands following the ":finally" up to the matching
			|:endtry| are executed first.  This process applies to
			all nested ":try"s inside the loop.  The outermost
			":endtry" then jumps back to the start of the loop.

						*:break* *:brea* *E587*
:brea[k]		When used inside a ":while" or ":for" loop, skips to
			the command after the matching ":endwhile" or
			":endfor".
			If it is used after a |:try| inside the loop but
			before the matching |:finally| (if present), the
			commands following the ":finally" up to the matching
			|:endtry| are executed first.  This process applies to
			all nested ":try"s inside the loop.  The outermost
			":endtry" then jumps to the command after the loop.

:try				*:try* *:endt* *:endtry* *E600* *E601* *E602*
:endt[ry]		Change the error handling for the commands between
			":try" and ":endtry" including everything being
			executed across ":source" commands, function calls,
			or autocommand invocations.

			When an error or interrupt is detected and there is
			a |:finally| command following, execution continues
			after the ":finally".  Otherwise, or when the
			":endtry" is reached thereafter, the next
			(dynamically) surrounding ":try" is checked for
			a corresponding ":finally" etc.  Then the script
			processing is terminated.  (Whether a function
			definition has an "abort" argument does not matter.)
			Example: >
		:try | edit too much | finally | echo "cleanup" | endtry
		:echo "impossible"	" not reached, script terminated above
<
			Moreover, an error or interrupt (dynamically) inside
			":try" and ":endtry" is converted to an exception.  It
			can be caught as if it were thrown by a |:throw|
			command (see |:catch|).  In this case, the script
			processing is not terminated.

			The value "Vim:Interrupt" is used for an interrupt
			exception.  An error in a Vim command is converted
			to a value of the form "Vim({command}):{errmsg}",
			other errors are converted to a value of the form
			"Vim:{errmsg}".  {command} is the full command name,
			and {errmsg} is the message that is displayed if the
			error exception is not caught, always beginning with
			the error number.
			Examples: >
		:try | sleep 100 | catch /^Vim:Interrupt$/ | endtry
		:try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry
<
					*:cat* *:catch* *E603* *E604* *E605*
:cat[ch] /{pattern}/	The following commands until the next ":catch",
			|:finally|, or |:endtry| that belongs to the same
			|:try| as the ":catch" are executed when an exception
			matching {pattern} is being thrown and has not yet
			been caught by a previous ":catch".  Otherwise, these
			commands are skipped.
			When {pattern} is omitted all errors are caught.
			Examples: >
		:catch /^Vim:Interrupt$/	" catch interrupts (CTRL-C)
		:catch /^Vim\%((\a\+)\)\=:E/	" catch all Vim errors
		:catch /^Vim\%((\a\+)\)\=:/	" catch errors and interrupts
		:catch /^Vim(write):/		" catch all errors in :write
		:catch /^Vim\%((\a\+)\)\=:E123/	" catch error E123
		:catch /my-exception/		" catch user exception
		:catch /.*/			" catch everything
		:catch				" same as /.*/
<
			Another character can be used instead of / around the
			{pattern}, so long as it does not have a special
			meaning (e.g., '|' or '"') and doesn't occur inside
			{pattern}.
			NOTE: It is not reliable to ":catch" the TEXT of
			an error message because it may vary in different
			locales.

					*:fina* *:finally* *E606* *E607*
:fina[lly]		The following commands until the matching |:endtry|
			are executed whenever the part between the matching
			|:try| and the ":finally" is left:  either by falling
			through to the ":finally" or by a |:continue|,
			|:break|, |:finish|, or |:return|, or by an error or
			interrupt or exception (see |:throw|).

							*:th* *:throw* *E608*
:th[row] {expr1}	The {expr1} is evaluated and thrown as an exception.
			If the ":throw" is used after a |:try| but before the
			first corresponding |:catch|, commands are skipped
			until the first ":catch" matching {expr1} is reached.
			If there is no such ":catch" or if the ":throw" is
			used after a ":catch" but before the |:finally|, the
			commands following the ":finally" (if present) up to
			the matching |:endtry| are executed.  If the ":throw"
			is after the ":finally", commands up to the ":endtry"
			are skipped.  At the ":endtry", this process applies
			again for the next dynamically surrounding ":try"
			(which may be found in a calling function or sourcing
			script), until a matching ":catch" has been found.
			If the exception is not caught, the command processing
			is terminated.
			Example: >
		:try | throw "oops" | catch /^oo/ | echo "caught" | endtry
< 
							*:ec* *:echo*
:ec[ho] {expr1} ..	スペースで区切られ<EOL>で終了する引数{expr1}を表示す
			る。|:comment|も参照。
			改行が必要な場合"\n"を使用する。カーソルを第1列(カラ
			ム)に持って行くには"\r"を使用する。
			コメント文を同じ行に続けることはできない。
			例: >
		:echo "the value of 'shell' is" &shell
<							*:echo-redraw*
			A later redraw may make the message disappear again.
			And since Vim mostly postpones redrawing until it's
			finished with a sequence of commands this happens
			quite often.  To avoid that a command from before the
			":echo" causes a redraw afterwards (redraws are often
			postponed until you type something), force a redraw
			with the |:redraw| command.  Example: >
		:new | redraw | echo "there is a new window"
<

							*:echon*
:echon {expr1} ..	改行を付けずに、{expr1}を表示する。|:comment|も参照。
			コメント文を同じ行に続けることはできない。
			例:
>		:echon "the value of 'shell' is " &shell

			Vimコマンドの":echo"と、外部のシェルコマンドである
			":!echo"との違いに注意:
>		:!echo %		--> filename
			":!"の引数は展開される。|:_%|を参照。
>		:!echo "%"		--> filename or "filename"
			前の例のように働く。ダブルクォートが表示されるかどうか
			は、使用している'shell'に依存する。
>		:echo %			--> 何も表示されない
			'%'は式として不当な文字である。
>		:echo "%"		--> %
			単に文字'%'を表示する。
>		:echo expand("%")	--> filename
			'%'を展開するために関数expand()を呼び出している。

							*:echoh* *:echohl*
:echoh[l] {name}	次の":echo[n]"コマンドから、ハイライトグループ{name}を
			適用する。例:
>		:echohl WarningMsg | echo "Don't panic!" | echohl None
			使用した後にはグループを"None"に戻すことを忘れないよう
			に。さもないとそれ以降のechoの表示総てがハイライトされ
			てしまう。

							*:echom* *:echomsg*
:echom[sg] {expr1} ..	Echo the expression(s) as a true message, saving the
			message in the |message-history|.
			Spaces are placed between the arguments as with the
			|:echo| command.  But unprintable characters are
			displayed, not interpreted.
			The parsing works slightly different from |:echo|,
			more like |:execute|.  All the expressions are first
			evaluated and concatenated before echoing anything.
			The expressions must evaluate to a Number or String, a
			Dictionary or List causes an error.
			Uses the highlighting set by the |:echohl| command.
			Example: >
		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."
<			See |:echo-redraw| to avoid the message disappearing
			when the screen is redrawn.
							*:echoe* *:echoerr*
:echoe[rr] {expr1} ..	Echo the expression(s) as an error message, saving the
			message in the |message-history|.  When used in a
			script or function the line number will be added.
			Spaces are placed between the arguments as with the
			:echo command.  When used inside a try conditional,
			the message is raised as an error exception instead
			(see |try-echoerr|).
			Example: >
		:echoerr "This script just failed!"
<			If you just want a highlighted message use |:echohl|.
			And to get a beep: >
		:exe "normal \<Esc>"
<
							*:exe* *:execute*
:exe[cute] {expr1} ..	{expr1}の評価結果の文字列をExコマンドとして実行する。
			スペースで区切られた複数の引数は連結される。
			コメント文を同じ行に続けることはできない。
			例:
>		:execute "buffer " nextbuf
>		:execute "normal " count . "w"

			Executeは'|'を受けつけないコマンドに、次のコマンドを続
			けて実行させるのにも使用できる。例:
>		:execute '!ls' | echo "theend"
			(訳注:普通の使い方では":!ls"の後には'|'を使って、Exコ
			マンドを続けることはできない)

			注意:executeに渡す文字列としては、"while"や"if"系のコ
			マンドが始まったり終ったりするだけのようなものは不適格
			である。よって次のような例は認められない:
			Note: The executed string may be any command-line, but
			you cannot start or end a "while" or "if" command.
			Thus this is illegal:
>		:execute 'while i > 5'
>		:execute 'echo "test" | break'

			文字列の中に完全な"while"や"if"コマンドが含まれること
			が求められる:
>		:execute 'while i < 5 | echo i | let i = i + 1 | endwhile'


							*:comment*
			":execute"や":echo"そして":echon"は、同一行に直接コメ
			ントを続けることはできない。何故ならそれらのコマンドに
			とって'"'は文字列の始まりに見えてしまうからである。し
			かし'|'の後にコメントを書くことは可能である。例:
>		:echo "foo" | "this is a comment

==============================================================================
8. 例外処理					*exception-handling*

The Vim script language comprises an exception handling feature.  This section
explains how it can be used in a Vim script.

Exceptions may be raised by Vim on an error or on interrupt, see
|catch-errors| and |catch-interrupt|.  You can also explicitly throw an
exception by using the ":throw" command, see |throw-catch|.


TRY CONDITIONALS					*try-conditionals*

Exceptions can be caught or can cause cleanup code to be executed.  You can
use a try conditional to specify catch clauses (that catch exceptions) and/or
a finally clause (to be executed for cleanup).
   A try conditional begins with a |:try| command and ends at the matching
|:endtry| command.  In between, you can use a |:catch| command to start
a catch clause, or a |:finally| command to start a finally clause.  There may
be none or multiple catch clauses, but there is at most one finally clause,
which must not be followed by any catch clauses.  The lines before the catch
clauses and the finally clause is called a try block. >

     :try
     :  ...
     :  ...				TRY BLOCK
     :  ...
     :catch /{pattern}/
     :  ...
     :  ...				CATCH CLAUSE
     :  ...
     :catch /{pattern}/
     :  ...
     :  ...				CATCH CLAUSE
     :  ...
     :finally
     :  ...
     :  ...				FINALLY CLAUSE
     :  ...
     :endtry

The try conditional allows to watch code for exceptions and to take the
appropriate actions.  Exceptions from the try block may be caught.  Exceptions
from the try block and also the catch clauses may cause cleanup actions.
   When no exception is thrown during execution of the try block, the control
is transferred to the finally clause, if present.  After its execution, the
script continues with the line following the ":endtry".
   When an exception occurs during execution of the try block, the remaining
lines in the try block are skipped.  The exception is matched against the
patterns specified as arguments to the ":catch" commands.  The catch clause
after the first matching ":catch" is taken, other catch clauses are not
executed.  The catch clause ends when the next ":catch", ":finally", or
":endtry" command is reached - whatever is first.  Then, the finally clause
(if present) is executed.  When the ":endtry" is reached, the script execution
continues in the following line as usual.
   When an exception that does not match any of the patterns specified by the
":catch" commands is thrown in the try block, the exception is not caught by
that try conditional and none of the catch clauses is executed.  Only the
finally clause, if present, is taken.  The exception pends during execution of
the finally clause.  It is resumed at the ":endtry", so that commands after
the ":endtry" are not executed and the exception might be caught elsewhere,
see |try-nesting|.
   When during execution of a catch clause another exception is thrown, the
remaining lines in that catch clause are not executed.  The new exception is
not matched against the patterns in any of the ":catch" commands of the same
try conditional and none of its catch clauses is taken.  If there is, however,
a finally clause, it is executed, and the exception pends during its
execution.  The commands following the ":endtry" are not executed.  The new
exception might, however, be caught elsewhere, see |try-nesting|.
   When during execution of the finally clause (if present) an exception is
thrown, the remaining lines in the finally clause are skipped.  If the finally
clause has been taken because of an exception from the try block or one of the
catch clauses, the original (pending) exception is discarded.  The commands
following the ":endtry" are not executed, and the exception from the finally
clause is propagated and can be caught elsewhere, see |try-nesting|.

The finally clause is also executed, when a ":break" or ":continue" for
a ":while" loop enclosing the complete try conditional is executed from the
try block or a catch clause.  Or when a ":return" or ":finish" is executed
from the try block or a catch clause of a try conditional in a function or
sourced script, respectively.  The ":break", ":continue", ":return", or
":finish" pends during execution of the finally clause and is resumed when the
":endtry" is reached.  It is, however, discarded when an exception is thrown
from the finally clause.
   When a ":break" or ":continue" for a ":while" loop enclosing the complete
try conditional or when a ":return" or ":finish" is encountered in the finally
clause, the rest of the finally clause is skipped, and the ":break",
":continue", ":return" or ":finish" is executed as usual.  If the finally
clause has been taken because of an exception or an earlier ":break",
":continue", ":return", or ":finish" from the try block or a catch clause,
this pending exception or command is discarded.

For examples see |throw-catch| and |try-finally|.


NESTING	OF TRY CONDITIONALS				*try-nesting*

Try conditionals can be nested arbitrarily.  That is, a complete try
conditional can be put into the try block, a catch clause, or the finally
clause of another try conditional.  If the inner try conditional does not
catch an exception thrown in its try block or throws a new exception from one
of its catch clauses or its finally clause, the outer try conditional is
checked according to the rules above.  If the inner try conditional is in the
try block of the outer try conditional, its catch clauses are checked, but
otherwise only the finally clause is executed.  It does not matter for
nesting, whether the inner try conditional is directly contained in the outer
one, or whether the outer one sources a script or calls a function containing
the inner try conditional.

When none of the active try conditionals catches an exception, just their
finally clauses are executed.  Thereafter, the script processing terminates.
An error message is displayed in case of an uncaught exception explicitly
thrown by a ":throw" command.  For uncaught error and interrupt exceptions
implicitly raised by Vim, the error message(s) or interrupt message are shown
as usual.

For examples see |throw-catch|.


EXAMINING EXCEPTION HANDLING CODE			*except-examine*

Exception handling code can get tricky.  If you are in doubt what happens, set
'verbose' to 13 or use the ":13verbose" command modifier when sourcing your
script file.  Then you see when an exception is thrown, discarded, caught, or
finished.  When using a verbosity level of at least 14, things pending in
a finally clause are also shown.  This information is also given in debug mode
(see |debug-scripts|).


THROWING AND CATCHING EXCEPTIONS			*throw-catch*

You can throw any number or string as an exception.  Use the |:throw| command
and pass the value to be thrown as argument: >
	:throw 4711
	:throw "string"
<							*throw-expression*
You can also specify an expression argument.  The expression is then evaluated
first, and the result is thrown: >
	:throw 4705 + strlen("string")
	:throw strpart("strings", 0, 6)

An exception might be thrown during evaluation of the argument of the ":throw"
command.  Unless it is caught there, the expression evaluation is abandoned.
The ":throw" command then does not throw a new exception.
   Example: >

	:function! Foo(arg)
	:  try
	:    throw a:arg
	:  catch /foo/
	:  endtry
	:  return 1
	:endfunction
	:
	:function! Bar()
	:  echo "in Bar"
	:  return 4710
	:endfunction
	:
	:throw Foo("arrgh") + Bar()

This throws "arrgh", and "in Bar" is not displayed since Bar() is not
executed. >
	:throw Foo("foo") + Bar()
however displays "in Bar" and throws 4711.

Any other command that takes an expression as argument might also be
abandoned by an (uncaught) exception during the expression evaluation.  The
exception is then propagated to the caller of the command.
   Example: >

	:if Foo("arrgh")
	:  echo "then"
	:else
	:  echo "else"
	:endif

Here neither of "then" or "else" is displayed.

							*catch-order*
Exceptions can be caught by a try conditional with one or more |:catch|
commands, see |try-conditionals|.   The values to be caught by each ":catch"
command can be specified as a pattern argument.  The subsequent catch clause
gets executed when a matching exception is caught.
   Example: >

	:function! Foo(value)
	:  try
	:    throw a:value
	:  catch /^\d\+$/
	:    echo "Number thrown"
	:  catch /.*/
	:    echo "String thrown"
	:  endtry
	:endfunction
	:
	:call Foo(0x1267)
	:call Foo('string')

The first call to Foo() displays "Number thrown", the second "String thrown".
An exception is matched against the ":catch" commands in the order they are
specified.  Only the first match counts.  So you should place the more
specific ":catch" first.  The following order does not make sense: >

	:  catch /.*/
	:    echo "String thrown"
	:  catch /^\d\+$/
	:    echo "Number thrown"

The first ":catch" here matches always, so that the second catch clause is
never taken.

							*throw-variables*
If you catch an exception by a general pattern, you may access the exact value
in the variable |v:exception|: >

	:  catch /^\d\+$/
	:    echo "Number thrown.  Value is" v:exception

You may also be interested where an exception was thrown.  This is stored in
|v:throwpoint|.  Note that "v:exception" and "v:throwpoint" are valid for the
exception most recently caught as long it is not finished.
   Example: >

	:function! Caught()
	:  if v:exception != ""
	:    echo 'Caught "' . v:exception . '" in ' . v:throwpoint
	:  else
	:    echo 'Nothing caught'
	:  endif
	:endfunction
	:
	:function! Foo()
	:  try
	:    try
	:      try
	:	 throw 4711
	:      finally
	:	 call Caught()
	:      endtry
	:    catch /.*/
	:      call Caught()
	:      throw "oops"
	:    endtry
	:  catch /.*/
	:    call Caught()
	:  finally
	:    call Caught()
	:  endtry
	:endfunction
	:
	:call Foo()

This displays >

	Nothing caught
	Caught "4711" in function Foo, line 4
	Caught "oops" in function Foo, line 10
	Nothing caught

A practical example:  The following command ":LineNumber" displays the line
number in the script or function where it has been used: >

	:function! LineNumber()
	:    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")
	:endfunction
	:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry
<
							*try-nested*
An exception that is not caught by a try conditional can be caught by
a surrounding try conditional: >

	:try
	:  try
	:    throw "foo"
	:  catch /foobar/
	:    echo "foobar"
	:  finally
	:    echo "inner finally"
	:  endtry
	:catch /foo/
	:  echo "foo"
	:endtry

The inner try conditional does not catch the exception, just its finally
clause is executed.  The exception is then caught by the outer try
conditional.  The example displays "inner finally" and then "foo".

							*throw-from-catch*
You can catch an exception and throw a new one to be caught elsewhere from the
catch clause: >

	:function! Foo()
	:  throw "foo"
	:endfunction
	:
	:function! Bar()
	:  try
	:    call Foo()
	:  catch /foo/
	:    echo "Caught foo, throw bar"
	:    throw "bar"
	:  endtry
	:endfunction
	:
	:try
	:  call Bar()
	:catch /.*/
	:  echo "Caught" v:exception
	:endtry

This displays "Caught foo, throw bar" and then "Caught bar".

							*rethrow*
There is no real rethrow in the Vim script language, but you may throw
"v:exception" instead: >

	:function! Bar()
	:  try
	:    call Foo()
	:  catch /.*/
	:    echo "Rethrow" v:exception
	:    throw v:exception
	:  endtry
	:endfunction
<							*try-echoerr*
Note that this method cannot be used to "rethrow" Vim error or interrupt
exceptions, because it is not possible to fake Vim internal exceptions.
Trying so causes an error exception.  You should throw your own exception
denoting the situation.  If you want to cause a Vim error exception containing
the original error exception value, you can use the |:echoerr| command: >

	:try
	:  try
	:    asdf
	:  catch /.*/
	:    echoerr v:exception
	:  endtry
	:catch /.*/
	:  echo v:exception
	:endtry

This code displays

	Vim(echoerr):Vim:E492: Not an editor command:   asdf ~


CLEANUP CODE						*try-finally*

Scripts often change global settings and restore them at their end.  If the
user however interrupts the script by pressing CTRL-C, the settings remain in
an inconsistent state.  The same may happen to you in the development phase of
a script when an error occurs or you explicitly throw an exception without
catching it.  You can solve these problems by using a try conditional with
a finally clause for restoring the settings.  Its execution is guaranteed on
normal control flow, on error, on an explicit ":throw", and on interrupt.
(Note that errors and interrupts from inside the try conditional are converted
to exceptions.  When not caught, they terminate the script after the finally
clause has been executed.)
Example: >

	:try
	:  let s:saved_ts = &ts
	:  set ts=17
	:
	:  " Do the hard work here.
	:
	:finally
	:  let &ts = s:saved_ts
	:  unlet s:saved_ts
	:endtry

This method should be used locally whenever a function or part of a script
changes global settings which need to be restored on failure or normal exit of
that function or script part.

							*break-finally*
Cleanup code works also when the try block or a catch clause is left by
a ":continue", ":break", ":return", or ":finish".
   Example: >

	:let first = 1
	:while 1
	:  try
	:    if first
	:      echo "first"
	:      let first = 0
	:      continue
	:    else
	:      throw "second"
	:    endif
	:  catch /.*/
	:    echo v:exception
	:    break
	:  finally
	:    echo "cleanup"
	:  endtry
	:  echo "still in while"
	:endwhile
	:echo "end"

This displays "first", "cleanup", "second", "cleanup", and "end". >

	:function! Foo()
	:  try
	:    return 4711
	:  finally
	:    echo "cleanup\n"
	:  endtry
	:  echo "Foo still active"
	:endfunction
	:
	:echo Foo() "returned by Foo"

This displays "cleanup" and "4711 returned by Foo".  You don't need to add an
extra ":return" in the finally clause.  (Above all, this would override the
return value.)

							*except-from-finally*
Using either of ":continue", ":break", ":return", ":finish", or ":throw" in
a finally clause is possible, but not recommended since it abandons the
cleanup actions for the try conditional.  But, of course, interrupt and error
exceptions might get raised from a finally clause.
   Example where an error in the finally clause stops an interrupt from
working correctly: >

	:try
	:  try
	:    echo "Press CTRL-C for interrupt"
	:    while 1
	:    endwhile
	:  finally
	:    unlet novar
	:  endtry
	:catch /novar/
	:endtry
	:echo "Script still running"
	:sleep 1

If you need to put commands that could fail into a finally clause, you should
think about catching or ignoring the errors in these commands, see
|catch-errors| and |ignore-errors|.


CATCHING ERRORS						*catch-errors*

If you want to catch specific errors, you just have to put the code to be
watched in a try block and add a catch clause for the error message.  The
presence of the try conditional causes all errors to be converted to an
exception.  No message is displayed and |v:errmsg| is not set then.  To find
the right pattern for the ":catch" command, you have to know how the format of
the error exception is.
   Error exceptions have the following format: >

	Vim({cmdname}):{errmsg}
or >
	Vim:{errmsg}

{cmdname} is the name of the command that failed; the second form is used when
the command name is not known.  {errmsg} is the error message usually produced
when the error occurs outside try conditionals.  It always begins with
a capital "E", followed by a two or three-digit error number, a colon, and
a space.

Examples:

The command >
	:unlet novar
normally produces the error message >
	E108: No such variable: "novar"
which is converted inside try conditionals to an exception >
	Vim(unlet):E108: No such variable: "novar"

The command >
	:dwim
normally produces the error message >
	E492: Not an editor command: dwim
which is converted inside try conditionals to an exception >
	Vim:E492: Not an editor command: dwim

You can catch all ":unlet" errors by a >
	:catch /^Vim(unlet):/
or all errors for misspelled command names by a >
	:catch /^Vim:E492:/

Some error messages may be produced by different commands: >
	:function nofunc
and >
	:delfunction nofunc
both produce the error message >
	E128: Function name must start with a capital: nofunc
which is converted inside try conditionals to an exception >
	Vim(function):E128: Function name must start with a capital: nofunc
or >
	Vim(delfunction):E128: Function name must start with a capital: nofunc
respectively.  You can catch the error by its number independently on the
command that caused it if you use the following pattern: >
	:catch /^Vim(\a\+):E128:/

Some commands like >
	:let x = novar
produce multiple error messages, here: >
	E121: Undefined variable: novar
	E15: Invalid expression:  novar
Only the first is used for the exception value, since it is the most specific
one (see |except-several-errors|).  So you can catch it by >
	:catch /^Vim(\a\+):E121:/

You can catch all errors related to the name "nofunc" by >
	:catch /\<nofunc\>/

You can catch all Vim errors in the ":write" and ":read" commands by >
	:catch /^Vim(\(write\|read\)):E\d\+:/

You can catch all Vim errors by the pattern >
	:catch /^Vim\((\a\+)\)\=:E\d\+:/
<
							*catch-text*
NOTE: You should never catch the error message text itself: >
	:catch /No such variable/
only works in the english locale, but not when the user has selected
a different language by the |:language| command.  It is however helpful to
cite the message text in a comment: >
	:catch /^Vim(\a\+):E108:/   " No such variable


IGNORING ERRORS						*ignore-errors*

You can ignore errors in a specific Vim command by catching them locally: >

	:try
	:  write
	:catch
	:endtry

But you are strongly recommended NOT to use this simple form, since it could
catch more than you want.  With the ":write" command, some autocommands could
be executed and cause errors not related to writing, for instance: >

	:au BufWritePre * unlet novar

There could even be such errors you are not responsible for as a script
writer: a user of your script might have defined such autocommands.  You would
then hide the error from the user.
   It is much better to use >

	:try
	:  write
	:catch /^Vim(write):/
	:endtry

which only catches real write errors.  So catch only what you'd like to ignore
intentionally.

For a single command that does not cause execution of autocommands, you could
even suppress the conversion of errors to exceptions by the ":silent!"
command: >
	:silent! nunmap k
This works also when a try conditional is active.


CATCHING INTERRUPTS					*catch-interrupt*

When there are active try conditionals, an interrupt (CTRL-C) is converted to
the exception "Vim:Interrupt".  You can catch it like every exception.  The
script is not terminated, then.
   Example: >

	:function! TASK1()
	:  sleep 10
	:endfunction

	:function! TASK2()
	:  sleep 20
	:endfunction

	:while 1
	:  let command = input("Type a command: ")
	:  try
	:    if command == ""
	:      continue
	:    elseif command == "END"
	:      break
	:    elseif command == "TASK1"
	:      call TASK1()
	:    elseif command == "TASK2"
	:      call TASK2()
	:    else
	:      echo "\nIllegal command:" command
	:      continue
	:    endif
	:  catch /^Vim:Interrupt$/
	:    echo "\nCommand interrupted"
	:    " Caught the interrupt.  Continue with next prompt.
	:  endtry
	:endwhile

You can interrupt a task here by pressing CTRL-C; the script then asks for
a new command.  If you press CTRL-C at the prompt, the script is terminated.

For testing what happens when CTRL-C would be pressed on a specific line in
your script, use the debug mode and execute the |>quit| or |>interrupt|
command on that line.  See |debug-scripts|.


CATCHING ALL						*catch-all*

The commands >

	:catch /.*/
	:catch //
	:catch

catch everything, error exceptions, interrupt exceptions and exceptions
explicitly thrown by the |:throw| command.  This is useful at the top level of
a script in order to catch unexpected things.
   Example: >

	:try
	:
	:  " do the hard work here
	:
	:catch /MyException/
	:
	:  " handle known problem
	:
	:catch /^Vim:Interrupt$/
	:    echo "Script interrupted"
	:catch /.*/
	:  echo "Internal error (" . v:exception . ")"
	:  echo " - occurred at " . v:throwpoint
	:endtry
	:" end of script

Note: Catching all might catch more things than you want.  Thus, you are
strongly encouraged to catch only for problems that you can really handle by
specifying a pattern argument to the ":catch".
   Example: Catching all could make it nearly impossible to interrupt a script
by pressing CTRL-C: >

	:while 1
	:  try
	:    sleep 1
	:  catch
	:  endtry
	:endwhile


EXCEPTIONS AND AUTOCOMMANDS				*except-autocmd*

Exceptions may be used during execution of autocommands.  Example: >

	:autocmd User x try
	:autocmd User x   throw "Oops!"
	:autocmd User x catch
	:autocmd User x   echo v:exception
	:autocmd User x endtry
	:autocmd User x throw "Arrgh!"
	:autocmd User x echo "Should not be displayed"
	:
	:try
	:  doautocmd User x
	:catch
	:  echo v:exception
	:endtry

This displays "Oops!" and "Arrgh!".

							*except-autocmd-Pre*
For some commands, autocommands get executed before the main action of the
command takes place.  If an exception is thrown and not caught in the sequence
of autocommands, the sequence and the command that caused its execution are
abandoned and the exception is propagated to the caller of the command.
   Example: >

	:autocmd BufWritePre * throw "FAIL"
	:autocmd BufWritePre * echo "Should not be displayed"
	:
	:try
	:  write
	:catch
	:  echo "Caught:" v:exception "from" v:throwpoint
	:endtry

Here, the ":write" command does not write the file currently being edited (as
you can see by checking 'modified'), since the exception from the BufWritePre
autocommand abandons the ":write".  The exception is then caught and the
script displays: >

	Caught: FAIL from BufWrite Auto commands for "*"
<
							*except-autocmd-Post*
For some commands, autocommands get executed after the main action of the
command has taken place.  If this main action fails and the command is inside
an active try conditional, the autocommands are skipped and an error exception
is thrown that can be caught by the caller of the command.
   Example: >

	:autocmd BufWritePost * echo "File successfully written!"
	:
	:try
	:  write /i/m/p/o/s/s/i/b/l/e
	:catch
	:  echo v:exception
	:endtry

This just displays: >

	Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)

If you really need to execute the autocommands even when the main action
fails, trigger the event from the catch clause.
   Example: >

	:autocmd BufWritePre  * set noreadonly
	:autocmd BufWritePost * set readonly
	:
	:try
	:  write /i/m/p/o/s/s/i/b/l/e
	:catch
	:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e
	:endtry
<
You can also use ":silent!": >

	:let x = "ok"
	:let v:errmsg = ""
	:autocmd BufWritePost * if v:errmsg != ""
	:autocmd BufWritePost *   let x = "after fail"
	:autocmd BufWritePost * endif
	:try
	:  silent! write /i/m/p/o/s/s/i/b/l/e
	:catch
	:endtry
	:echo x

This displays "after fail".

If the main action of the command does not fail, exceptions from the
autocommands will be catchable by the caller of the command:  >

	:autocmd BufWritePost * throw ":-("
	:autocmd BufWritePost * echo "Should not be displayed"
	:
	:try
	:  write
	:catch
	:  echo v:exception
	:endtry
<
							*except-autocmd-Cmd*
For some commands, the normal action can be replaced by a sequence of
autocommands.  Exceptions from that sequence will be catchable by the caller
of the command.
   Example:  For the ":write" command, the caller cannot know whether the file
had actually been written when the exception occurred.  You need to tell it in
some way. >

	:if !exists("cnt")
	:  let cnt = 0
	:
	:  autocmd BufWriteCmd * if &modified
	:  autocmd BufWriteCmd *   let cnt = cnt + 1
	:  autocmd BufWriteCmd *   if cnt % 3 == 2
	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
	:  autocmd BufWriteCmd *   endif
	:  autocmd BufWriteCmd *   write | set nomodified
	:  autocmd BufWriteCmd *   if cnt % 3 == 0
	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
	:  autocmd BufWriteCmd *   endif
	:  autocmd BufWriteCmd *   echo "File successfully written!"
	:  autocmd BufWriteCmd * endif
	:endif
	:
	:try
	:	write
	:catch /^BufWriteCmdError$/
	:  if &modified
	:    echo "Error on writing (file contents not changed)"
	:  else
	:    echo "Error after writing"
	:  endif
	:catch /^Vim(write):/
	:    echo "Error on writing"
	:endtry

When this script is sourced several times after making changes, it displays
first >
	File successfully written!
then >
	Error on writing (file contents not changed)
then >
	Error after writing
etc.

							*except-autocmd-ill*
You cannot spread a try conditional over autocommands for different events.
The following code is ill-formed: >

	:autocmd BufWritePre  * try
	:
	:autocmd BufWritePost * catch
	:autocmd BufWritePost *   echo v:exception
	:autocmd BufWritePost * endtry
	:
	:write


EXCEPTION HIERARCHIES AND PARAMETERIZED EXCEPTIONS	*except-hier-param*

Some programming languages allow to use hierarchies of exception classes or to
pass additional information with the object of an exception class.  You can do
similar things in Vim.
   In order to throw an exception from a hierarchy, just throw the complete
class name with the components separated by a colon, for instance throw the
string "EXCEPT:MATHERR:OVERFLOW" for an overflow in a mathematical library.
   When you want to pass additional information with your exception class, add
it in parentheses, for instance throw the string "EXCEPT:IO:WRITEERR(myfile)"
for an error when writing "myfile".
   With the appropriate patterns in the ":catch" command, you can catch for
base classes or derived classes of your hierarchy.  Additional information in
parentheses can be cut out from |v:exception| with the ":substitute" command.
   Example: >

	:function! CheckRange(a, func)
	:  if a:a < 0
	:    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"
	:  endif
	:endfunction
	:
	:function! Add(a, b)
	:  call CheckRange(a:a, "Add")
	:  call CheckRange(a:b, "Add")
	:  let c = a:a + a:b
	:  if c < 0
	:    throw "EXCEPT:MATHERR:OVERFLOW"
	:  endif
	:  return c
	:endfunction
	:
	:function! Div(a, b)
	:  call CheckRange(a:a, "Div")
	:  call CheckRange(a:b, "Div")
	:  if (a:b == 0)
	:    throw "EXCEPT:MATHERR:ZERODIV"
	:  endif
	:  return a:a / a:b
	:endfunction
	:
	:function! Write(file)
	:  try
	:    execute "write" a:file
	:  catch /^Vim(write):/
	:    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"
	:  endtry
	:endfunction
	:
	:try
	:
	:  " something with arithmetics and I/O
	:
	:catch /^EXCEPT:MATHERR:RANGE/
	:  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")
	:  echo "Range error in" function
	:
	:catch /^EXCEPT:MATHERR/	" catches OVERFLOW and ZERODIV
	:  echo "Math error"
	:
	:catch /^EXCEPT:IO/
	:  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")
	:  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")
	:  if file !~ '^/'
	:    let file = dir . "/" . file
	:  endif
	:  echo 'I/O error for "' . file . '"'
	:
	:catch /^EXCEPT/
	:  echo "Unspecified error"
	:
	:endtry

The exceptions raised by Vim itself (on error or when pressing CTRL-C) use
a flat hierarchy:  they are all in the "Vim" class.  You cannot throw yourself
exceptions with the "Vim" prefix; they are reserved for Vim.
   Vim error exceptions are parameterized with the name of the command that
failed, if known.  See |catch-errors|.


PECULIARITIES
							*except-compat*
The exception handling concept requires that the command sequence causing the
exception is aborted immediately and control is transferred to finally clauses
and/or a catch clause.

In the Vim script language there are cases where scripts and functions
continue after an error: in functions without the "abort" flag or in a command
after ":silent!", control flow goes to the following line, and outside
functions, control flow goes to the line following the outermost ":endwhile"
or ":endif".  On the other hand, errors should be catchable as exceptions
(thus, requiring the immediate abortion).

This problem has been solved by converting errors to exceptions and using
immediate abortion (if not suppressed by ":silent!") only when a try
conditional is active.  This is no restriction since an (error) exception can
be caught only from an active try conditional.  If you want an immediate
termination without catching the error, just use a try conditional without
catch clause.  (You can cause cleanup code being executed before termination
by specifying a finally clause.)

When no try conditional is active, the usual abortion and continuation
behavior is used instead of immediate abortion.  This ensures compatibility of
scripts written for Vim 6.1 and earlier.

However, when sourcing an existing script that does not use exception handling
commands (or when calling one of its functions) from inside an active try
conditional of a new script, you might change the control flow of the existing
script on error.  You get the immediate abortion on error and can catch the
error in the new script.  If however the sourced script suppresses error
messages by using the ":silent!" command (checking for errors by testing
|v:errmsg| if appropriate), its execution path is not changed.  The error is
not converted to an exception.  (See |:silent|.)  So the only remaining cause
where this happens is for scripts that don't care about errors and produce
error messages.  You probably won't want to use such code from your new
scripts.

							*except-syntax-err*
Syntax errors in the exception handling commands are never caught by any of
the ":catch" commands of the try conditional they belong to.  Its finally
clauses, however, is executed.
   Example: >

	:try
	:  try
	:    throw 4711
	:  catch /\(/
	:    echo "in catch with syntax error"
	:  catch
	:    echo "inner catch-all"
	:  finally
	:    echo "inner finally"
	:  endtry
	:catch
	:  echo 'outer catch-all caught "' . v:exception . '"'
	:  finally
	:    echo "outer finally"
	:endtry

This displays: >
    inner finally
    outer catch-all caught "Vim(catch):E54: Unmatched \("
    outer finally
The original exception is discarded and an error exception is raised, instead.

							*except-single-line*
The ":try", ":catch", ":finally", and ":endtry" commands can be put on
a single line, but then syntax errors may make it difficult to recognize the
"catch" line, thus you better avoid this.
   Example: >
	:try | unlet! foo # | catch | endtry
raises an error exception for the trailing characters after the ":unlet!"
argument, but does not see the ":catch" and ":endtry" commands, so that the
error exception is discarded and the "E488: Trailing characters" message gets
displayed.

							*except-several-errors*
When several errors appear in a single command, the first error message is
usually the most specific one and therefor converted to the error exception.
   Example: >
	echo novar
causes >
	E121: Undefined variable: novar
	E15: Invalid expression: novar
The value of the error exception inside try conditionals is: >
	Vim(echo):E121: Undefined variable: novar
<							*except-syntax-error*
But when a syntax error is detected after a normal error in the same command,
the syntax error is used for the exception being thrown.
   Example: >
	unlet novar #
causes >
	E108: No such variable: "novar"
	E488: Trailing characters
The value of the error exception inside try conditionals is: >
	Vim(unlet):E488: Trailing characters
This is done because the syntax error might change the execution path in a way
not intended by the user.  Example: >
	try
	    try | unlet novar # | catch | echo v:exception | endtry
	catch /.*/
	    echo "outer catch:" v:exception
	endtry
This displays "outer catch: Vim(unlet):E488: Trailing characters", and then
a "E600: Missing :endtry" error message is given, see |except-single-line|.

==============================================================================
9. 例							    *eval-examples*

16進数で表示する ~

>  " The function Nr2Hex() returns the Hex string of a number.
>  func Nr2Hex(nr)
>    let n = a:nr
>    let r = ""
>    while n
>      let r = '0123456789ABCDEF'[n % 16] . r
>      let n = n / 16
>    endwhile
>    return r
>  endfunc
>
>  " The function String2Hex() converts each character in a string to a two
>  " character Hex string.
>  func String2Hex(str)
>    let out = ''
>    let ix = 0
>    while ix < strlen(a:str)
>      let out = out . Nr2Hex(char2nr(a:str[ix]))
>      let ix = ix + 1
>    endwhile
>    return out
>  endfunc

使い方:
>  echo Nr2Hex(32)
結果: "20"
>  echo String2Hex("32")
結果: "3332"


行をソート(並べ替え)する (by Robert Webb) ~

これは行をソートするためのVimスクリプトである。Vimにおいて行を(Visualモードで)
選択し":Sort"とタイプする。これは如何なる外部プログラムも起動しない。よってど
のようなプラットホームであっても動作する。実は関数Sort()は、C言語のqsort()のよ
うに引数として比較関数を受けつける。よって、データ毎に必要となるソート順に応じ
た、異なった比較関数を与えることができる。

> " Function for use with Sort(), to compare two strings.
> func! Strcmp(str1, str2)
>     if (a:str1 < a:str2)
>	return -1
>     elseif (a:str1 > a:str2)
>	return 1
>     else
>	return 0
>     endif
> endfunction
>
> " Sort lines.  SortR() is called recursively.
> func! SortR(start, end, cmp)
>     if (a:start >= a:end)
>	return
>     endif
>     let partition = a:start - 1
>     let middle = partition
>     let partStr = getline((a:start + a:end) / 2)
>     let i = a:start
>     while (i <= a:end)
>	let str = getline(i)
>	exec "let result = " . a:cmp . "(str, partStr)"
>	if (result <= 0)
>	    " Need to put it before the partition.  Swap lines i and partition.
>	    let partition = partition + 1
>	    if (result == 0)
>		let middle = partition
>	    endif
>	    if (i != partition)
>		let str2 = getline(partition)
>		call setline(i, str2)
>		call setline(partition, str)
>	    endif
>	endif
>	let i = i + 1
>     endwhile
>
>     " Now we have a pointer to the "middle" element, as far as partitioning
>     " goes, which could be anywhere before the partition.  Make sure it is at
>     " the end of the partition.
>     if (middle != partition)
>	let str = getline(middle)
>	let str2 = getline(partition)
>	call setline(middle, str2)
>	call setline(partition, str)
>     endif
>     call SortR(a:start, partition - 1, a:cmp)
>     call SortR(partition + 1, a:end, a:cmp)
> endfunc
>
> " To Sort a range of lines, pass the range to Sort() along with the name of a
> " function that will compare two lines.
> func! Sort(cmp) range
>     call SortR(a:firstline, a:lastline, a:cmp)
> endfunc
>
> " :Sort takes a range of lines and sorts them.
> command! -nargs=0 -range Sort <line1>,<line2>call Sort("Strcmp")

							*sscanf*
Vimにはsscanf()に相当する関数が無い。もしも行の一部を取り出す必要があるのなら
ば、matchstr()やsubstitute()を使って行なうことができる。この例は"foobar.txt,
123, 45"のような行から、どうやってファイル名と行番号とカラム番号を取り出すかを
示している。
>  " Set up the match bit
>  let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'
>  "get the part matching the whole expression
>  let l = matchstr(line, mx)
>  "get each item out of the match
>  let file = substitute(l, mx, '\1', '')
>  let lnum = substitute(l, mx, '\2', '')
>  let col = substitute(l, mx, '\3', '')

入力は変数"line"、結果は"file"と"lnum"と"col"に格納される(アイデアはMichael
Geddesによる)。

getting the scriptnames in a Dictionary ~
						*scriptnames-dictionary*
The |:scriptnames| command can be used to get a list of all script files that
have been sourced.  There is no equivalent function or variable for this
(because it's rarely needed).  In case you need to manipulate the list this
code can be used: >
    " Get the output of ":scriptnames" in the scriptnames_output variable.
    let scriptnames_output = ''
    redir => scriptnames_output
    silent scriptnames
    redir END
    
    " Split the output into lines and parse each line.  Add an entry to the
    " "scripts" dictionary.
    let scripts = {}
    for line in split(scriptnames_output, "\n")
      " Only do non-blank lines.
      if line =~ '\S'
	" Get the first number in the line.
        let nr = matchstr(line, '\d\+')
	" Get the file name, remove the script number " 123: ".
        let name = substitute(line, '.\+:\s*', '', '')
	" Add an item to the Dictionary
        let scripts[nr] = name
      endif
    endfor
    unlet scriptnames_output

==============================================================================
10. +eval機能が無効					*no-eval-feature*

コンパイル時に|+eval|機能が無効とされている場合、総ての式評価(eval)コマンドは
提供されない。その場合、Vimスクリプトが総ての種類のエラーを引き起こすことを避
ける為、":if"と":endif"は解釈される。":if"とそれに対応する":endif"に挟まれた内
容は無視される。":if"の後に続く引数も無視される。この":if"コマンドはネスティン
グが可能である。しかし必ず行の先頭に書かれている必要がある。":else"コマンドは
認識されない。

|+eval|機能が存在しなかった場合、どのようにコマンドが実行を免れるかの例:

	:if 1
	:  echo "Expression evaluation is compiled in"
	:else
	:  echo "You will _never_ see this message"
	:endif

==============================================================================
11. サンドボックス				*eval-sandbox* *sandbox* *E48*

The 'foldexpr', 'includeexpr', 'indentexpr', 'statusline' and 'foldtext'
options are evaluated in a sandbox.  This means that you are protected from
these expressions having nasty side effects.  This gives some safety for when
these options are set from a modeline.  It is also used when the command from
a tags file is executed and for CTRL-R = in the command line.
The sandbox is also used for the |:sandbox| command.

These items are not allowed in the sandbox:
	- changing the buffer text
	- defining or changing mapping, autocommands, functions, user commands
	- setting certain options (see |option-summary|)
	- setting certain v: variables (see |v:var|)  *E794*
	- executing a shell command
	- reading or writing a file
	- jumping to another buffer or editing a file
	- executing Python, Perl, etc. commands
This is not guaranteed 100% secure, but it should block most attacks.

							*:san* *:sandbox*
:san[dbox] {cmd}	Execute {cmd} in the sandbox.  Useful to evaluate an
			option that may have been set from a modeline, e.g.
			'foldexpr'.

							*sandbox-option*
A few options contain an expression.  When this expression is evaluated it may
have to be done in the sandbox to avoid a security risk.  But the sandbox is
restrictive, thus this only happens when the option was set from an insecure
location.  Insecure in this context are:
- sourcing a .vimrc or .exrc in the current directory
- while executing in the sandbox
- value coming from a modeline

Note that when in the sandbox and saving an option value and restoring it, the
option will still be marked as it was set in the sandbox.

==============================================================================
12. テキストロック						*textlock*

In a few situations it is not allowed to change the text in the buffer, jump
to another window and some other things that might confuse or break what Vim
is currently doing.  This mostly applies to things that happen when Vim is
actually doing something else.  For example, evaluating the 'balloonexpr' may
happen any moment the mouse cursor is resting at some position.

This is not allowed when the textlock is active:
	- changing the buffer text
	- jumping to another buffer or window
	- editing another file
	- closing a window or quitting Vim
	- etc.


 vim:tw=78:ts=8:ft=help:norl:
