COMMENT: キーマッピング
STATUS: finished 5.7a
TRANSLATOR: 西岡拓洋
TRANSLATOR: 北条耀
MAINTEINER: 村岡太郎<koron@tka.att.ne.jp>

*map.txt*	For Vim version 5.7a.  Last change: 2000 May 03


		  VIM REFERENCE MANUAL	  by Bram Moolenaar


キー・マッピングと略語補完

1. キー・マッピング		|key-mapping|
2. 略語補完			|abbreviations|
3. ユーザー定義コマンド		|user-commands|

==============================================================================
1. キー・マッピング				*key-mapping* *mapping* *macro*

新しいマッピングを作成したり、マッピングを削除したり、マッピングをリストするコ
マンドがあります。様々な形式の "map" とそれらのモードとの関係に関しては
|map-overview| をご覧下さい。

:map	 {lhs} {rhs}					*:map*
:nm[ap]  {lhs} {rhs}					*:nm* *:nmap*
:vm[ap]  {lhs} {rhs}					*:vm* *:vmap*
:om[ap]  {lhs} {rhs}					*:om* *:omap*
:map!	 {lhs} {rhs}					*:map!*
:im[ap]  {lhs} {rhs}					*:im* *:imap*
:cm[ap]  {lhs} {rhs}					*:cm* *:cmap*
			マップコマンドを割り当てられてるモードで、キーの連続
			{lhs} を {rhs} にマップします。その結果は、{rhs} も含
			め、他のマッピングも調べられ、このことによりマッピング
			のネストと再帰が可能になります。


:no[remap]   {lhs} {rhs}				*:no*  *:noremap*
:nn[oremap]  {lhs} {rhs}				*:nn*  *:nnoremap*
:vn[oremap]  {lhs} {rhs}				*:vn*  *:vnoremap*
:ono[remap]  {lhs} {rhs}				*:ono* *:onoremap*
:no[remap]!  {lhs} {rhs}				*:no!* *:noremap!*
:ino[remap]  {lhs} {rhs}				*:ino* *:inoremap*
:cno[remap]  {lhs} {rhs}				*:cno* *:cnoremap*
			マップコマンドを割り当てられてるモードで、キーの連続
			{lhs} を {rhs} にマップします。{rhs} へのマッピングを禁
			止することで、マッピングのネストと再帰を避けることがで
			きます。1つのコマンドを再定義するときによく使われます。
			{Vi にはない機能です}


:unm[ap]   {lhs}					*:unm*	*:unmap*
:nun[map]  {lhs}					*:nun*	*:nunmap*
:vu[nmap]  {lhs}					*:vu*	*:vunmap*
:ou[nmap]  {lhs}					*:ou*	*:ounmap*
:unm[ap]!  {lhs}					*:unm!* *:unmap!*
:iu[nmap]  {lhs}					*:iu*	*:iunmap*
:cu[nmap]  {lhs}					*:cu*	*:cunmap*
			マップコマンドを割り当てられてるモードで、{lhs} への
			マッピングを削除します。他のモードに適用されるマッピン
			グは残っています。
			注意: 後ろにスペースがある場合、それも {lhs} の一部と見
			なされます。ですのでこのアンマップコマンドはうまくいき
			ません:
>				:map @@ foo
>				:unmap @@ | print

:mapc[lear]						*:mapc*   *:mapclear*
:nmapc[lear]						*:nmapc*  *:nmapclear*
:vmapc[lear]						*:vmapc*  *:vmapclear*
:omapc[lear]						*:omapc*  *:omapclear*
:mapc[lear]!						*:mapc!*  *:mapclear!*
:imapc[lear]						*:imapc*  *:imapclear*
:cmapc[lear]						*:cmapc*  *:cmapclear*
			マップコマンドが割り当てられているモードでのすべてのマ
			ッピングを削除します。{Vi にはない機能です}
			警告: デフォルトのマッピングも削除されます。

:map
:nm[ap]
:vm[ap]
:om[ap]
:map!
:im[ap]
:cm[ap]
			マップコマンドを割り当てているモードでのすべてのマッピ
			ングをリストします。":map" と ":map!" が一番よく使われ
			ます。というのもこれらは他のモードのものも全て含むから
			です。

:map	 {lhs}						*:map_l*
:nm[ap]  {lhs}						*:nmap_l*
:vm[ap]  {lhs}						*:vmap_l*
:om[ap]  {lhs}						*:omap_l*
:map!	 {lhs}						*:map_l!*
:im[ap]  {lhs}						*:imap_l*
:cm[ap]  {lhs}						*:cmap_l*
			マップコマンドを割り当てているモードでの {lhs} で始まる
			キーの連続へのキー・マッピングをリストします。
			{Vi にはない機能です}

これらのコマンドは一つのキーもしくはキーの連続を文字列にマップするのに使われま
す。機能キーにコマンドの連続を割りつけることもできますし、1つのキーを他のキー
に変換することなどもできます。現在のマッピングを保存し、そして復元する方法につ
いては |:mkexrc| をご覧下さい。

マッピングには5つのセットがあります:
- ノーマルモード: コマンドをタイプする時
- ビジュアルモード: ビジュアル範囲がハイライトされている間にコマンドを打つ時
- 演算待ち状態モード: 演算コマンドはタイプされていて移動コマンドはまだタイプさ
  れていない時 ("d", "y", "c", などの後)。
- 挿入モード。これらは上書きモードでも使われます。
- コマンドラインモード: ":" もしくは "/" コマンドを打った時

選択モードには専用のマッピングはありません。ビジュアルモードと同じものが使われ
ます。|Select-mode-mapping|

						*map-overview* *map-modes*
どのコマンドがどのモードで動作するかの要約:

    コマンド:				      モード:			      ~
					 ノーマル  ビジュアル  演算待ち状態   ~
:map   :noremap   :unmap   :mapclear	     X		X	   X
:nmap  :nnoremap  :nunmap  :nmapclear	     X		.	   .
:vmap  :vnoremap  :vunmap  :vmapclear	     .		X	   .
:omap  :onoremap  :ounmap  :omapclear	     .		.	   X

					    挿入  コマンドライン	~
:map!  :noremap!  :unmap!  :mapclear!	     X	       X
:imap  :inoremap  :iunmap  :imapclear	     X	       .
:cmap  :cnoremap  :cunmap  :cmapclear	     .	       X

オリジナルの Vi はノーマル/ビジュアル/演算待ち状態モードと挿入/コマンドライン
モードにそれぞれ分かれたマッピングは持っていませんでした。ですので、":map" と
":map!" コマンドはいくつかのモードに対してマッピングを設定したり表示させたり
するのです。Vim では ":nmap", ":vmap", ":omap", ":cmap", ":imap" コマンドを使
うことでそれぞれのモードに分けてマッピングを設定することができます。

1つのマッピングをノーマルモードとビジュアルモードに設定し、かつ演算待ち状態モー
ドには設定しない場合は、始めに3つすべてのモードに対して定義してから演算待ち状
態モードへのマッピングを外します。
	:map	xx something-difficult
	:ounmap xx
ビジュアルモードと演算待ち状態モードのみの場合や、ノーマルモードと演算待ち状態
モードのみの場合も同様にします。

							*map-listing*
マッピングをリストするときの始めの2桁にある文字は:

	CHAR		MODE	~
	<Space>		ノーマル、ビジュアル、演算待ち状態
	 n		ノーマル
	 v		ビジュアル
	 o		演算待ち状態
	 !		挿入とコマンドライン
	 i		挿入
	 c		コマンドライン

{rhs} の直前の "*" は再マップすることができないことを示します。

{lhs} の後の最初の非空白文字から、行末(もしくは '|')までのすべては、{rhs} の一
部とみなされます。このことで {rhs} がスペースで終わることができるようになって
います。

メモ: ビジュアルモードでマッピングを使うときは、"'<" マークを使うことができま
す。これは現在のバッファーで最後に選択されたビジュアル範囲の最初です |'<|。

							*map_backslash*
ここでは CTRL-V のみが、マッピングと略語での特殊な文字として触れられているとい
うことに注意してください。'cpoptions' が 'B' を含んでいない場合は、バックスラッ
シュも CTRL-V のように使うことができます。そうすると <> 表記を完全に使うことが
できます |<>|。しかし、"<C-V>" を CTRL-V のように後に続くものの特殊な意味をエ
スケープするような使い方はできません。

バックスラッシュにマップしたり、バックスラッシュをそのまま {rhs} に使いたい場
合は、特別なシーケンス "<Bslash>" を使うことができます。これを使うことで、ネス
トしているマッピングを使うときにバックスラッシュを重ねる必要がなくなります。

							*map_CTRL_C*
{lhs} に CTRL-C を使うことはできません。つまり CTRL-C にマップすることはできな
いのです。CTRL-C は常に動作中のコマンドを中止するのに使えなければならない、と
いうのが理由です。

							*map_space_in_lhs*
{lhs} にスペースを含めるには CTRL-V を前置してください(それぞれのスペースの前
で CTRL-V を2回タイプしてください)。
							*map_space_in_rhs*
もし {rhs} をスペースで始めたければ "<Space>" を使ってください。Vi との互換性
を完全に保ちたい場合は |<>| 表記は使わないで、{rhs} の前に CTRL-V (CTRL-V を2
回タイプする必要があります)を前置してください。
							*map_empty_rhs*
CTRL-V を1つだけ打ち込んだ後に(実際には2回 CTRL-V をタイプする必要があります)
何もタイプしないことで空の {rhs} を作ることもできます。残念ながら vimrc でこれ
をする方法はありません。
							*<Nop>*
何もしないマッピングを作るより簡単な方法は、"<Nop>" を {rhs} に使うことです。
これは |<>| 表記を使えるようにしていると動作します。例えば、ファンクション・キー
8は何もしないようにしたい場合は:
>	:map  <F8>  <Nop>
>	:map! <F8>  <Nop>

							*map-comments*
'"' 文字も {lhs} か {rhs} の一部と見なされるため、これらのコマンドの後ろにコメ
ントを挿入することはできません。

							*map_bar*
'|' 文字はマップコマンドを次のコマンドと分けるのに使われますので、'|' を
{rhs} に含めるにはなにか特別なことをする必要があります。3つの方法があって:
   use	     works when			   example	~
   <Bar>     '<' が'cpoptions'になければ   :map _l :!ls <Bar> more^M
   \|	     'b' が'cpoptions'になければ   :map _l :!ls \| more^M
   ^V|	     Vim と Vi で常に		   :map _l :!ls ^V| more^M

(ここで ^V は CTRL-V を表します; 1つの CTRL-V を挿入するには2回 CTRL-V をタイ
プする必要があります; ここで <> 表記を使って "<C-V>" とすることはできません)。

'cpoptions' をデフォルトの設定で使っていると、これら3つ全てうまく動作します。

'b' が 'cpoptions' にあると、"\|" は '\' で終わるマッピングとそれから別のコマ
ンドが続いているとみなされます。これは Vi コンパチブルではありますが、他のコマ
ンドと比べるとあまり論理的ではありません。

							*map_return*
マッピングに Ex コマンドを含める場合、その後にそれを実行するために行を終了させ
るものを挿入する必要があります。これには <CR> を使うことが推奨されています(参
照 |<>|)。例:
>  :map  _ls  :!ls -l %<CR>:echo "the end"<CR>

挿入もしくはコマンドラインモードで文字列へののマッピングを避けるには、始めに
 CTRL-V をタイプしてください。'paste' オプションがオンになっていると挿入モード
でのマッピングは解除されます。

エラーが起きた場合は(エラーメッセージが出ます)、その後のマッピングは実行されな
いということに注意してください。これは Vi コンパチブルです。

azZtTfF[]rm'`"v と CTRL-X コマンドの次の文字(引数)には、マップされていないとい
うことを覚えておいてください。これは、すでにそのコマンドが同じ名前でマップされ
ていても、すべての名前付きレジスターとマークを使えるようにするために行われまし
た。

							*map-which-keys*
なにかマップしようとしているときに、{lhs} にどのキーを使うかを選択する必要があ
ります。Vim コマンドで使われているキーは避けるようにする必要がありますし、そう
しないとそれらのコマンドを使うことができなくなります。そこでいくつかの提案とし
ては:
- ファンクション・キー <F2>, <F3> など。またShift+ファンクション・キー <S-F1>,
  <S-F2> など。 <F1>は既にヘルプコマンド用に使われていることも注意してください。
- Metaキー(ALTキーを押しながら)。
- "_" か "," 文字とそれに続く文字を使う。"_" と "," コマンドはすでにVimには存
  在していますが(参照|_|)、たぶん使うことはないでしょう。
- 他のコマンドと同じ用途のキーを使う。例えば: CTRL-PとCTRL-N。もっとマッピング
  をするためには、余分な文字を使います。

							*map-examples*
いくつかの例(そのままタイプする形です。"<CR>" はそのまま4文字をタイプします;
この表記を使うには 'cpoptions' に '<' フラグがあってはいけません。

>  :map <F3>  o#include
>  :map <M-g> /foo<CR>cwbar<Esc>
>  :map _x    d/END/e<CR>
>  :map! qq   quadrillion questions

							*map-typing*
Vim はマップされているシーケンスの最初とタイプされた文字を比較します。途中まで
マッチしているものが見つかれば、完全にマッチするかマッチするものがなくなるまで、
さらにタイプされる文字を待ちます。例えば: "qq" に map! していると、最初にタイ
プした 'q' は、次の文字をタイプするまでスクリーンには表示されません。なぜなら、
Vim は次にタイプされる文字が 'q' であるかそうでないかは知ることができないから
です。'timeout' オプションがオンになっていると(デフォルトでオンです)、Vim は1
秒間だけ待ちます(もしくは 'timeoutlen' オプションで指定されている長さだけ)。そ
の後に、'q' はそのものを意味するのだとみなします。もしタイプする速さが遅かった
り、システム自体が遅い場合は 'timeout' オプションを外してください。それから
'ttimeout' オプションもセットしておきたいかもしれません。

							*map-keys-fails*
ある状況では、キーコードが認識されないこともありえます:
- Vimがキーコードを部分的にしか読めない。たいていの場合、これは最初の文字だ
  けです。一部のバージョンのUnixのxtermで起こります。
- 文字(列)のあとのマップされたキーコードがある。例、"<F1><F1>"あるいは"g<F1>"。
この状況においてはキーコードは認識されず、マッピングは失敗します。
この問題を避けるには、２つの方法があります:
- 'cpoptions'から'K'フラグを除く。これで、Vimはファンクションキーの残りの文字
  列を待つようになります。
- <F1>から<F4>によって生成される実際のキーコードを使っているとき、<xF1>から
  <xF4>に一致しているかもしれません。<xF1>から<F1>へ、<xF2>から<F2>へ、などの
  マッピングが存在しますが、これらはマッピングのもう半分のあとでは認識されませ
  ん。<F1>から<F4>のキーコードが正しいことを確認してください:
>	:set <F1>=<type CTRL-V><type F1>
  <F1>を4文字としてタイプします。"="の後の部分は文字通りにではなく、実際のキー
  を打ち込んでください。
別の解決法は、第2の特殊キーへのマッピングで実際のキーコードを使うことです:
>	:map <F1><Esc>OP :echo "yes"<CR>
本物の<Esc>をタイプしないこと。Vimはキーコードを認識して無条件に<F1>と置き換え
てしまいます。

						*recursive_mapping*
{rhs} の中に {lhs} を含める場合は、再帰的なマッピングを使うことができます。
{lhs} がタイプされると、{rhs} に置き換えられます。{rhs} の中に {lhs} があらわ
れるとそれも置き換えられ、...。このことでコマンドを無限の回数繰り返すことがで
きます。エラーを生じさせないと止めることができないのが唯一の問題です。1つだけ
例外があります: {rhs} が {lhs} で始まっていると、始めの文字が再帰的にマップさ
れることはありません(これは Vi 互換です)。
例えば:
>  :map ab abcd
は "a" コマンドを実行して "bcd" をテキストに挿入します。{rhs} の中の "ab" は再
帰的にマップされることはありません。

2つのキーの意味を入れ換えたければ :noremap コマンドを使ってください。例えば:
>  :noremap k j
>  :noremap j k
これは、カーソルの上下移動のコマンドを入れ換えます。

普通の :map コマンドで、'remap' オプションがオンになっていると、{lhs} の一部で
はないテキストが見つかるまでマッピングは起こります。例えば、次のようにしている
と:
>  :map x y
>  :map y x
Vim はまず x を y で置き換え、それから y を x で置き換え、...。これが
'maxmapdepth' 回数起こると、Vim は "recursive mapping" というエラーメッセージ
を表示します。

"index" ファイルを見て使われていないキーを探し、それらを使って実装されている機
能を失うことなくマップすることができます。ファンクション・キーとメタキーを使うこ
とを勧めます。もし、ほとんど使わないコマンドは失ってもいいと思うなら、"_" もし
くは "-" で始まるマッピングを作ってもよいでしょう。また ":help {key}^D" とする
ことで、キーがなんらかのコマンドで使われているかどうか調べることもできます。
({key}は探したいキーを指定し、^D はCTRL-Dです)。

マップされるシーケンスにアンドゥコマンドを含めたとすると、これはテキストをマク
ロが実行される前の状態に戻すことになります。マップされるシーケンスにアンドゥコ
マンドを1個のみ含める限り、このことはオリジナルの Vi 互換です(オリジナルの Vi
でアンドゥコマンドを2つ、マップされるシーケンスに含めても意味がありません。始
めのアンドゥを実行する前のテキストの状態に戻るだけです)。

特殊なキーをマップに含めるのには、3つの方法があります:
1. Vi 互換の方法: キーコードをマップします。これは <Esc> で始まるシーケンスで
  あることがよくあります。このようなマッピングを挿入するには、まず ":map " と
  タイプしてから、機能キーを押す前に CTRL-V をタイプする必要があります。もし、
  そのキーのキーコードが termcap (t_options) にあれば、自動的に内部コードの形
  式に変換され、二番目のような方法のマッピングになります('k' フラグが
  'cpoptions' に含められていない限り)。
2. 2番目の方法は機能キーの内部コードを使う方法です。そうしたマッピングを挿入す
   るには、まず CTRL-K を押してから機能キーを押してください。もしくは "#1",
   "#2", .. "#9", "#0", "<Up>", "<S-Down>", "<S-F7>", などの形式を使ってくださ
   い。(参照: キーの表 |key-notation|。<Up> からのすべてのキーを使うことができ
   ます)。始めの10個のファンクション・キーは2つの方法で定義できます: "#2" のよ
   うな番号だけの方法と、"<F>" と共に "<F2>" のように指定する方法です。この両
   方がファンクション・キー2を表します。"#0" はファンクション・キー10を表し、
   t_f10 で定義されます。これはキーボードによってはファンクション・キー0である
   かもしれません。'cpoptions' に '<' フラグが含められていると、<> 形式は使え
   ません。
3. termcap エントリーを <t_xx> という形式で使う方法です。"xx" は termcap エン
   トリーの名前です。どんなエントリーの文字列も使うことができます。例えば:
>    :map <t_F3> G
   ファンクション・キー13を "G" にマップします。これは 'cpoptions' に '<' フラ
   グが含められていると使えません。

二番目と三番目の方法の利点は、異なる端末で修正なしでマッピングが動作することで
す(機能キーは、端末によらずそれと同じ内部コード、もしくは実際のキーコードに変
換されます。これが動作するには termcap が正しく動作しなければなりません。そし
て、同じマッピングを使っていなければなりません)。

詳細: まず Vim はキーボードから入力されるシーケンスがマップされているかどうか
を調べます。マップされていなければ、端末のキーコードが試されます(参照
|terminal-options|)。もし端末のコードが見つかれば、内部コードで置き換えられま
す。それからさらに、マッピングのチェックが行われます(内部コードを他にマップで
きるように)。スクリプトファイルに書き込まれる内容は、どのように解釈されたかに
よります。もし端末のキーコードがマッピングとして解釈された場合は、キーコードそ
のものがスクリプトファイルに書き込まれます。端末のコードとして解釈された場合は、
内部コードがスクリプトファイルに書き込まれます。

==============================================================================
2. 略語補完				*abbreviations* *Abbreviations*

略語補完は、挿入モード、上書きモード、コマンドラインモードで使えます。略記とし
て登録されている単語を挿入した場合、それが表す単語に置き換えられます。これは、
よく使う長い単語を打ち込むときのタイプ数を減らしてくれます。そして、明確なスペ
ルエラーを自動的に修正するのにも使えます。
例:

	:iab ms MicroSoft
	:iab tihs this

略記には三つの種類があります:

full-id	  "full-id" タイプは完全なキーワード文字から構成されます( 'iskeyword'
	  オプションに含まれる文字です)。最も一般的な略記です。

	  例: "foo", "g3", "-1"

end-id	  "end-id" タイプはキーワード文字で終わりますが、他の文字はキーワード
	  文字ではないです。

	  例: "#i", "..f", "$/7"

non-id	  "non-id" タイプは非キーワード文字で終わります。他の文字はスペースと
	  タブ以外のどんなタイプの文字でもよいです。{Vi では、このタイプはサポ
	  ートされていません}

	  例: "def#", "4/7$"

略記できない文字列の例: "a.b", "#def", "a b", "_$r"

略記は非キーワード文字をタイプしたときに解釈されます。これは、挿入モードを終わ
らせる <Esc> をタイプしたり、コマンドを終わらせる <CR> をタイプしたときにも起
こります。略記を終わらせる非キーワード文字は、略記が展開された後に挿入されます。
例外は <C-]> 文字で、略記以外の文字を挿入せずに略記を展開するのに使われます。

例:
>   :ab hh	hello
	    "hh<Space>" で "hello<Space>" に展開されます。
	    "hh<C-]>" で "hello" に展開されます。

カーソルの前の文字が略記にマッチしなければなりません。それぞれのタイプで、さら
に規則があります:

full-id   マッチしたものの前が非キーワード文字であるか、行もしくは挿入が始まっ
	  た場所。例外: 略記が1文字のみである場合、その前にスペースか <Tab> 以
	  外の非キーワード文字があると解釈されません。

end-id	  マッチしたものの前が非キーワード文字であるか、スペースもしくは <Tab>
	  であるか、行もしくは挿入が始まる場所。

non-id	  マッチしたものの前が<Tab> であるか、行もしくは挿入が始まる場所。

例: ({CURSOR}は非キーワード文字をタイプする場所です)
>  :ab foo   four old otters
		" foo{CURSOR}"	  は " four old otters" に展開されます
		" foobar{CURSOR}" は展開されません
		"barfoo{CURSOR}"  は展開されません

>  :ab #i #include
		"#i{CURSOR}"	  は "#include" に展開されます
		">#i{CURSOR}"	  は展開されません

>  :ab ;; <endofline>"
		"test;;"	  は展開されません
		"test ;;"	  は "test <endofline>" に展開されます

挿入モードで略記を避けるには: 略記の一部をタイプしてから挿入モードを <Esc> で
抜け、再度挿入モードに "a" で入って残りをタイプします。もしくは、略記の後の文
字の前で CTRL-V をタイプします。
コマンドラインモードで略記を避けるには: 略記の展開を避けるには、略記の途中で
 CTRL-V を2回タイプしてください。普通の文字の前の CTRL-V はだいたい無視されま
す。

略記の後で、カーソルを動かすこともできます。
>   :iab if if ()<Left>
これは、'cpoptions' に '<' フラグが含まれていると、うまく動作しません。|<>|

デフォルトで設定されている略記はありません。

略記の展開は再帰的には行われません。":ab f f-o-o" という略記を問題なく使うこと
ができます。しかし、略記をマップすることはできます。 {Vi ではいくつかのバージョ
ンで再帰的な略記をサポートしていますが、そこになんら明確な理由があるわけではな
いです}

'paste' オプションがオンだと略記は使えなくなります。

						*:ab* *:abbreviate*
:ab[breviate]		すべての略記をリストします。1列目の文字は、略記が使わ
			れるモードを示しています: 'i' は挿入モード、'c' はコマ
			ンドラインモード、'!' はその両方。

:ab[breviate] {lhs}	{lhs}で始まる略記をリストします。

:ab[breviate] {lhs} {rhs}
			{rhs}の略記を{lhs}として定義します。既に{lhs}が定義さ
			れていると、新しい{rhs}で置き換えられます。{rhs}はスペ
			ースを含んでいてもかまいません。

						*:una* *:unabbreviate*
:una[bbreviate] {lhs}	{lhs}への略記をリストから全て削除します

						*:norea* *:noreabbrev*
:norea[bbrev] [lhs] [rhs]
			":ab" と同じですが、{rhs}への再帰的なマッピングを許し
			ません。{Vi にはない機能です}

						*:ca* *:cabbrev*
:ca[bbrev] [lhs] [rhs]	":ab" と同じですが、コマンドラインモードのみで有効で
			す。{Vi にはない機能です}

						*:cuna* *:cunabbrev*
:cuna[bbrev] {lhs}	":una" と同じですが、コマンドラインモードのみで有効で
			す。{Vi にはない機能です}

						*:cnorea* *:cnoreabbrev*
:cnorea[bbrev] [lhs] [rhs]
			":ab" と同じですが、コマンドラインモードのみで有効で、
			{rhs}への再帰的なマッピングを許しません。{Vi にはない
			機能です}

						*:ia* *:iabbrev*
:ia[bbrev] [lhs] [rhs]	":ab" と同じですが、挿入モードのみで有効です。{Vi には
			ない機能です}

						*:iuna* *:iunabbrev*
:iuna[bbrev] {lhs}	":una" と同じですが、挿入モードのみで有効です。{Vi に
			はない機能です}

						*:inorea* *:inoreabbrev*
:inorea[bbrev] [lhs] [rhs]
			":ab" と同じですが、挿入モードのみで有効で、{rhs}への
			再帰的なマッピングを許しません。{Vi にはない機能です}

							*:abc* *:abclear*
:abc[lear]		すべての略記を削除します。{Vi にはない機能です}

							*:iabc* *:iabclear*
:iabc[lear]		挿入モードでのすべての略記を削除します。{Vi にはない機
			能です}

							*:cabc* *:cabclear*
:cabc[lear]		コマンドラインモードでのすべての略記を削除します。
			{Vi にはない機能です}

							*using_CTRL-V*
特殊な文字を略記の <rhs> で使うことは可能です。ほとんどの印字可能ではない文字
の特殊な意味を避けるのには、CTRL-V を使うことができるはずです。いくつの
CTRL-V を挿入すればよいかは、どのようにして略記を挿入するかによります。これは
マッピングに関しても同様です。いくつか例を使ってみましょう。

"esc" を実際の <Esc> 文字を挿入する略記にしたいとしましょう。Vim で ":ab" コマ
ンドを使うときには、次のようにしなければなりません: (ここで ^V は CTRL-V で、
^[ は <Esc> です)

タイプ:     ab esc ^V^V^V^V^V^[

	キーボードからのすべてのインプットは ^V クォート解釈される必要がありま
	す。ですので、1番目と、3番目と、5番目の ^V 文字は単に2番目と4番目の ^V
	と、^[ をコマンドラインで使えるようにします。

見え方:     ab esc ^V^V^[

	コマンドラインには実際には2つの ^V が ^[ の前に含まれています。もしそ
	うするつもりがあれば、これは .exrc ファイルでの見え方になるはずです。
	始めの ^V は2番目の ^V をクォートするためにあります; :ab コマンドは
	^V をクォート文字として扱いますので、略記の中でクォートされたホワイト
	スペースもしくは | 文字を使うことができます。:ab コマンドは ^[ に対し
	ては何も特殊な処理は行いません。ですので、クォートする必要もないです。
	(しかしながら、クォートしても問題はないです; 7(8はだめです!)個の ^V を
	挿入しても動作します).

格納:	    esc     ^V^[

	略記は解析された後、短い形式("esc")と長い形式("^V^[")の2文字として、略
	記テーブルに格納されます。:ab コマンドを引数なしで実行したときに、この
	形で略記は表示されます。

	後に、ユーザーが "esc" をタイプしたことによって略記が展開されたとき、
	長い形式はキーボードのインプットと同じようにように ^V 解釈される必要が
	あります。^V が、^[ が "挿入モードから抜ける" 文字として解釈されること
	を防ぐのです。その代わりに、^[ がテキストに挿入されます。

展開: ^[

[例は Steve Kirkendall によって提供されました]

==============================================================================
3. ユーザー定義コマンド					*user-commands*

ユーザー独自の Ex コマンドを定義することができ、内蔵のコマンドと同様に動作しま
す(範囲指定や、引数を持つことができます。引数はファイル名、バッファー名、など
として補完することも可能です)。違いは、コマンドが実行されたときに、いったん普
通の Ex コマンドに変換されてから実行されるということです。

すべてのユーザー定義コマンドは大文字で始まる必要があります。これは内蔵のコマン
ドと混同しないようにするためです。(とりわけ :Next や :Print などのいくつかの内
蔵コマンドは、大文字で始まっています。こういった場合、内蔵のコマンドが常に優先
されます)。ユーザーコマンドの始めの文字以外の文字は、大文字であっても小文字で
あっても、または数字であってもかまいません。数字を使う場合、数字を引数に取るほ
かのコマンドが曖昧になるかもしれない、ということに注意してください。例えば、
"Cc2" コマンドは ":Cc2" という引数なしのユーザーコマンドでもありえますし、"2"
という引数を取った ":Cc" コマンドとしても解釈されうるのです。これらの問題を避
けるには、コマンド名と引数の間にスペースを挿入することを勧めます。

ユーザー定義コマンドを使うときに、コマンドの省略形を使うこともできます。しかし
ながら、その省略形が唯一でなければエラーが起きます。さらには、内蔵コマンドの方
が常に優先されます。

例:
>	:command Rename ...
>	:command Renumber ...
>	:Rena				" "Rename" を意味します
>	:Renu				" "Renumber" を意味します
>	:Ren				" エラー - 曖昧
>	:command Paste ...
>	:P				" 内蔵の :Print です

スクリプトの中で使う場合は、完全な名前をユーザー定義コマンドにたいして用いるこ
とが勧められています。

:com[mand]						*:com* *:command*
			すべてのユーザー定義コマンドをリストします。コマンドを
			リスとしているときの、始めの2列の文字は
			    !	-bang 属性を持つコマンド
			    "	-register 属性を持つコマンド
			(属性に関する詳細は下をご覧下さい)

:com[mand] {cmd}	{cmd} で始まるユーザー定義コマンドをリストする

:com[mand][!] [{attr}...] {cmd} {rep}
			ユーザーコマンドを定義する。コマンド名は {cmd} でそれ
			を置き換えるテキストが {rep} です。コマンドの属性(下を
			参照)は {attr} です。既にコマンドが存在している場合は、
			! が指定されていない限り(この場合は再定義されます)、エ
			ラーが報告されます。

:delc[ommand] {cmd}					*:delc* *:delcommand*
			ユーザー定義コマンド {cmd} を削除します。

:comc[lear]						*:comc* *:comclear*
			すべてのユーザー定義コマンドを削除します。

コマンドの属性

Vim はユーザー定義コマンドを他の Ex コマンドと同じように扱います。引数を持った
り、範囲を指定することができます。引数はファイル名、バッファー、などに補完する
ことができます。正確には、これはコマンドが定義されたときに指定されたコマンドの
属性によります。

たくさんの属性があって、それらは4つの分野に分けることができます: 引数の扱い方、
補完の仕方、範囲指定の仕方、特殊なケース。属性は分野毎に下に記述されています。

引数の扱い方

デフォルトでは、ユーザー定義コマンドは引数を取りません(引数が与えられた場合は
エラーを報告します)。しかしながら、-nargs 属性を使って、コマンドが引数を取るよ
うにすることはできます。有効なのは:

	-nargs=0    引数を取らない(デフォルト)
	-nargs=1    1個だけ引数を要求する
	-nargs=*    いくつでも引数を取れる(0, 1, もしくはそれ以上)
	-nargs=?    0もしくは1個の引数が取れる
	-nargs=+    引数が与えられる必要があるが、いくつでもよい

この文脈では、引数は(エスケープされていない)スペースで分けられていると仮定され
ています。

補完の仕方

デフォルトでは、ユーザー定義コマンドは引数の補完を行おうとはしません。しかしな
がら、下記の属性を1つもしくは複数指定することで、引数の補完を行うことができる
ようになります。

	-complete=augroup	autocmd グループ
	-complete=buffer	バッファー名
	-complete=command	Ex コマンド(と、引数)
	-complete=dir		ディレクトリ名
	-complete=event		autocommand のイベント
	-complete=file		ファイルとディレクトリ名
	-complete=help		ヘルプの主題
	-complete=highlight	ハイライト・グループ
	-complete=menu		メニュー
	-complete=option	オプション
	-complete=tag		タグ
	-complete=tag_listfiles	CTRL-D を押した時にタグ、ファイル名を表示
	-complete=var		ユーザー変数

範囲指定の仕方

デフォルトでは、ユーザー定義コマンドは行番号による範囲指定を受け付けません。し
かしながら、コマンドが範囲指定を受け付けるようにすることは可能です(-range 属性
によって)。もしくは、任意のカウント値を取るようにすることもできます。この場合、
行番号の位置(|:split| コマンドのように -range=N)で指定するか、"count" 引数
(|:Next| コマンドのように -count=N)で指定するかです。可能な属性は:

	-range	    範囲指定が可能になります、デフォルトは現在の行
	-range=%    範囲指定が可能になります、デフォルトはファイル全体(1,$)
	-range=N    行番号位置で指定される(|:split| のように)カウント(デフォル
		    ト N)
	-count=N    行番号位置で指定されるカウント(デフォルト N)か、初期化引数
		    (|:Next| のように)。-count (デフォルトなしで)と指定すると
		    -count=0 のように動作します。

-range=N と -count=N は相互に排他的であるということに注意してください。- どち
らかのみを指定することができます。

特殊なケース

いくつかの特殊なケースもあります:

	-bang	    コマンドは ! 修飾子を取ることができます(:q や :w のように)
	-register   コマンドの始めの引数はオプションとしてレジスター名を指定す
		    ることができます(:del, :put, :yank のように)。

-count と -register 属性の場合で、オプショナルな引数が与えられた場合、引数リス
トから削除されてそれぞれを置き換えるテキストが利用できるようになります。

置き換えテキスト

ユーザー定義コマンドの置き換えテキストは、<...> 表記を使った特殊なエスケープシー
ケンスがあるかどうか調べられます。エスケープシーケンスは、コマンドラインから入
力される値によって置き換えられ、他のテキストは全て変更なしでコピーされます。結
果として生成される文字列が Ex コマンドとして実行されます。もしエスケープシーケ
ンスの最初の < にバックスラッシュが前置してあると、シーケンスは変更されず元の
ままコピーされます。

有効なエスケープシーケンスは

						*<line1>*
	<line1>	コマンド範囲の始めの行
						*<line2>*
	<line2>	コマンド範囲の最後の行
						*<count>*
	<count>	与えられたカウント ('-range' と '-count' 属性で記述されている)
						*<bang>*
	<bang>	('-bang' 属性を参照) コマンドが ! 修飾子付きで実行された場合に
		! に展開され、それ以外は何にも展開されません。
						*<reg>* *<register>*
	<reg>	('-register' 属性を参照) 指定されていれば、オプショナルなレジ
		スター。それ以外は何にも展開されません。<register> もこれと同
		義です。
						*<args>*
	<args>	与えられた通りのコマンド引数。(しかし、上で述べられているよう
		に、カウントかレジスターが引数の一部になり得るわけですが、そう
		するとそれらは <args> の一部とはなりません)。
	<lt>	1つの '<' (小なり)文字。これは、これらエスケープシーケンスのう
		ちのコピーを文字どおりに得たい場合に、必要となります。- 例えば、
		<bang> を得るには <lt>bang> として下さい。

エスケープシーケンスの始めの2文字が "q-" であると(例えば、<q-args>)、値はその
式で使うのに有効な値となるようにクォートされます。これは引数を1つの値として扱
います。

コマンドが引数をユーザー定義関数に渡すことができるようにするために、特別な形式
 <f-args> ("function args")があります。これらはコマンドの引数をスペースの位置
で区切り、それぞれの引数をここにクォートし、そして <f-args> シーケンスはコンマ
で区切られるクォートされた引数のリスとに置き換えられます。下のMycmdの例をご
覧下さい。引数がなければ、<f-args>もまた引数を持ちません。

例

>   " ここから最後までのすべてを削除します
>   :com Ddel +,$d

>   " 現在のバッファーをリネームします
>   :com -nargs=1 -bang -complete=file Ren f <args>|w<bang>

>   " 指定された範囲をあるファイルの内容に置き換えます
>   " (1行に書きます)
>   :com -range -nargs=1 -complete=file
>	 Replace <line1>-pu_|<line1>,<line2>d|r <args>|<line1>d

>   " 指定された範囲の行数を数える
>   com! -range -nargs=0 Lines :echo <line2> - <line1> + 1 "lines"

>   " ユーザー関数を呼びます(<f-args>の例)
>   :com -nargs=* Mycmd call Myfunc(<f-args>)

次のように実行された場合は:
>	:Mycmd arg1 arg2
次のものを起動します:
>	:call Myfunc("arg1","arg2")

>   " より現実的な例
>   :function Allargs(command)
>   :	let i = 0
>   :	while i < argc()
>   :	   if filereadable(argv(i))
>   :	     execute "e " . argv(i)
>   :	     execute a:command
>   :	   endif
>   :	   let i = i + 1
>   :	endwhile
>   :endfunction
>   :command -nargs=+ -complete=command Allargs call Allargs(<q-args>)

Allargs コマンドは、引数としてどのVimコマンドでも取ることができ、引数のリス
トのすべてのファイルに対して実行されます。使い方の例 ("e" フラグをつけてエラー
を無視しており、また "update" コマンドで変更されたバッファーを書き込んでいるこ
とに注意してください):
>	:Allargs %s/foo/bar/ge|update
これは、次のものを起動します:
>	:call Allargs("%s/foo/bar/ge|update")

 vim:tw=78:ts=8:ft=help:norl:
