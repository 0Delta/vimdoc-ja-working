COMMENT: テキストの大規模な修正方法
STATUS: finished 6.3.054
TRANSLATOR: 清水俊彦(しみず) <mailto:t_smz@syd.odn.ne.jp>

*usr_10.txt*	For Vim version 6.1.  Last change: 2001 Sep 18
*usr_10.txt*	For Vim version 6.3.  Last change: 2004 Mar 12

		     VIM USER MANUAL - by Bram Moolenaar

				 大規模な変更		     


第４章では、ちょっとした変更を加える方法について説明しました。この章では変更
を繰り返したり、大量の文書に影響を与えるような変更方法について説明いをしま
しょう。visualモードでは矩形のテキストに対していろいろな処理を行えます。また
本当に複雑なことを実行するような外部プログラムを使うこともできます。

|10.1|	レコーディング(記録)とプレイバック(再現)
|10.2|	置換
|10.3|	コマンドの範囲
|10.4|	グローバル(global)コマンド
|10.5|	visualブロックモード
|10.6|	ファイルの一部の保存と読み込み
|10.7|	テキストの整形
|10.8|	大文字/小文字の変更
|10.9|	外部プログラムの利用

     Next chapter: |usr_11.txt|  クラッシュからの回復
 Previous chapter: |usr_09.txt|  GUIの利用
Table of contents: |usr_toc.txt|

==============================================================================
*10.1*	レコーディング(記録)とプレイバック(再現)

"."コマンドは直前の変更コマンドを繰り返します。しかし、一箇所だけではない、
もう少し複雑なことを繰り返したい場合はどうすればよいでしょう？このために記録
コマンドがあります。次の３つの手順を行います。

1. "q{register}" コマンドを実行すると、指定の{register}に一連のキー入力を記録
   し始めます。レジスタ名は"a"～"z"のいずれかです。
2. 記録したいコマンドを入力します。
3. 記録を終了させるには"q"を押します。

記録したマクロは"@{register}"コマンドで実行できます。

このコマンドをどのように使うか練習してみましょう。次のようなファイル名リスト
があるとします。

	stdio.h ~
	fcntl.h ~
	unistd.h ~
	stdlib.h ~

これを次のように変更したいとします。

	#include "stdio.h" ~
	#include "fcntl.h" ~
	#include "unistd.h" ~
	#include "stdlib.h" ~

まず１行目の行頭に移動します。そして次のコマンドを実行します。

	qa			マクロの記録をレジスタａに開始します。
	^			行頭に移動します。
	i#include "<Esc>	行頭に次の文字列を挿入します。
				#include "
	$			行末に移動します。
	a"<Esc>			行末に引用符(")を追加します。
	j			カーソルを次の行に移動します。
	q			マクロの記録を終了します。

さて、１回分の作業はこれで終りました。ここで"@a"コマンドを３回実行して、変更
を繰り返すことができます。
"@a"コマンドの前にはカウンタ指定ができます。指定するとその回数だけマクロを実
行します。この場合なら、次のようにします。 >

	3@a


移動と実行
----------

変更したい行がいろんな場所に分散している場合は、カーソルを各場所に移動して、
"@a"コマンドを使います。それを一度でも実行すれば、再実行は"@@"でできます。
こっちの方がちょっとだけ入力が簡単です。今、レジスタｂを実行するために"@b"を
使うと、次に"@@"を実行した時にはレジスタｂのマクロが実行されます。
このプレイバック方法と"."を使う方法を比べると、数点の違いがあります。まず最
初に"."は１箇所の変更しか繰り返せないという点です。上の練習でも見たように、
"@a"では複数の変更と移動がこなせます。次に"."は直前の変更しか繰り返せないと
いう点です。レジスタ内容を実行する方法なら、何らかの変更を加えた後でも"@a"
を使って記録したコマンドを再実行できます。最後に、26のレジスタを使える点で
す。つまり実行したいコマンド群を２６個まで覚えておけるということです。


レジスタの使用
--------------

記録に用いるレジスタはヤンクや削除で使っているのと同じものです。これはレジス
タを操作して、記録内容を他のコマンドと合成することができるということです。
レジスタｎにいくつかのコマンドが記録されているとしましょう。ところが、それを
"@n"で実行しようとして何かミスがあることに気付きました。最初から記録をやり直
すこともできますが、また他の間違いをしてしまうかもしれません。そうではなく、
次のようなテクニックを使います。

	G			ファイルの最後にジャンプ
	o<Esc>			空行を作成
	"np			レジスタｎの内容をプット。すると記録した
				時に入力したコマンドが文字列表示されます
	{edits}			間違っている部分を修正。これは普通に編集して
				実施
	0			その行の行頭に移動
	"ny$			修正したコマンドをレジスタｎに格納
	dd			不要になった最終行を削除

さて、これで"@n"すると正しいコマンドが実行されます。(記録されたコマンドが改
行を含む場合は上記の最後の２項目はその全内容を含むようにしてください)


レジスタに追記
--------------

ここまでレジスタ名には小文字を使ってきました。レジスタに追記するには大文字を
使います。
単語を変更するためのコマンドがレジスタｃに記録されているとします。これは目的
通り動くのですが、次に変更すべき単語を探す処理を追加する場合、次のようにしま
す。 >

	qC/word<Enter>q

このコマンドは、記録内容をレジスタｃに追記するという"qC"で始まっています。
つまり書き込むレジスタ名を大文字で書くと、その小文字のレジスタに追記すると
いう意味になるのです。

これは記録コマンドだけでなく、ヤンクや削除コマンドでも同じです。例えば、いく
つかの行をレジスタａに集めたいとします。最初の行では次のコマンドを実行し
ます。 >

	"aY

次に２つ目の行に移動し、このように入力します。 >

	"AY

これを該当する全ての行で実行します。レジスタａにはヤンクした順に全行が含ま
れています。

==============================================================================
*10.2*	置換							*find-replace*

":substitute"コマンドはファイルの全行について文字列の置換を実行します。この
コマンドは次の形式で指定します。 >

	:[range]substitute/from/to/[flags]

このコマンドは[range]で指定した行範囲の中で、文字列"from"を文字列"to"に変更
します。例えば、次のコマンドを実行すると、全行の"Professor"を"Teacher"に置換
します。 >

	:%substitute/Professor/Teacher/
<
	Note:
	":substitute"の綴りを完全に入力するような人はまずいません。たいてい
	の場合、短縮形の":s"が使われます。以降ではこの短縮形を使います。

コマンドの前の"%"はファイル全体を対象とする指定です。範囲指定をしないと、
":s"コマンドは現在行のみを対象とします。範囲指定については次の節で述べます。
|10.3|

デフォルトでは、":substitute" コマンドは各行の最初に見つかったものだけを変
更します。例えば、上のコマンドは次のように動きます。

	Professor Smith criticized Professor Johnson today. ~

これを次のように変更します。

	Teacher Smith criticized Professor Johnson today. ~

その行にある全箇所を置換するには g(グローバル)フラグをコマンドに追加します。
次のようになります。 >

	:%s/Professor/Teacher/g

これを実行すると、先程の行は次のようになります。

	Teacher Smith criticized Teacher Johnson today. ~

他にもフラグには p(print=出力) と c(confirm=確認)があります。pフラグは変更の
ある各行を画面に表示します。また cフラグは置換する前に本当に置き換えるかどう
かを確認します。次のように入力します。 >

	:%s/Professor/Teacher/c

vimは最初に"Professor"が現れる箇所を見つけ、今まさに置換しようとしているテキス
トを表示し、次のようなプロンプトを表示します。
>
	replace with Teacher (y/n/a/q/l/^E/^Y)?

ここでは次のいずれかの返答が必要です。

	y		Yes; 変更
	n		No; 変更せずにスキップ
	a		All; これは変更し、以降のものは全て確認なしで変更
	q		Quit; これも含めて、以降は変更しない
	l		Last; これを変更した上で置換を終了
	CTRL-E		画面を１行逆スクロールする
	CTRL-Y		画面を１行スクロールする


置換コマンドの"from"の部分は実際にはパターンです。これは検索コマンドで使わ
れるのと同じ種類のものです。例えば次の例では、行頭に現れる"the"のみを置換
の対象とします。 >

	:s/^the/these/

"from"や"to"にスラッシュ(/)を含むようなパターンを書きたいのであれば、その前
に逆スラッシュ(\)を置きます。例えば次の通りです。 >

	:s/one\/two/one or two/

ここでは"one/two"という文字列を"one or two"に置換しています。
もっと簡単な方法もあります。実は":s"コマンドの直後の文字は別にスラッシュ(/)
でなくてもいいのです。例えば、これをプラス(+)にするとこのようになります。 >

	:s+one/two+one or two+

この場合は、スラッシュの前に逆スラッシュを付ける必要はありません。

==============================================================================
*10.3*	コマンドの範囲

":substitute"コマンドや多くのコマンドラインモードのコマンドでは一部の行に
対して実行させることができます。これを範囲(range)と呼びます。
範囲指定の基本形式は {number},{number} です。 >

	:1,5s/this/that/g

この例では置換コマンドを１行目～５行目に対して実行します。５行目も範囲に入
ります。範囲指定は必ずコマンドの前に指定します。

数字が１つだけの場合は、特定の１行を指定する時に使います。 >

	:54s/President/Fool/

一部には範囲を指定しないとファイル全体を対象とするコマンドもあります。このよ
うなコマンドに現在行を対象とさせるには"."を使います。":write"コマンドはその
ように動きます。範囲を指定しないとファイル全体を保存し、現在行だけをファイル
に保存するには次のようにします。 >

	:.write otherfile

最初の行は１行目となります。では最終行の指定は？ それは"$"で示します。例え
ば、現在行から最終行を範囲として置換を行うのは次のとおりです。 >

	:.,$s/yes/no/

先程も使った"%"は実際には"1,$"、つまり最初の行から最終行までと同じことです。


範囲でのカッコの使用
--------------------

本のある章を編集していて、そこに出てくる"grey"を全て"gray"に置換したいとし
ましょう。ただしその章だけを対象とし、以降の章は対象にしたくありません。また
章の区切りは行頭が"Chapter"の行があるものとします。次のコマンドでそれができ
ます。 >

	:?^Chapter?,/^Chapter/s=grey=gray=g

パターン検索を２回使っています。最初の"?^Chapter?"は現在行から逆方向に検索
を行い、ヒットするパターンを探します。この ?pattern? という範囲の書き方は逆
方向の検索に使います。同じように "/^Chapter/"は前方検索を行い、次の章の先
頭を求めています。
上の例では置換コマンドのセパレータには"="を使っています。これはスラッシュを
多用することによる解りにくさを避けるためです。スラッシュでもそれ以外の文字
でも問題なく動きます。


加算と減算
----------

実は上のコマンドには、ちょっとだけ間違いがあります。もし次の章のタイトルに
"grey"の文字列がある場合も置換の対象となってしまいます。まあそれが期待して
いたことかも知れませんが、そうでなければ？ その場合はオフセットを指定すれば
よいのです。
パターンを探して、その直前の行までを対象とするには次のようにします。 >

	/Chapter/-1

数字は１でなくても構いません。次の例はヒットした行の２行下を指定するという意
味になります。 >

	/Chapter/+2

オフセット値は範囲を示す他の項目にも使えます。次のようにも使えます。  >

	:.+3,$-5

これは、現在行の３行下から、最終行の５行上までの範囲を指定してます。


マークの利用
------------

特定の場所を示すのに行番号の代りに、その場所を覚えておいてそれを範囲として
使用するのにマークが使えます。
マークについては第３章で触れました。例えば、選択範囲としたい領域の先頭で"mt"
でマークし、領域の末尾で"mb"でマークします。すると、マークを使って次のように
範囲指定をすることができます。(マークのある行も範囲に入ります) >

	:'t,'b


visualモードと範囲

visualモードでも範囲選択ができます。":"を押してコマンドラインモードに入った
時、次のような表示となります。 >

	:'<,'>

ここでコマンドを入力すると、そのコマンドはビジュアルに選択した行範囲に対し
て適用されます。

	Note:
	行の一部をvisualモードで選択した場合や、CTRL-Vで文字列を矩形選択し
	た場合でも、コマンドラインモードのコマンドは行全体を対象とします。
	これは今後のバージョンのvimでは変更になるかも知れません。

'<と'>の実体はvisual選択範囲の始点と終点です。他の範囲をvisualモードで選択
しない限り、この２つのマークの場所は残っています。ですから、"'<"コマンドを
使えば、visualモードで選択していた範囲の始点にジャンプできます。次のように
マークと他の項目を組み合せることもできます。 >

	:'>,$

これはvisual領域の終点から、ファイルの末尾までを行範囲を示します。


行番号
------

変更したい行数が分かっている場合、その数を入力してから":"を押します。例えば
"5:"と入力した場合、次のような表示となります。 >

	:.,.+4

続けて、使いたいコマンドを入力できます。範囲として、"."(現在行)～".+4"(４行
下)が使われます。つまり範囲は５行ということです。

==============================================================================
*10.4*	global(グローバル)コマンド

ここで説明する":global"コマンドはvimの中でも最強の部類に属するコマンドです。
これはパターンにヒットする行を探し、その行で任意のコマンドを実行します。コマン
ドの形式は次の通りです。 >

	:[range]global/{pattern}/{command}

これは":substitute"コマンドに似ています。ただ、文字列を他のものに置き換える
のではなく、{command}コマンドを実行するのです。

	Note:
	":global"で実行するコマンドは":"で始まるコマンドだけです。通常モード
	のコマンドは直接は使えません。ただし、|:normal|コマンドについては実
	行できます。

C++スタイルのコメント行にある"foobar"だけを"barfoo"に置換したいとしましょう。
コメント行は"//"で始まる行とします。次のコマンドを使いましょう。 >

	:g+//+s/foobar/barfoo/g

ここでの":g"は":global"の短縮形です。":substitute"を":s"と縮めるのと同じで
す。次に"+"記号で囲まれた文字があります。今回はスラッシュを含んだパターンを
検索するので、パターンのセパレータに"+"を使っています。その次は"foobar"を
"barfoo"に置換するコマンドがあります。
グローバルコマンドの適用範囲はデフォルトではファイル全体です。ですから上の例
では範囲指定をしていません。この点は":substitute"がデフォルトでは現在行だけ
を対象とするのと異なります。
このコマンドは完全ではありません。というのは行の途中で"//"が出てきた場合も
ヒットするため、行頭から"//"までの間も置換の対象となってしまいます。

":substitute"と同じく、どんなパターンでも使えます。もっと複雑なパターンについ
て後で学べば、それも使えます。

==============================================================================
*10.5*	ブロック選択のビジュアルモード

CTRL-Vを使うと、テキストの矩形部分を選択することができます。ここではブロック
で使える特殊なコマンドについて説明します。

visualブロックモードでは、"$"コマンドには特殊な意味があります。直前のモーショ
ンコマンドに"$"を使ったのであれば、ビジュアル領域の全行が行末まで拡張されま
す。これは現在のカーソル行が他の行よりも短かくても全行の行末まで選択が拡張
されます。この効果は左右のカーソル移動コマンドを使わない限り、残ります。
つまり、"j"なら効果は残りますが、"h"では停止します。


テキストの挿入
--------------

"I{string}<Esc>"コマンドを使うと、ビジュアルブロックの各行の左側に{string}を
挿入します。CTRL-Vを押すと、ブロック選択のビジュアルモードに入ります。そこで
ブロックを決めるためにカーソルを動かします。次に"I"を押して挿入モードに入り、
文字列の挿入を開始します。ここで文字を入力するとは最初の行にだけ表示されます。
<Esc>を押して挿入モードを抜けると、上で入力した文字列が魔法のようにビジュア
ル領域の残りの行に挿入されます。例を示します。

	include one ~
	include two ~
	include three ~
	include four ~

カーソルを"one"の"o"に合わせてCTRL-Vを押します。"3j"で、カーソルを"four"の
場所まで動かします。これで４行にまたがるブロック選択が出来ました。ここで、
次のコマンドを入力します。 >

	Imain.<Esc>

結果は次のようになります。

	include main.one ~
	include main.two ~
	include main.three ~
	include main.four ~

もしブロックの途中に短かい行があって、ブロックに入っていない行があった場合、その
行には何も挿入されません。例えば、ビジュアル領域選択をする
もしブロックの矩形からはずれているような短かい行がブロックの範囲にあった場合
は、その行は何も影響を受けません。次のように最初と最後の行に"long"という文字
を含んだ行があって、２行目が短かい場合、２行目は選択されません。

	This is a long line ~
	short ~
	Any other long line ~

		  ^^^^ selected block

さて、ここで、"Ivery <Esc>"を入力すると、次の結果となります。

	This is a very long line ~
	short ~
	Any other very long line ~

短かい行には何も挿入されません。入力した行で改行をした場合は、"I"は通常モー
ドでの挿入コマンドのようにブロックの最初の行にだけ挿入されます。

"A"コマンドも同じように動きます。違いは、追加されるのがブロックの左側ではな
く右側である点です。
"A"にはひとつ、特別なケースがあります。ブロック選択のvisualモードで"$"を使っ
て各行の行末まで選択範囲を拡張した場合、"A"を使うと各行の行末に文字列を追加
します。
上と同じ例を使って、"$A XXX<Esc>"を入力すると、次のような結果となります。

	This is a long line XXX ~
	short XXX ~
	Any other long line XXX ~

これは実際に"$"コマンドを使う必要があります。vimはそれを使ったことを覚えてい
ます。カーソルを使って一番長い行の行末までカーソルを移動させ、見た目の範囲を
同じにしても、結果は違ってきます。


文字列の変更
------------

ビジュアルブロックでの"c"コマンドはブロックを削除し、挿入モードに入って文字
列を入力できるようにします。入力された文字列はブロックの各行に挿入されます。
上での例と同様に"long"を選択している時に、"c_LONG_<Esc>"を入力すると、次のよ
うになります。

	This is a _LONG_ line ~
	short ~
	Any other _LONG_ line ~

"I"コマンドの場合と同じく、短かい行は無視されます。また、新しい文字列には改
行は入力できません。

"C"コマンドの場合は、ブロックの左端から行末までを削除します。次に挿入モード
に入り、文字列を入力できるようになります。その文字列は各行の行末に追加され
ます。
また同じ例ですが、"Cnew text<Esc>"を入力すると次のようになります。

	This is a new text ~
	short ~
	Any other new text ~

注意すべきは、"long"という単語だけが選択されていても、これを実行すると、行末
まで全部消えてしまう点です。つまりビジュアルブロックの左端だけしか見ないとい
うことです。
繰り返しですが、ブロックに含まれないような短かい行はここでも無視されます。

その他にブロック内の文字列を変更するコマンドには次のようなものがあります。

	~	大文字/小文字切換え (a -> A and A -> a)
	U	大文字化する        (a -> A and A -> A)
	u	小文字化する        (a -> a and A -> a)


ひとつの文字で埋める
--------------------

ブロック全体を１つの文字で埋めるには"r"コマンドを使います。またまた、上で用
いた例ですが、"long"を選択した上で"rx"と入力します。

	This is a xxxx line ~
	short ~
	Any other xxxx line ~


	Note:
	ブロック内の行末以降の文字も含めたい場合には、２５章の'virtualedit'
	機能の説明をご覧ください。


左シフト、右シフト
------------------

">"コマンドは選択範囲を決まった桁数だけ右にシフトして空白で埋めます。シフト
の開始位置はビジュアルブロックの左端となります。
これまた同じ例ですが、">"を行うと次のようになります。

	This is a	  long line ~
	short ~
	Any other	  long line ~

このシフト桁数は'shiftwidth'オプションで指定します。これを４に変更するには次
のようにします。 >

	:set shiftwidth=4

"<"コマンドはブロックの左端にある空白類を決まった桁数だけ削除します。このコ
マンドはそこにある文字列の量によって制限を受けます。つまり、シフトできるだけ
の空白文字がない場合は、あるだけしか削除しません。


行の結合
--------

"J"コマンドは選択している全行を１行に連結します。つまり改行を削除します。
正確には、改行記号、行頭の空白類、行末の空白類、の３つをまとめて１つの空白
に置換します。(これは'joinspaces'オプションで変更できます)
さて、見慣れたいつもの例題を使ってみましょう。"J"の結果はこうなります。

	This is a long line short Any other long line ~

"J"コマンドはブロック選択のvisualモードでなくても使えます。"v"や"V"でのvisual
モードの場合も全く同じ結果となります。

空白文字類を変更したくないの場合は、"gJ"コマンドを使います。

==============================================================================
*10.6* ファイルの一部の保存や読み込み

Ｅメールを書く時に、他のファイルを取り込みたいことがあります。これは":read 
{filename}"コマンドで実行できます。そのファイルの内容はカーソルの下にプット
されます。次の文章でやってみましょう。

	Hi John, ~
	Here is the diff that fixes the bug: ~
	Bye, Pierre. ~

カーソルを２行目のに移動し、次のコマンドを入力します。 >

	:read patch

"patch"という名前のファイルが挿入されます。その結果は次の通りです。

	Hi John, ~
	Here is the diff that fixes the bug: ~
	2c2 ~
	<	for (i = 0; i <= length; ++i) ~
	--- ~
	>	for (i = 0; i < length; ++i) ~
	Bye, Pierre. ~

":read"コマンドには範囲を指定できます。ファイル内容はこの範囲の後の数字の行
の下にプットされます。例えば":$r patch"ならば、"patch"をファイルの最後に追加
します。
最初の行よりも上にファイルを読み込むにはどうすればいいのでしょう？これは行
番号として０を指定すればできます。そんな行は本当はありませんから、ほとんどの
コマンドではエラーメッセージが出ます。ですが、このコマンドでなら使えるのです。
>
	:0read patch

"patch"の内容はファイルの先頭にプットされます。


行範囲を指定しての保存
----------------------

行範囲を指定してファイルに保存するには、":write"コマンドを使います。
範囲指定をしなければファイル全体を保存します。範囲指定するとその範囲内の行だ
けを保存します。 >

	:.,$write tempo

上の例はカーソル位置の行から末尾までをファイル"tempo"に保存します。そのファ
イルが既に存在しているのであれば、エラーメッセージが出ます。vimは間違って既
存のファイルに上書きするのを防止してくれます。もし上書きしても大丈夫なことが
わかっているのなら、次のように"!"を付けます。 >

	:.,$write! tempo

注意：上の"!"は":write"の直後に(空白などを置かずに)指定しないといけません。
でないと、この章の後半で説明するフィルタコマンドになってしまいます。


ファイルに追記する
------------------

この章の最初の節で、レジスタａに複数の行内容を集める方法を説明しました。同じ
ように、ファイルでも行を集めることができます。次のコマンドで現在行だけを保存
してください。 >

	:.write collection

次にカーソルを２つ目に追記した行に移動し、次のように入力します。 >

	:.write >>collection

">>"はvimに"collection"に新規ファイルとして保存するのではなく、ファイルの末
尾に追記することを指示します。この指定は必要な回数分自由に繰り返すことができ
ます。

==============================================================================
*10.7*	文章の整形

プレインテキストを入力している時に、各行の長さを画面に合うように自動的に調整
してくれれば助かります。文章の入力中にそれをさせるには'textwidth'オプション
を設定します。 >

	:set textwidth=72

サンプルのvimrcファイルではどのファイルでもこのコマンドを使っていることを覚
えているかもしれません。つまり、vimrcファイルを使っていたのであれば、あなた
は既にこのコマンドを使っていたということです。次のコマンドで'textwidth'の現
在の値を確認してみましょう。 >

	:set textwidth

これで各行の長さは72文字までで分割されます。ただし、行の途中まで文章を挿入
している時や、単語を削除している時には行が長くなったり短かくなったりします。
vimは既存の文章を勝手に整形はしません。vimに現在の段落を整形させるには次の
ようにします。 >

	gqap

これは"gq"というオペレータで始まるコマンドです。次に"ap"というテキストオブ
ジェクトが続きます。これは「１段落(＝a paragraph)」という意味です。段落は、
空行に囲まれた領域のことを示します。

	Note:
	空行(改行文字だけの行)と空白行(空白文字だけの行)は違います。段落の
	区切りとなるのは「空行」だけです。見た目では気付きにくいので注意！

"ap"の代りに任意のモーションやテキストオブジェクトが使えます。段落が正しく
分割されていれば、次のコマンドでファイル全体を整形できます。 
>
	gggqG

"gg"は１行目にカーソルを動かします。"gqG"の先頭の２文字は文章整形のオペレー
タ、"G"はファイルの末尾へのジャンプをするモーションです。

段落を明確に定義していない場合は、対象となる行を選択して整形することができ
ます。カーソルを整形したい範囲の最初の行に移動し、"gqj"コマンドを使います。
これは現在行と次の行を整形します。もし最初の行が短かければ次の行の単語が追加
されます。逆に長ければ、次の行にあふれた単語を追いやります。処理後のカーソル
は、２行目に移動します。ここで"."を使うとこのコマンドを繰り返します。これを
フォーマット化したい範囲の最後まで続ければよいのです。

==============================================================================
*10.8*	大文字/小文字変換

"section header"という小文字の文字列があり、そのうち、"section"を大文字にし
たい場合、"gU"オペレータで行います。まずカーソルをその単語の先頭に置きます。
>
			     gUw
<	section header	    ---->      SECTION header

"gu"オペレータは全く逆に動きます。 >

			     guw
<	SECTION header	    ---->      section header

同様に"g~"は大文字/小文字の入れ換えをします。これらは全てオペレータ、つまり
モーションコマンドやテキストオブジェクトやvisualモードが使えます。
オペレータを行単位にするには２回指定します。例えば削除オペレータは"d"ですが、
１行を削除するのは"dd"です。同じように"gugu"は行全体を小文字にします。これを
さらに短縮して"guu"でも構いません。"gUgU"も"gUU"となりますし、"g~g~"は"g~~"
です。次のようになります。 >

				g~~
<	Some GIRLS have Fun    ---->   sOME girls HAVE fUN ~

==============================================================================
*10.9*	外部プログラムの利用

vimにはパワフルなコマンドセットがありますから何でもできます。でも外部のコマ
ンドを使った方が良い場合や速く処理できる場合もあります。
"!{motion}{program}"コマンドは文章のかたまりを与えて、外部コマンドにフィルタ
リングさせることができます。言い換えると{program}で指定されたシステムのコマ
ンドを実行し、それに{motion}で指定された範囲の文章を入力として与えます。その
コマンドの出力結果を受け取り、選択されていた範囲の文章と入れ換えます。
UNIXのフィルタに慣染んでいない方には、要領を得ない説明かと思いますので、例を
挙げて説明します。ソート(並べ換え)プログラムはファイルをソートします。次のよ
うなコマンドを実行すると、ソートされていないinput.txtというファイルの内容を
並べ換えてoutput.txtというファイルに保存します。(この例はUNIXでもMicrosoft
Windowsでも動きます) >

	sort <input.txt >output.txt

さて、ここで同じことをvimでやってみましょう。編集中のファイルの１～５行目を
ソートしたいとします。カーソルを１行目に動かしてから、次のコマンドを実行し
ます。 >

	!5G

"!"コマンドはvimにフィルタを実行させるための指示です。これはオペレータですの
で、次にモーションコマンドが必要です。これによってフィルタに渡す範囲を指定し
ます。"5G"は５行目までジャンプするモーションコマンドです。これで１～５行目が
フィルタの範囲であることがわかりました。
フィルタリングの場合、ここでカーソルが最下段に動き、画面の行頭には"!"と表示
されます。ここでフィルタコマンド名を入力します。この場合なら、"sort"ですね。
結局、このコマンドの全体は次のようになります。 >

	!5Gsort<Enter>

この結果はソートプログラムが最初の５行について動作します。元の５行はプログラ
ムの出力によって置き換えられます。

	line 55			      line 11
	line 33			      line 22
	line 11		-->	      line 33
	line 22			      line 44
	line 44			      line 55
	last line		      last line

"!!"コマンドは現在のカーソル行をフィルタにかけるコマンドです。UNIXでは"date"
コマンドは日付と時刻を表示します。"!!date<Enter>"は現在の行内容を"date"の出
力結果に置き換えます。これはファイルにタイムスタンプを追加するのに便利です。


うまく動かない場合
------------------

シェルを起動し、テキストを送りこみ、出力を取り込む、という処理を行うには、
vimはどのようにシェルが動くかを完全に把握していることが必要です。フィルタ
処理に問題がある場合は、以下のオプションの内容をチェックしてください。

	'shell'		vimが外部プログラムを実行するのに使うプログラムの指
			定
	'shellcmdflag'	シェルにコマンドを渡すための引数
	'shellquote'	コマンド名を囲むためのクオート文字
	'shellxquote'	コマンド名とリダイレクトを囲むための文字
	'shelltype'	シェルの種類(Amiga専用)
	'shellslash'	ファイル名のバックスラッシュをスラッシュにする
			(MS-Windows系専用)
	'shellredir'	コマンドの出力をファイルに保存するために指定する文字列

UNIXではこれはほとんど問題になりません。というのはシェルは２種類("sh"系と
"csh"系)に集約されるからです。vimは'shell'オプションをチェックし、関連オプ
ション値を自動的に設定します。その内容は'shell'のどこかに"csh"という文字があ
るかどうかで決めています。
しかし、MS-Windowsでは多種のシェルが存在するため、フィルタ処理がうまく動くよ
うにオプション値を調整してやる必要があります。より詳しい情報はヘルプでご覧
ください。


コマンドの出力を読む
--------------------

カレントディレクトリの内容を読み込むには、次のようにします。

Unix系: >
	:read !ls
MS-Windows系: >
	:read !dir

"ls"や"dir"コマンドの出力を取り込んで、カーソル以降に挿入します。これはファ
イルからの読み込みコマンドに似ていますが、"!"があることでコマンドが続くこと
を指定している点が違います。
コマンドには引数が指定できます。範囲も指定できます。どこに処理結果をプットす
るかを指定できます。 >

	:0read !date -u

これはファイルの先頭に現在の日付と時間をUTC形式で挿入します。("-u"引数が使え
るようなdateコマンドが必要ですよ。当たり前ですが...) なお、"!!date"は現在行
を入れ換えるのに対して、":read !date"は行を挿入するという点が違います。


コマンドにテキストを書き出す
----------------------------

UNIXの"wc"コマンドは単語数を返します。編集中のファイルの単語数をカウントする
には次のようにします。 >

	:write !wc

これは既に述べたwriteコマンドと似ています。ただ、ファイル名の代わりに"!"と外
部コマンド名が指定されています。ここで書き込んだ文字列は指定のコマンドの標準
入力として渡されます。出力は次のようになります。

       4      47     249 ~

"wc"コマンドは冗長なメッセージを出しません。上の例は行数が４、単語数が４７、
文字数が２４９であることを示しています。

次のような間違いに気をつけてください。 >

	:write! wc

これはカレントディレクトリの"wc"というファイルに強制的に上書きをするコマンド
です。writeの直後の空白は重要です！


画面の再描画
------------

外部コマンドがエラーメッセージを出した場合、画面がめちゃくちゃになってしまう
かもしれません。vimは自身が再描画が必要な場所を把握しているため、最低限必要
な領域だけを再描画します。しかし他のプログラムがどのようん描画をしたかまでは
把握できません。次のコマンドはvimに画面全体を再描画させます。 >

	CTRL-L

==============================================================================

Next chapter: |usr_11.txt|  クラッシュから立ち直る

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
