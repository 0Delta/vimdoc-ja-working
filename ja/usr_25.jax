COMMENT: 整形されたテキストの扱い(折返し、配置、インデント、表)
STATUS: finished 6.3.054
TRANSLATOR: 清水俊彦(しみず) <mailto:t_smz@syd.odn.ne.jp>

*usr_25.txt*	For Vim version 6.3.  Last change: 2003 Jun 21

                     VIM USER MANUAL - by Bram Moolenaar

                      フォーマット付きテキストを編集する


文章が１行１文になっていることなどほとんどありません。この章ではページなどの
書式に合うように文を分割する方法について述べます。
vimには１行の段落や表を編集する便利な機能もあります。

|25.1|  行を分割する
|25.2|  テキストを揃える
|25.3|  インデントとタブ
|25.4|  長い行の分割
|25.5|  表の編集

     Next chapter: |usr_26.txt|  繰り返し
 Previous chapter: |usr_24.txt|  挿入を素早く行う
Table of contents: |usr_toc.txt|

==============================================================================
*25.1*  行を分割する

vimには文章をより簡単に分割するための機能がたくさんあります。デフォルトでは、
自動的に改行することはありません。つまり、利用者が自分で<Enter>を押す必要が
あります。プログラムを作る時には、行末を自分で決められるこのやり方が使いやす
いでしょう。でも1行が最大70桁にしたい文書を作る時にはあまり良い方法ではあり
ません。
'textwidth'オプションを設定すると、vimが自動的に改行を挿入してくれます。例え
ば、１行30桁以内のとても巾の狭いコラムを書きたい場合を考えてみましょう。その
場合はこのようなコマンドを実行します。 >

        :set textwidth=30

で、普通に入力を行います。(上の数字は桁数です)

                 1         2         3
        12345678901234567890123456789012345
        I taught programming for a whi ~

ここで、次に"l"を入力すると、１行が30桁の制限を越えますので、vimはこれに気付
いて、改行を挿入します。その結果、このようになります。

                 1         2         3
        12345678901234567890123456789012345
        I taught programming for a ~
        whil ~

さて、続けましょう。同様に残りのパラグラフを入力します。

                 1         2         3
        12345678901234567890123456789012345
        I taught programming for a ~
        while. One time, I was stopped ~
        by the Fort Worth police, ~
        because my homework was too ~
        hard. True story. ~

自分で改行を入力する必要はありんせん。vimが自動的にそれを置いてくれます。

        Note:
        'wrap'オプションだと、行を改行して表示してくれます。でもこれはファイ
        ルに改行文字を挿入するわけではありません。


再桁揃え
--------

vimはワープロではありません。ワープロならば、段落の最初で何か削除すると、改
行位置を再設定してくれます。vimはそうではありません。ですから、最初の行で
"programming"を削除するとその行だけが短かくなってしまいます。

                 1         2         3
        12345678901234567890123456789012345
        I taught for a ~
        while. One time, I was stopped ~
        by the Fort Worth police, ~
        because my homework was too ~
        hard. True story. ~

これではうまくありません。パラグラフの形を整えるには"gq"オペレータを使いま
す。
まず、ビジュアルモードでこれを行ってみましょう。最初の行で次のように入力しま
す。 >

        v4jgq

"v"はビジュアルモードの開始、"4j"でパラグラフの最後までを範囲とし、"gq"オペ
レータを実行します。この実行結果はこうなります。

                 1         2         3
        12345678901234567890123456789012345
        I taught for a while. One ~
        time, I was stopped by the ~
        Fort Worth police, because my ~
        homework was too hard. True ~
        story. ~

Note: 自動的にフォーマットすることもできます。|auto-format|を見てください。

"gq"はオペレータですので、適用対象の範囲を選ぶのに３つの方法が使えます。
ビジュアルモード、カーソルモーション、テキストオブジェクトの３つです。
上の例なら"gq4j"でも同じことができます。これだと打鍵数は少ないですが、行数が
わかっていないといけません。"}"という便利なモーションコマンドがあります。こ
のコマンドは段落の最後までカーソルを移動します。
"gq"でとても便利に使えるテキストオブジェクトがあります。これをやってみてくだ
さい。 >

        gqap

"ap"はテキストオブジェクトで"a paragraph"の意味です。これは(空行で区切られた)
１つの段落のフォーマットを整えます。
段落を空行で区切ってあれば、こうすれば、ファイル全体のフォーマットを整えるこ
とができます。 >

        gggqG

"gg"はファイルの１行目に移動し、"gqG"は最後の行までのフォーマットを整えます。
Warning: 段落がちゃんと区切られていないと、１つにつながってしまいます。よく
あるのは、空白やTABのみの行を作ってしまう場合です。これは空白行ですが、空行
ではありません。

vimはプレインテキストを越えたフォーマット設定ができます。この変更のやり方は
|fo-table|をご覧ください。全停止した後ろの空白の数を変える方法については、
'joinspaces'オプションの説明をご覧ください。
フォーマットを整えるのに外部コマンドを使うのも可能です。vimの組み込みコマン
ドでは正しくフォーマットが整えられない場合に便利です。'formatprg'オプション
をご覧ください。

==============================================================================
*25.2*  文章の右寄せ、左寄せ

ある範囲の行をセンタリングするには、このコマンドを使います。 >

        :{range}center [width]

{range}は通常はコマンド行で指定した範囲です。[width] はオプションパラメタで
センタリングする行の桁数を指定できます。[width]が指定されていない場合は、デ
フォルト値として'textwidth'の値を用います。(もし'textwidth'が０なら、80とみな
します。例えば、次のように使います。 >

        :1,5center 40

この結果はこうなります。

       I taught for a while. One ~
       time, I was stopped by the ~
     Fort Worth police, because my ~
      homework was too hard. True ~
                 story. ~


右寄せ
------

同じように右寄せするには":right"コマンドを使います。 >

        :1,5right 37

結果はこの通り。

            I taught for a while. One ~
           time, I was stopped by the ~
        Fort Worth police, because my ~
          homework was too hard. True ~
                               story. ~

左寄せ
------

最後はこのコマンドです。

        :{range}left [margin]

":center"や":right"と違うのは、":left"で指定するパラメタが行の長さではないと
いう点です。ここでの値は左マージンとなります。省略した場合は、文章は画面の左
端に寄せることになります（つまりマージン値が０の時と同じです）これが５の場合
は、文章は左端から５桁分のインデントが付きます。例えば、このようなコマンドを
実行してみます。 >

        :1left 5
        :2,5left

この結果はこのようになります。

             I taught for a while. One ~
        time, I was stopped by the ~
        Fort Worth police, because my ~
        homework was too hard. True ~
        story. ~


文章の両方揃え
--------------

vimにはテキストを両揃えにする機能は組み込まれていません。とはいっても、それを
行ってくれる素晴らしいマクロパッケージがあります。このパッケージを使うには、
次のコマンドを実行します。 >

        :runtime macros/justify.vim

このvimスクリプトファイルでは新たなビジュアルコマンド"_j"を定義しています。
このコマンドでブロックを指定するには、まずビジュアルモードで範囲を選択して
"_j"コマンドを実行します。
より詳しい説明についてはファイルの内容をご覧ください。これは次の行で"gf"コ
マンドでジャンプしてください。

もう一つは外部プログラムてフィルタを通す方法です。こんな具合です。 >

        :%!fmt

==============================================================================
*25.3*  インデント(段付け)とタブ

文章を他の部分より目立たせるのにインデントを使えます。例えば、このマニュアル
では例題の部分を空白８つか<Tab>でインデントしています。普通に各行で<Tab>キーを押
して、入力しても構いません。次の文章を使いましょう。

        the first line ~
        the second line ~

上の例は<Tab>を押してから文章を入力し、<Enter>、また<Tab>を押して文章を入力
しています。'autoindent'オプションを使うと、自動的にインデントを補ってくれま
す。 >

        :set autoindent

新しい行を入力しようとすると、その直前の行と同じ桁数のインデントを行います。
上の例なら、<Enter>を押した後の<Tab>は入力する必要がありません。


インデントを増やす
------------------

ある行のインデント量を増やすには">"オペレータを使います。よく使うのは">>"で
す。これは現在行のインデントを増やします。
このコマンドで増えるインデント量は'shiftwidth'オプションで指定できます。この
デフォルト値は８です。">>"で増やすインデント量を例えば、空白４つにするには、
このようにします。 >

        :set shiftwidth=4

上で示した例題の２行目で">>"を使うと、このような結果となります。

        the first line ~
            the second line ~

なお、"4>>"は現在行から４行分のインデント量を増やす命令です。


TABSTOP
-------

インデントを４桁毎にインデントを設定したい場合には'shiftwidth'を４に設定しま
す。しかしこれだと<Tab>を押した時には８桁のインデントのままです。これを変更
するには、'softtabstop'オプションを設定します。 >

        :set softtabstop=4

これは<Tab>キーを押すとインデント巾として空白を４つ挿入します。既に空白が４
つある場合には、<Tab>文字に置き換えます。(ファイル上で７つ分の空白文示の領域
を節約できます）
なお、常に空白文字を使い<Tab>文字を使わせたくない場合は'expandtab'オプション
を使います。

        Note:
	'tabstop'オプションは４に設定できます。でも、他の時に'tabstop'の値を
	デフォルト(=8)のままで再編集すると、正しく表示されないでしょう。また
	他のアプリケーションで編集する時やプリンタに印刷する時もうまくいかな
	いでしょう。ですから'tabstop'の値は常にデフォルトの８のままにしておく
	のが良いでしょう。８というのはどこに行っても通じる値ですから。


TABを変更する
-------------

TABが３であることを前提に書かれたファイルを編集すると、vimでは見苦しく表示さ
れます。普通はTABが８だからです。'tabstop'を３に設定すれば、表示は直ります。
ですがこのファイルを編集する都度、この設定を行わなければなりません。vimでは
そのファイルのTABの数を変更できます。最初に'tabstop'を正しく見えるように設定
し、次に":retab"コマンドを使います。 >

        :set tabstop=3
        :retab 8

":retab"コマンドは'tabstop'を８に変更し、それでも表示が同じになるように文章
を変更します。これは連続する空白を<Tab>と空白記号に置き換えます。 その後で
ファイルの書き込みを行えば、以降はオプション設定を行わなくても正しくインデン
トされた状態で編集ができます。
Warning: プログラムソースに対して":retab"を使うと、文字列定数の中にある空白
記号が変更されてしまうかもしれません。ですから、文字列中では<TAB>を使わず、
"\t"を使うようにした方が良いでしょう。

==============================================================================
*25.4*  長い行の分割

ウィンドウの横巾よりも長い行があるようなファイルを編集する場合には、その内容
が画面に納まるように、長い行を途中で折り曲げて表示します。
'wrap'オプションをoffにすると、ファイル中の各行は画面上でも１行に表示されま
す。ですから長い行の行末は画面のずっと右側にあって表示されなくなります。
カーソルを表示されていない部分に動かそうとすると、vimはその部分を表示できる
ように画面をスクロールします。言ってみれば、文章を見る覗き窓が水平方向に移動
するイメージです。
デフォルトでは、GUI版のvimでは水平スクロールバーは表示しません。もし使いたけ
れば、このコマンドを使います。 >

        :set guioptions+=b

vimウィンドウの下に水平スクロールバーが表示されます。

もしスクロールバーがなかったり、使いたくない場合は、次に示すようなコマンドを
使って文章をスクロールします。カーソルは同じ場所のままですが、必要に応じて文
字のある場所に動くことはあります。

        zh              右にスクロール
        4zh             右に４文字分スクロール
        zH              右にウィンドウ巾の半分だけスクロール
        ze              カーソルが右端に来るように右スクロール
        zl              左にスクロール
        4zl             左に４文字分スクロール
        zL              左にウィンドウ巾の半分だけスクロール
        zs              カーソルが左端に来るように左スクロール

１行の文章を使ってこれを試してみましょう。最初にカーソルは"which"の"w"の場所
にあります。上にある"current window"は現在見えている範囲を示しています。その
下にある"window"の行は左に書いてあるコマンドを実行した後に見える範囲を示して
います。

                              |<-- current window -->|
                some long text, part of which is visible in the window ~
        ze        |<--     window     -->|
        zH         |<--     window     -->|
        4zh               |<--     window     -->|
        zh                   |<--     window     -->|
        zl                     |<--     window     -->|
        4zl                       |<--     window     -->|
        zL                              |<--     window     -->|
        zs                             |<--     window     -->|


ラップしない場合の移動
----------------------

'wrap'オプションがoffで水平スクロールされた状態の場合、画面に見えている範囲
でカーソルを動かすコマンドを次に示します。つまり、画面の左右にあるはずの文は
無視します。言い換れば、以下のコマンド群はスクロールをしないということです。

        g0              その行の右端の文字まで移動
        g^              その行の右端(ただし空白文字類を除く)の文字まで移動
        gm              その行の中央に移動
        g$              その行の左端に見えている文字まで移動

                |<--     window    -->|
        some long    text, part of which is visible ~
                 g0  g^    gm        g$


単語の分割					*edit-no-break*
----------

他のアプリケーションで使えるようにするため、１つの段落が改行されないようにし
なければならないかもしれません。'wrap'をoffにした場合にはこのような行の全体
を見通すことができないという欠点があります。'wrap'をonにすると各単語の途中で
も行分割してしまいますから、読みづらくなってしまいます。
この種の段落を編集する時は、'linebreak'オプションを設定しておくのが良いでしょ
う。これを使うと行を表示する時に適切な箇所で改行をします。'linebreak'がoffの
状態ではこのような表示となります。

        +---------------------------------+
        |letter generation program for a b|
        |ank.  They wanted to send out a s|
        |pecial, personalized letter to th|
        |eir richest 1000 customers.  Unfo|
        |rtunately for the programmer, he |
        +---------------------------------+
>
        :set linebreak

上の設定を行った後は、このようになります。

        +---------------------------------+
        |letter generation program for a  |
        |bank.  They wanted to send out a |
        |special, personalized letter to  |
        |their richest 1000 customers.    |
        |Unfortunately for the programmer,|
        +---------------------------------+

これ以外にも、次のような関連オプションがあります。
	'breakat'	改行を挿入しても良い文字を指定します。
	'showbreak'	行分割した行の先頭に表示する文字を指定します。
	'textwidth'	これを０に設定すると段落を分割しなくなります。



分割された行内の移動
--------------------

"j"と"k"コマンドはカーソルを前後の行に移動します。つまり'wrap'がonの時に長い
行があると、１つの"j"や"k"で何行もの行を一度に動いてしまいます。
画面上での１行だけカーソルを動かしたい時には"gj"と"gk"コマンドを使います。
行分割されていない行では"j"や"k"と同じ動きとなります。行が分割されている時は
画面上で１つ下か上の行に移動します。
この移動コマンドを矢印キーに割り当てたい場合には、このようなマップ定義を行う
ことができます。 >

        :map <Up> gk
        :map <Down> gj


１つの段落を１行にまとめる
--------------------------

MS-Wordのようなプログラムに文章を送り込もうとすると、各段落は１行に繋いでお
くべきでしょう。段落を空白行で区切ってある文章なら、次のようにすれば、各段落
を１つの行に変換できます。 >

	:g/./,/^$/join

なんだか複雑そうですね。ではこれを分解してみましょう。

	:g/./		何でもよいから１文字以上の文字を含む行を探す":global"
			コマンド
	     ,/^$/	上で見つけた行(空行でない行)から空白行までの範囲を示
	     		す。
		  join	上で定めた範囲に対してそれを１行に繋ぐ":join"コマンド

次のような８つの改行があるような文章があるとします。

	+----------------------------------+
	|A letter generation program	   |
	|for a bank.  They wanted to	   |
	|send out a special,		   |
	|personalized letter.		   |
	|				   |
	|To their richest 1000		   |
	|customers.  Unfortunately for	   |
	|the programmer,		   |
	+----------------------------------+

これが次の２行にまとまります。
You end up with two lines:

	+----------------------------------+
	|A letter generation program for a |
	|bank.	They wanted to send out a s|
	|pecial, personalized letter.	   |
	|To their richest 1000 customers.  |
	|Unfortunately for the programmer, |
	+----------------------------------+

この指定は段落と段落の間に空白やTABを含むような空白行で区切ってあるとうまく
動きません。次のコマンドはそういった空白行でもうまく動きます。
>
	:g/\S/,/^\s*$/join

これでも、最後の段落を１行にまとめるのであれば、最後の行は空行か空白行でなけ
ればなりません。

==============================================================================
*25.5*  表の編集

次のような４つのカラムがあるような表を編集したいとしましょう。

        nice table        test 1        test 2      test 3 ~
        input A           0.534 ~
        input B           0.913 ~

３つ目のカラムには数値を入力する必要があるとします。２行目にカーソルを動かし
て"A"コマンドで空白を入力してからその数値を入力するのもやり方です。
ですがこの種の編集をするための特殊オプションを用意しています。 >

        set virtualedit=all

すると、実際に文字がない場所にもカーソルを動かすことができるようになります。
これを「バーチャルスペース(空白)」と呼びます。これを使うと表の編集がすごく楽
になります。
まずカーソルを最後のカラムに動かすために、ヘッダ部を使って検索を行います。 >

        /test 3

次に"j"を押すと、"input A"の値を入力できる場所に動きますので、"0.693"と入力
します。するとこのような表示となります。

        nice table        test 1     test 2      test 3 ~
        input A           0.534                  0.693 ~
        input B           0.913 ~

vimは自動的に元の行末と入力した数値とのスキマを空白で埋めます。次に"Bj"コマ
ンドで次の行のカラムに移動します。"B"は空白類で区切られた単語の先頭に移動す
るコマンドです。続く"j"は次の行の値を入力すべき場所に移動します。

        Note:
	表示されているどの場所にでもカーソルは移動できます。最終行の後ろでも
	移動できます。ただし、その場所で何か文字を入力しない限り、空白文字の
	挿入は行われません。


カラムのコピー
--------------

上の表の３つ目のカラムを、"test 1"カラムの前に追加(挿入)するには、次のように
７つの手順でできます。

 1. カーソルをこのカラムの左上隅に移動します。例えば、"/test 3"を使います。
 2. CTRL-Vを押してブロック選択のビジュアルモードを開始します。
 3. "2j"でカーソルを２行下に移動します。この場所は"input B"の"test 3"カラム
    ですので「バーチャルスペース」になります。
 4. カーソルを右に移動しカラム全体が選択されるようにし、さらにカラム間の空白
    分を選択します。例えば"9l"とすれば良いでしょう。
 5. 選択範囲を"y"コマンドでヤンクします。
 6. カーソルを"test 1"の場所、つまり新しいカラムを挿入したい場所に動かします。
 7. "P"を押してプットします。

この結果は次のようになります。

        nice table        test 3    test 1     test 2      test 3 ~
        input A           0.693     0.534                  0.693 ~
        input B                     0.913 ~

"test 1"カラム全体が右側に押し出されます。挿入したカラムで空白しかない部分も
同じように右側に動いている点に注目してください。

さて、これで元のカーソル移動モードに戻しましょう。 >

        :set virtualedit=


バーチャル置換モード
--------------------

上の'virtualedit'モードの欠点は「違った感じ」がすることです。最終行より後に
カーソルを動かしても、空白やTABがあるかどうか判断できません。もう一つの方法
があります。それが今から述べる「バーチャル置換モード」です。
表の中にTABとそれ以外の文字が混在している行があるとします。その最初のTAB位置
で、"rx"を実行するとこのようにレイアウトが崩れてしまいます。

        inp     0.693   0.534   0.693 ~

               |
           rx  |
               V

        inpx0.693   0.534       0.693 ~

こうならないようにするには"gr"コマンドを使います。

        inp     0.693   0.534   0.693 ~

               |
          grx  |
               V

        inpx    0.693   0.534   0.693 ~

このように"gr"コマンドは文字の置換によって画面レイアウトが変わらないようにし
てくれます。間を埋めるのに必要なTABや空白を自動的に補います。つまり実際には
元のTABは"x"に置き換えた上でレイアウトが崩れないように空白類を追加しているの
です。この場合ならTAB記号を挿入しています。
２文字以上の置き換えを行いたい場合は、"R"コマンドで置換モード(|04.9|節をご覧
ください)に入ります。これもレイアウトを崩したり意図しない置き換えを行ってし
まいます。

        inp     0       0.534   0.693 ~

                |
         R0.786 |
                V

        inp     0.78634 0.693 ~

このような場合は"gR"コマンドで「バーチャル置換モード」に入ります。これだとレ
イアウトを崩さないようにできます。

        inp     0       0.534   0.693 ~

                |
        gR0.786 |
                V

        inp     0.786   0.534   0.693 ~

==============================================================================

Next chapter: |usr_26.txt|  繰り返し

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
