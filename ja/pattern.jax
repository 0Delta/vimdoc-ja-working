COMMENT: 正規表現
STATUS: finished 5.6
TRANSLATOR: 北条耀

*pattern.txt*	For Vim version 5.6.  Last change: 1999 Oct 27


		  VIM REFERENCE MANUAL	  by Bram Moolenaar


パターンと検索コマンド					*pattern-searches*

1. 検索コマンド			|search-commands|
2. パターンの定義		|search-pattern|

==============================================================================
1. 検索コマンド						*search-commands*

							*/*
/{pattern}[/]<CR>	[count] 番目にマッチする {pattern} を前方に検索します。
			(排他的)

/{pattern}/{offset}<CR> [count] 番目にマッチする {pattern} を前方に検索し
			|{offset}| 行の分上/下に移動します。(行指向)

							*/<CR>*
/<CR>			[count]番目に、最後に検索したパターン|last-pattern|にマ
			ッチするものを最後に使われた|{offset}|を使って前方に検
			索します。

//{offset}<CR>		[count]番目に、最後に検索したパターン|last-pattern|にマ
			ッチするものを新しい|{offset}|を使って前方に検索します。
			{offset}が空であればオフセットは使われません。

							*?*
?{pattern}[?]<CR>	[count] 番目にマッチする {pattern} を後方に検索します。
			(排他的)

?{pattern}?{offset}<CR> [count] 番目にマッチする {pattern} を後方に検索して
			|{offset}| 行の分上/下に移動します。(行指向)

							*?<CR>*
?<CR>			[count]番目に、最後に検索したパターン|last-pattern|に
			マッチするものを最後に使われた|{offset}|を使って後方に
			検索します。

??{offset}<CR>		[count]番目に、最後に検索したパターン|last-pattern|に
			マッチするものを新しい|{offset}|を使って後方に検索しま
			す。{offset}が空であればオフセットは使われません。


							*n*
n			最後の "/" か "?" を [count] 回繰り返します。
			|last-pattern| {Vi: カウントの前置を受け付けません}

							*N*
N			最後の "/" か "?" を逆方向に [count] 回繰り返します。
			|last-pattern| {Vi: カウントの前置を受け付けません}

							*star*
*			[count] 番目にマッチする現在のカーソル位置にもっとも近
			い単語を前方に検索します。検索に使われる単語は、まず:
				1. カーソルの下のキーワード |'iskeyword'|
				2. 現在の行のカーソルの前方のキーワード
				3. カーソルの下の空白でない単語
				4. 現在の行のカーソルの前方の空白でない単語
			"/\<keyword\>" コマンドで検索するように完全なキーワード
			のみが検索できます。(排他的)  {Vi にはない機能です}

							*#*
#			"*" と同じですが、後方に検索します。ポンド記号(163 の文
			字)でも動作します。"#" キーがバックスペースとして動作し
			ている場合は Vim を起動する前に "stty erase <BS>" とし
			てみてください(<BS> は CTRL-H もしくは本当のバックスペ
			ースです)。  {Vi にはない機能です}

							*gstar*
g*			"*" と似ていますが "\<" と "\>" を単語の回りに加えませ
			ん。つまり単語の一部にマッチするものを検索することもで
			きます。  {Vi にはない機能です}

							*g#*
g#			"#" と似ていますが "\<" と "\>" を単語の回りに加えませ
			ん。つまり単語の一部にマッチするものを検索することもで
			きます。  {Vi にはない機能です}

							*gd*
gd			ローカル宣言の場所に移動します。カーソルがローカル変数
			の上にあればこのコマンドはその宣言にジャンプします。は
			じめに Vim は現在の関数の最初を("[[" コマンドのように)
			検索し、もし見つからなければ1行目で検索を中止します。見
			つかった場合は空行がある場所まで戻り、そこからカーソル
			の下のキーワードを "*" コマンドのように検索します。しか
			しこの場合コメントのように思われる行は無視されます
			( 'comments' オプションも参照してください)。
			しかし Vim は文法を実際にチェックしているわけではなく、
			キーワードにマッチするものを検索しているだけですので、
			これがうまく動作することは保証されないということに注意
			してください。インクルードされるファイルも検索したい場
			合は |include-search| でリストされているコマンドを使っ
			てください。 {Vi にはない機能です}

							*gD*
gD			グローバル宣言の場所に移動します。カーソルがそのファイ
			ルで定義されているグローバル変数の上にあればこのコマン
			ドはその宣言に移動します。"gd" と同じように動作しますが
			キーワードの検索が常に1行目から始められるところが違いま
			す。  {Vi にはない機能です}

							*CTRL-C*
CTRL-C			現在の(検索)コマンドを中止します。MS-DOSではCTRL-Break
			を使ってください |dos-CTRL-Break|。
			ノーマルモードではすべてのやりかけのコマンドが中止され
			ます。

							*:noh* *:nohlsearch*
:noh[lsearch]		'hlsearch' オプションで指定されたハイライトをやめさせま
			す。検索コマンドを使うか 'hlsearch' オプションをオンに
			するかすれば自動的に再びオンになります。
			このコマンドは、ハイライト状態が自動コマンドの実行時に
			セーブ、リストアされるため、自動コマンド内では無効です。
			|autocmd-searchpat|

'incsearch' オプションがセットされていると検索パターンを入力している間に現在マ
ッチするものが示されます。表示されているマッチした場所にカーソルを実際に移動さ
せるには <CR> を打って検索を終了させる必要があるということを覚えておいてくださ
い。また検索を中止するには <Esc> キーを使ってください。

もし 'hlsearch' オプションをセットしていれば最後に使った検索パターンはハイライ
トされていることになります。これを中断させたければ |:nohlsearch| コマンドを使っ
てください。

					*search-offset* *{offset}*
これらのコマンドは指定されたパターンを検索するのですが、"/" と "?" ではさらに
オフセットを与えて検索することができます。2つのタイプのオフセットがあります: 
行オフセットと文字オフセットです。  {Vi: 文字オフセットははありません}

オフセットはマッチした場所から相対的にカーソルの場所を移動させます:
    [num]	[num] 行下の一桁目に
    +[num]	[num] 行下の一桁目に
    -[num]	[num] 行上の一桁目に
    e[+num]	[num] 文字右にマッチ部分の終わりの場所から移動
    e[-num]	[num] 文字左にマッチ部分の終わりの場所から移動
    s[+num]	[num] 文字右にマッチ部分の初めの場所(start)から移動
    s[-num]	[num] 文字左にマッチ部分の初めの場所(start)から移動
    b[+num]	[num] 文字右にマッチ部分の初めの場所(begin)から移動
    b[-num]	[num] 文字左にマッチ部分の初めの場所(begin)から移動

'-' か '+' は与えられていて [num] が与えられていなければ、カウント1とみなされ
ます。オフセットに 'e' を含めている場合は、検索は包括的になります(カーソルが移
動するであろう位置の文字まで操作の対象になります)。

例:

pattern			cursor position ~
/test/+1		"test" の1行下の1桁目
/test/e			"test" の最後
/test/s+2		"test" の 's' 文字
/test/b-3		"test" の3文字前

もしこれらのコマンドが演算コマンドの後ろで用いられた場合、検索の前と後のカーソ
ル位置の間の文字が操作の対象となります。ただし、行オフセットが指定されている場
合は2つのカーソルの位置の間の行全体が操作の対象となります。

							*//;*
非常に特殊なオフセットとして ';' があり、これは検索コマンドに続けます。例えば:

>  /test 1/;/test
>  /test.*/+1;?ing?

最初のものは、初めに次に現れる "test 1" を見つけ、それからその後に最初に現れる
"test" を見つけます。

これは2つの検索コマンドをそれぞれの後に実行するようなものですが、次のところが
違います:
- 演算コマンドの後に1つの移動コマンドのように使うことができます。
- 続く "n" もしくは "N" コマンドの方向は最初の検索コマンドの方向になります。
- エラーが起きた場合カーソルはまったく動きません。

							*last-pattern*
最後に使われたパターンとオフセットは記憶されておかれ、これらはあるいは方向を変
えたり別のカウントを前置して検索を繰り返す場合に使うことができます。2つのパター
ンが記憶されておかれるということに注意してください: 1つは 'normal' 検索コマン
ドでもう1つは置換コマンド ":s" です。それぞれの場合で空のパターンが与えられた
場合、前に使われたパターンが使われます。

'magic'オプションは最後に使われたパターンを変更しません。'magic'を変更しても、
最後に使われたパターンの解釈は変わりません。
'ignorecase'オプションはそうではありません。'ignorecase'が変更されれば、最後
のパターンは違うテキストにマッチすることになります。

'hlsearch' オプションをセットしている場合、最後に使われた検索パターンにマッチ
するものすべてがハイライトされます。

Vi ではタグが検索される場合は ":tag" コマンドは最後に検索されたパターンをセッ
トします。Vim ではこれは行われません、'cpoptions' に 't' フラグが付いていない
限り前の検索パターンが忘れられることはありません。検索パターンは常に検索履歴に
追加されます。

'wrapscan' オプションがオン(デフォルトの値はこれです)の場合、検索はバッファー
の最後から初めに戻って行われます。'wrapscan' オプションがセットされていない場
合後方検索はバッファーの最初でストップし、前方検索はバッファーの最後でストップ
します。'wrapscan' がセットされていてパターンが見つからなかった場合、"pattern
not found" というメッセージがでて、カーソルは動きません。'wrapscan' がセットさ
れていない場合、前方に検索している場合はメッセージは"search hit BOTTOM without
match" となり、後方に検索している場合は "search hit TOP without match" というメ
ッセージが出ます。'wrapscan' がセットされている場合、検索がファイルの最後/最初
から最初/最後に戻ったときには "search hit TOP, continuing at BOTTOM" もしくは
"search hit BOTTOM, continuing at TOP" というメッセージがそれぞれ後方検索/前方
検索している場合に表示されます。このメッセージは 's' フラグを 'shortmess' オプ
ションにつけることで消すことができます。ハイライト方法の 'w' がこのメッセージ
に使われます(デフォルト： 標準出力)。

							*search-range*
"/" では行の中のある範囲を指定して検索することはできません。とにかくこれを行い
たい場合は ":substitute" コマンドに 'c' フラグをつける方法があります。例:
>  :.,300s/Pattern//gc
このコマンドはカーソルの位置と300行目までの間で "Pattern" を検索します。マッチ
した場所でなんらかの文字を押すように促されます。やめさせるには 'q' とタイプし、
次にマッチするものを見つけるには 'n' をタイプします。

"*", "#", "g*", "g#" コマンドはカーソルに近い単語を次の順番で検索します。最初
に検索に使われるものは:
- カーソルの下のキーワード
- 同じ行のカーソルの右側のキーワード
- カーソルの下の(空白で区切られる)単語
- 同じ行のカーソルの右側の(空白で区切られる)単語
キーワードは 'iskeyword' で定義されている文字のみを含みます。
(空白で区切られる)単語は空白文字(<Tab> と <Space>)以外で構成されます。
もし10本の指を使ってタイプを行っているなら、この文字は覚えやすいということも覚
えておいてください:
"#" はあなたの左手の中指で押します(左上に検索します)。そして
"*" はあなたの右手の中指で押します(右下に検索します)。

==============================================================================
2. パターンの定義			*search-pattern* *pattern* *[pattern]*
					*regular-expression* *regexp* *Pattern*

パターンには特殊な文字を含めることができます。そしてこれは 'magic' オプションの
設定で変えることができます。'magic'には常にデフォルトの設定を使うことを推奨しま
す。これは移植上の問題を回避します。

							*/bar* */\bar*
1. パターンは "\|" で分けられた1つもしくは複数のブランチからなります。このパタ
   ーンはブランチのうちのどれかにマッチするものにはすべてマッチします。例: 
   "foo\|beep" は "foo" と "beep" にマッチします。もし複数のブランチがマッチす
   れば初めにマッチしたものが使われます。

2. ブランチは1つもしくは複数のピースの結合からなります。ブランチは初めにマッチ
   するピースとそれに続く2番目にマッチするピースそれに続く...にマッチします。
   例: "foo[0-9]beep" は初めに "foo" にマッチし、それから数字それから "beep" と
   いう風にマッチします。

3. ピースはアトム(それ以上分割できないもの)であり、次のものを続けることができま
   す:
     'magic' 'nomagic'	~
							*/star* */\star*
	*	\*	前にあるアトムの0回以上の繰り返しに可能な限り多くの回数
			マッチします (最大 32767)
							*/\+*
	\+	\+	前にあるアトムの1回以上の繰り返しに可能な限り多くの回数
			マッチします (最大 32767) {Vi にはない機能です}
							*/\=*
	\=	\=	前にあるアトムの0回もしくは1回に可能な限り多くの回数マ
			ッチします {Vi にはない機能です}
							*/\{*
	\{n,m}	\{n,m}	前にあるアトムのn回からm回までの繰り返しに可能な限り多
			くの回数マッチします {Vi にはない機能です}
	\{n}	\{n}	前にあるアトムのn回の繰り返しにマッチします 
			{Vi にはない機能です}
	\{n,}	\{n,}	前にあるアトムのn回以上の繰り返しに可能な限り多くの回数
			マッチします {Vi にはない機能です}
	\{,m}	\{,m}	前にあるアトムの0回からm回までの繰り返しに可能な限り多
			くの回数マッチします {Vi にはない機能です}
	\{}	\{}	前にあるアトムの0回以上の繰り返しに可能な限り多くの回数
			マッチします(* と同じです)  {Vi にはない機能です}
							*/\{-*
	\{-n,m}  \{-n,m} 前にあるアトムのn回からm回までの繰り返しに可能な限り少
			 ない回数マッチします  {Vi にはない機能です}
	\{-n}	 \{-n}	前にあるアトムのn回の繰り返しにマッチします
			{Vi にはない機能です}
	\{-n,}	 \{-n,} 前にあるアトムのn回以上の繰り返しに可能な限り少ない回数
			マッチします  {Vi にはない機能です}
	\{-,m}	 \{-,m} 前にあるアトムの0回からm回までの繰り返しに可能な限り少
			ない回数マッチします {Vi にはない機能です}
	\{-}	 \{-}	前にあるアトムの0回以上の繰り返しに可能な限り少ない回数
			マッチします  {Vi にはない機能です}

		(n と m は1から32767までの間の10進数です)

		"{" の後にすぐに "-" が現れている場合、もっとも短いものにマッチ
		する高速なアルゴリズムが使われます(下の例をご覧下さい)。特に 
		"\{-}" は "*" と同じですが一番短いものにマッチする高速なアルゴ
		リズムが使われます。しかし: 早くマッチしたものは短いマッチより
		優先されます: "a\{-}b" は "xaaab" の "aaab" にマッチすることに
		なります。

    例:
       .*	.\*	空の文字列も含めてすべてにマッチします
       ^.\+$	^.\+$	空行以外の行にマッチします
       foo\=	foo\=	"fo" と "foo" にマッチします
       ab\{2,3}c	"abbc" か "abbbc" にマッチします
       a\{5}		"aaaaa" にマッチします
       ab\{2,}c		"abbc", "abbbc", abbbbc", ... にマッチします
       ab\{,3}c		"ac", "abc", "abbc", "abbbc" にマッチします
       a[bc]\{3}d	"abbbd","abbcd","acbcd","acccd"などなどにマッチします
       a\(bc\)\{1,2}d	"abcd" か "abcbcd" にマッチします
       a[bc]\{-}[cd]	"abcd" の中の "abc" にマッチします
       a[bc]*[cd]	"abcd" の中の "abcd" にマッチします。


4. アトムは次のものです:
      magic   nomagic	~
	^	^	パターンの最初、もしくは "\|" の後、もしくは	*/^*
			"\(" の後で行の最初にマッチします; ほかの場所
			では文字どおりの '^' にマッチします。
	\^	\^	どの場所でも文字どおりの '^' にマッチします	*/\^*
	^	^	パターンの最初に置かれて行の最初にマッチします	*/^*
	$	$	パターンの最後、もしくは "\|" の前、もしくは	*/$*
			"\)" の前に置かれて<EOL>にマッチします; それ
			以外の場所では文字どおりの '$' にマッチします
	\$	\$	どの場所でも文字どおりの '$' にマッチします	*/\$*
	.	\.	任意の一文字にマッチします		  */.* */\.*
	\<	\<	単語の最初にマッチします			*/\<*
	\>	\>	単語の最後にマッチします			*/\>*

	文字クラス {Vi にはない機能です}:
	\i	\i	識別子文字 (参照: 'isident'オプション)		*/\i*
	\I	\I	"\i" と似ていますが数字を除きます		*/\I*
	\k	\k	キーワード文字(参照: 'iskeyword' オプション)	*/\k*
	\K	\K	"\k" と似ていますが数字を除きます		*/\K*
	\f	\f	ファイル名の文字(参照: 'isfname' オプション)	*/\f*
	\F	\F	"\f" と似ていますが数字を除きます		*/\F*
	\p	\p	印字可能な文字(参照: 'isprint' オプション)	*/\p*
	\P	\P	"\p" と似ていますが数字を除きます		*/\P*

						*whitespace* *white-space*
	\s	\s	ホワイトスペース文字: <Space> と <Tab>		*/\s*
	\S	\S	ホワイトスペース以外の文字; \s の反対です	*/\S*
	\d	\d	数字:				[0-9]		*/\d*
	\D	\D	数字以外の文字:			[^0-9]		*/\D*
	\x	\x	16進数:				[0-9A-Fa-f]	*/\x*
	\X	\X	16進数でない文字:		[^0-9A-Fa-f]	*/\X*
	\o	\o	8進数:				[0-7]		*/\o*
	\O	\O	8進数でない文字:		[^0-7]		*/\O*
	\w	\w	単語を構成する文字:		[0-9A-Za-z_]	*/\w*
	\W	\W	単語を構成する文字以外の文字:	[^0-9A-Za-z_]	*/\W*
	\h	\h	単語の先頭の文字:		[A-Za-z_]	*/\h*
	\H	\H	単語の先頭の文字以外の文字:	[^A-Za-z_]	*/\H*
	\a	\a	アルファベット文字:		[A-Za-z]	*/\a*
	\A	\A	アルファベット以外の文字:	[^A-Za-z]	*/\A*
	\l	\l	小文字:				[a-z]		*/\l*
	\L	\L	小文字以外の文字:		[^a-z]		*/\L*
	\u	\u	大文字:				[A-Z]		*/\u*
	\U	\U	大文字以外の文字:		[^A-Z]		*/\U*
			注: アトムを使った方が [] 形式を使うより高速です
			注: 'ignorecase' は文字クラスでは使われません
	(文字クラス終わり)

	\e	\e	<Esc> にマッチします				*/\e*
	\t	\t	<Tab> にマッチします				*/\t*
	\r	\r	<CR> にマッチします				*/\r*
	\b	\b	<BS> にマッチします				*/\b*
	\n	\n	<NL> にマッチします(まだ使えません) 複数の行に	*/\n*
			わたってパターンを指定するのに使われるでしょう
	~	\~	最後に行われた置換文字列にマッチします	    */~* */\~*
	\(\)	\(\)	エスケープされた括弧で囲まれたパターンです     */\(\)*
			(例: "\(^a\)") はそのパターンにマッチします      */\)*
	\1	\1	はじめの \( と \) で囲まれた副表現にマッチする	 */\1*
			文字列にマッチします {Vi にはない機能です}
			例: "\([a-z]\).\1" は "ata", "ehe", "tot", などにマッ
			チします
	\2	\2	"\1" に似ていますが2番目の副表現を使います	 */\2*
	   ...
	\9	\9	"\1" に似ていますが9番目の副表現を使います	*/\9*

	x	x	1つの文字です。特殊な意味は持ちません。それ自身にマッチ
			します
	\x	\x	バックスラッシュの後に1つの文字を続けます   */\* */\\*
			特殊な意味は持ちません。将来の拡張のためにとっておかれ
			ています。

	[]	\[]	範囲です。これは "[]" もしくは "\[]" で囲まれた */[]*
			一連の文字で、その中に含まれる任意の1文字にマッ */\[]*
			チします。例えば: "[xyz]" は 'x', 'y', 'z' のどれかにマ
			ッチします。
			- 文字列が "^" で始まっていると文字列に含まれない任意の
			  1文字にマッチします: "[^xyz]" は 'x', 'y', 'z' 以外の
			  すべてにマッチします。
			- 文字列の中で2つの文字が '-' で分割されていると、その
			  間の ASCII 文字すべてのリストの略記になります。例:
			  "[0-9]" は任意の10進数にマッチします。
			- 文字クラス表現はその文字クラスが属する文字セットに評
			  価されます。次の文字クラスがサポートされています:
			  Name		Contents ~
*[:alnum:]*		  [:alnum:]	アルファベットとアラビア数字
*[:alpha:]*		  [:alpha:]	アルファベット
*[:blank:]*		  [:blank:]	スペースとタブ文字
*[:cntrl:]*		  [:cntrl:]	制御文字
*[:digit:]*		  [:digit:]	10進数
*[:graph:]*		  [:graph:]	スペースを除いた印字可能な文字
*[:lower:]*		  [:lower:]	アルファベットの小文字
*[:print:]*		  [:print:]	スペースを含めた印字可能な文字
*[:punct:]*		  [:punct:]	句読点文字
*[:space:]*		  [:space:]	ホワイトスペース文字
*[:upper:]*		  [:upper:]	アルファベットの大文字
*[:xdigit:]*		  [:xdigit:]	16進数
*[:return:]*		  [:return:]	<CR> 文字
*[:tab:]*		  [:tab:]	<Tab> 文字
*[:escape:]*		  [:escape:]	<Esc> 文字
*[:backspace:]*		  [:backspace:]	<BS> 文字
			  文字クラス表現の括弧は範囲指定の括弧に加えてつけなけ
			  ればなりません。例を挙げると、次のものはもっともらし
			  い UNIX のファイル名の表現です: [-./[:alnum:]_~]\+
			  つまり、'-', '.', '/',アルファベット,数字, '_', '~'
			  が少なくとも1回以上使われている文字列です。*/\]*
			- ']', '^', '-', '\' をそのまま文字列に含めるにはバック
			  スラッシュを前においてください: "[xyz\]]","[\^xyz]",
			  "[xy\-z]","[xyz\\]"。(注:POSIXではこの方式のバックス
			  ラッシュをサポートしていません)
			  ']' に関しては括弧の最初に置くこともできます(後ろの例
			  で示すように "^" でも可能です): "[]xyz]" か "[^]xyz]"
			  {Vi にはない機能です}
			  '-' に関しては最初もしくは最後に置くことができます:
			  "[-xyz]", "[^-xyz]", "[xyz-]"
			  '\' に関しては "^]-etrb" 以外の文字を後に続けることも
			  できます。"[\xyz]" は '\',　'x', 'y', 'z' にマッチし
			  ます。しかしながら "\\" を使った方がよいです。なぜな
			  ら将来の拡張で他の文字が '\' の後に使われるかもしれま
			  せんから。
			- 'cpoptions' に 'l' が含まれていなければ次のものも解釈
			  されます {Vi にはない機能です}
				\e	<Esc>
				\t	<Tab>
				\r	<CR>
				\b	<BS>
			- 範囲マッチングは遅くなりえます。可能ならば上記のアイ
			  テムを使ってください。

'ignorecase'オプションがオンであれば、大文字小文字の違いは無視されます。
'smartcase'がセットされると、パターンが大文字のみなら、大文字小文字の違いを無視
します。

パターンに改行を含めることはできません(ごめんなさい!)。

例:
^beep(			たぶん C の関数の "beep" の初め

[a-zA-Z]$		行末の任意のアルファベット文字

\<\I\i*		もしくは
\<\h\w*
\<[a-zA-Z_][a-zA-Z0-9_]*
			識別子 (例えば C プログラムの中で)

\(\.$\|\. \)		<EOL> かスペースが後に続くピリオド
			"\(. \|\.$\)" は同じものを意味しないということに注意し
			てください。なぜなら '\)' の前の '$' は <EOL> ではない
			からです。これは Vi コンパチブルのためにそのままにして
			あります。

[.!?][])"']*\($\|[ ]\)	文の最後を検索するパターンです。")" コマンドの定義とほ
			とんど同じです。

技術的な説明:					*NL-used-for-Nul*
ファイルの中の <Nul> 文字は <NL> としてメモリーに保持され、ディスプレイでは
"^@" と表示されます。この変換はファイルを読み込む時と書き込む時に行われます。
検索パターンで <Nul> にマッチさせるには CTRL-@ もしくは "CTRL-V 000" と打ち込
むだけでよいです。そしてこれがおそらくあなたが期待するものでしょう。内部ではそ
の文字は検索パターンの中で <NL> に置き換えられます。ちょっと普通ではないところ
があって CTRL-V CTRL-J とタイプすることでも <NL> を挿入します。ですので、ファ
イル中の <Nul> も検索してしまいます。
{Vi はファイル中の <Nul> 文字をまったく扱えません}

						*CR-used-for-NL*
'fileformat' オプションに "mac" がセットされているとファイル中の <NL> 文字は
<CR> として保持されます。そしてディスプレイでは "^M" として表示されます。それ
以外はこれは <NL> の <Nul> に対する使い方と似た動作をします。

 vim:tw=78:ts=8:ft=help:norl:
