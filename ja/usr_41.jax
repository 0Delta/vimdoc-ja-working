COMMENT: Vimスクリプト書法
STATUS: finished 6.3.054
TRANSLATOR: 清水俊彦(しみず) <mailto:t_smz@syd.odn.ne.jp>
TRANSLATOR: nakadaira <hopper2@nanameue.jp>

*usr_41.txt*	For Vim version 6.3.  Last change: 2004 May 06

		     VIM USER MANUAL - by Bram Moolenaar

			      vimスクリプトの作り方


vimスクリプト言語は、起動時のvimrcファイル、シンタックスファイル、などなどで
使われています。本章では、vimスクリプトで使える命令などについて説明します。
説明することが大量にありますので、この章は長い目になっています。

|41.1|	はじめに
|41.2|	変数
|41.3|	式
|41.4|	条件
|41.5|	式の実行
|41.6|	関数を使う
|41.7|	関数を定義する
|41.8|	例外
|41.9|	いろんな注釈
|41.10|	プラグインを書く
|41.11|	ファイルタイププラグインを書く
|41.12|	コンパイラプラグインを書く

     Next chapter: |usr_42.txt|  新たなメニューを作る
 Previous chapter: |usr_40.txt|  新たなコマンドを作る
Table of contents: |usr_toc.txt|

==============================================================================
*41.1*	はじめに					*vim-script-intro*

一番最初に見るvimスクリプトはvimrc ファイルでしょう。vimは起動する時にこの
ファイルを読み込み、書いてあるコマンドを実行します。あなたの好みに合せて、
オプションの値を変えることができます。この中では":"コマンド（先頭が":"で
始まるようなコマンド。Exコマンドとかコマンドラインコマンドと呼ぶ時もあり
ます。）
シンタックスファイルもvimスクリプトです。これは特定のファイルタイプ用にオプ
ションを設定するためのファイルです。複雑なマクロを複数のvimスクリプトファイ
ルに分けて定義したりもできます。他にもいろんな使い方を考案できるでしょう。

まず、簡単な例から始めましょう。 >

	:let i = 1
	:while i < 5
	:  echo "count is" i
	:  let i = i + 1
	:endwhile
<
	Note:
	本当はここでは":"はいりません。vim内でコマンドを入力する場合にだけ
	必要です。vimスクリプトファイルでは、取り除いても構いません。
	ここでは、これらが":"コマンドであり、通常コマンドとは違っていること
	をハッキリさせるために使っています。

":let"コマンドは変数に値を代入します。一般的な書式は次の通りです。 >

	:let {variable} = {expression}

この場合、変数名が"i"で、式が数字の１という単純な値です。
":while"コマンドはループの開始を示します。一般的な書式は次のとおりです。 >

	:while {condition}
	:  {statements}
	:endwhile

呼応する":endwhile"までの間にある命令はwhileの条件({condition})が True であ 
る間、繰り返して実行します。ここでの条件は"i < 5"という式です。これは変数 i
が５よりも小さい間は True となります。
":echo"コマンドはパラメタの内容を表示します。ここでは"count is"という文字列
と変数 i の内容となります。i が１であれば、このような結果となります。

	count is 1 ~

ここにはさらに":let i ="というコマンドがあります。ここで使われる値は"i + 1"
という式です。結局、変数 i の内容に１を加え、その値を同じ変数の新たな値とし
て代入します。
この例の実行結果は次のようになります。

	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~

	Note:
	もし、whileループの中で動きっぱなしになってしまったら、CTRL-Cを
	(MS-WindowsではCTRL-Break)を押して強制割込してください。


３種類の数字
-----------

数字には10進数、16進数、8進数のいずれかを指定できます。16進数は先頭が"0x"か
"0X"で始まります。例えば"0x1f"は31のことです。8進数は先頭が"0"で始まります。
例えば、"017"は15です。10進数のつもりで先頭に"0"を付けないように注意してくだ
さい。8進数として扱われてしまいます。
":echo"コマンドは常に10進数で出力を行います。このようになります。 >

	:echo 0x7f 036
<	127 30 ~

数値にはマイナス記号を付けると負数となります。負数は8進数や16進数でも使えま
す。マイナス記号は減算でも使います。この例を上の例と較べてください。 >

	:echo 0x7f -036
<	97 ~

式の途中にある空白は無視します。とはいっても項目のセパレータに空白を使うと、
式の可読性を高めることになりますのでお勧めします。例えば、負数であるかのよう
な誤解を防ぐために、マイナス記号に続く数値の前には空白を置きましょう。 >

	:echo 0x7f - 036

==============================================================================
*41.2*	変数

変数名にはアルファベット、数字、アンダースコア(_)が使えます。ただし先頭に数
字は使えません。正しい変数名は例えば次のとおりです。

	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH

逆に間違った名前は次の通りです。
	foo+var		"+"は変数名に使えません。
	6var		先頭に数字は使えません。

これらはグローバル変数です。定義されている変数名の一覧を見るのはこのコマンド
です。 >

	:let

グローバル変数はどこでも使えます。あるスクリプトファイルで"count"という変数
を使っていれば、他のスクリプトでもその変数が使えるということです。これは少な
くとも混乱を招きますし、実際に問題が発生すれば最悪です。これを避けるために変
数がスクリプト内にローカルであるというマーク"s:"を付けることができます。
例えば、あるスクリプトに次のようなコードがあるとします。 >

	:let s:count = 1
	:while s:count < 5
	:  source other.vim
	:  let s:count = s:count + 1
	:endwhile

"s:count"はスクリプト内にローカルですから、"other.vim"というスクリプトからは
この変数の内容を変更できません。もし"other.vim"も"s:count"変数を使っていたと
しても、それは"other.vim"の中でローカルな別の変数です。スクリプトローカルな
変数の詳細については|script-variable|をご覧ください。

変数には他にも多くの種類があります。|internal-variables|をご覧ください。中で
もよく使うものを掲げておきます。

	b:name		バッファローカルな変数
	w:name		ウィンドウローカルな変数
	g:name		グローバル変数(関数内でも利用可能)
	v:name		vimが事前に宣言している変数


変数の削除
----------

変数はメモリを占有していますので、":let"コマンドの出力にも現れます。変数を削
除するには":unlet"コマンドを使います。例えば、 >

	:unlet s:count

これはスクリプトローカルな変数"s:count"を削除して、占有していたメモリを開放
します。変数が存在しているかどうかわからないけれど、なくてもエラーにはしたく
ない場合には次のように ! を追記します。 >

	:unlet! s:count

スクリプトが終了すると使われなくなったローカル変数は自動的に削除されません。
次にそのスクリプトを実行した時には、前回の終了時の値を使えます。例えば次の
とおりです。 >

	:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"

"exists()"関数は変数が既に定義されているかどうかをチェックします。パラメタに
は調べたい変数の名前を指定します。変数自身じゃありません。変数自身を調べるに
はこのようにします。 >

	:if !exists(s:call_count)

これで、s:callcountの内容がexists()関数でチェックすべき変数名となります。
ビックリマーク(exclamation mark)は値を反転します。変数がTrueの場合はFalseと
なり、Falseの場合はTrueになります。これを"not"と呼いんでも構いません。つまり
"if !exists()"は"if not exists()"とも読めるということです。
vimでは、０以外の値は全てTrueです。


文字列変数と定数
----------------

ここまでは、変数の値には数値だけを使ってきました。値には文字列も使えます。vim
で扱える型は数値と文字列の２種類だけです。 型は":let"コマンドで変数に値を代
入する度に動的に変化します。
変数に文字列値を代入するには文字列定数を使います。文字列定数には２つのタイプ
があります。１つ目はダブルクオート(")で囲った文字列です。 >

	:let name = "peter"
	:echo name
<	peter ~

文字列の中でダブルクオートを使いたければ、その直前にバックスラッシュを付け
ます。 >

	:let name = "\"peter\""
	:echo name
<	"peter" ~

文字列をシングルクオート(')で囲めば、バックスラッシュを省くことができます。 >

	:let name = '"peter"'
	:echo name
<	"peter" ~

シングルクオートで囲った場合、全ての文字は見た目の通りの意味となります。この
ため、中にシングルクオートを含むことはできません。バックスラッシュも見た目の
通りに扱われるため、次の文字の特殊な意味を打ち消すといった働きをしません。
ダブルクオートで囲った文字列には特殊な意味の文字が使えます。以下に便利なもの
を掲げておきます。

	\t		<Tab>
	\n		<NL>, line break
	\r		<CR>, <Enter>
	\e		<Esc>
	\b		<BS>, backspace
	\"		"
	\\		\, backslash
	\<Esc>		<Esc>
	\<C-W>		CTRL-W

最後の２つは単なる例です。"\<name>"形式で(nameで指定した)特殊キーを含むとい
う意味になります。
文字列で使える特殊な表現についての詳細は|expr-quote|をご覧ください。

==============================================================================
*41.3*	式(expression)

vimには豊富ながらもシンプルな方法で式の処理を行えます。厳密な定義については
|expression-syntax|をご覧ください。ここではごく基本的な機能にしぼって説明し
ます。
既に述べたような、数値や文字列や変数はそれ自体が１つの式です。つまり式を書け
る場所であれば、数値でも文字列でも変数でも使えるということです。それ以外にも
式にはこのような基本アイテムがあります。

	$NAME		環境変数
	&name		オプション
	@r		レジスタ

例を挙げましょう。 >

	:echo "The value of 'tabstop' is" &ts
	:echo "Your home directory is" $HOME
	:if @a > 5

"&name"形式はオプション値を保存したり、別の値に設定したり、古い値に戻したり、
といったことに使えます。 >

	:let save_ic = &ic
	:set noic
	:/The Start/,$delete
	:let &ic = save_ic

'ignorecase'オプションをoffにすることで、"The Start"パターンの検索を明示的に
大文字と小文字を分別させています。また、保存しておいた値を後で戻しています。


演算
----

上で述べたような基本的なアイテムを組み合せるとより興味深くなります。数値演算
を始めましょう。

	a + b		加算
	a - b		減算
	a * b		乗算
	a / b		除算
	a % b		剰余演算(余りを得る)

演算子の優先順位は普通の計算の場合と同じです。例を挙げましょう。 >

	:echo 10 + 5 * 2
<	20 ~

カッコを使って優先順位を上げることもできます。別に普通のことですね。 >

	:echo (10 + 5) * 2
<	30 ~

文字列は"."演算子を使って連結できます。 >

	:echo "foo" . "bar"
<	foobar ~

":echo"コマンドに複数の文字列を与えると、空白文字1つでそれらを接続します。例で
はパラメタは１つの式になっていますから、そのような空白文字は挿入されていませ
ん。

C言語からは条件演算子を借りました。 >

	a ? b : c

"a"の結果がTrueであれば、"b"となり、そうでなければ、"c"となります。 >

	:let i = 4
	:echo i > 5 ? "i is big" : "i is small"
<	i is small ~

３つの部分は事前に評価(evaluate)されますので、このように動くと考えることも
できます。

	(a) ? (b) : (c)

==============================================================================
*41.4*	条件文 

":if"コマンドは条件が成立した場合に限り、以降のステートメントを":endif"が見
つかるまで実行します。記述形式はこのようになります。

	:if {condition}
	   {statements}
	:endif

{condition}で与えられた式を評価してTrue(０以外)であれば、{statements}の内容
を実行します。{condition}も{statements}も正しく記述したコマンドでなければな
りません。ここにゴミがあると、vimは":endif"をうまく見つけられなくなります。
条件文では":else"も使えます。その場合の記述形式はこのようになります。

	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif

２つ目の{statements}は最初の条件を満たさない場合にだけ実行されます。
最後に":elseif"があります。

	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif

これは":else"＋"if"と全く同様に動きます。でもこれを使うと余分な":endif"を使
わなくて済みます。
vimrcファイルで便利に使えるサンプルを例にしましょう。これは'term'オプション
の内容によって、それぞれに依存する何かを行うためのスクリプトです。 >

	:if &term == "xterm"
	:  " Do stuff for xterm
	:elseif &term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif


論理演算子
----------

既に述べた例の中でも論理演算子を使っています。最もよく使うものを示します。

	a == b		等しい
	a != b		等しくない
	a >  b		より大きい
	a >= b		より大きいか等しい
	a <  b		より小さい
	a <= b		より小さいか等しい

この結果は条件に合致していれば１、そうでなければ０となります。例を示しま
しょう。 >

	:if v:version >= 600
	:  echo "congratulations"
	:else
	:  echo "you are using an old version, upgrade!"
	:endif

"v:version"というのはvimが定義している変数で、これにはvimのバージョン値が入
ります。version6.0は600となります。version6.1なら601です。
これはvimの複数のバージョンで動作するスクリプトを書く時に重宝します。
|v:version|もどうぞ。

論理演算子は数値でも文字列でも使えます。２つの文字列を比較する時、数値差を使
います。この数値にはバイト値を比べますが、一部の言語では必ずしも正しい結果と
ならない場合があります。
文字列と数値を比較する時は、文字列をまず数値に変換します。ちょっとトリッキー
なんですが、文字列が数字列でない時は、その値が０とみなされます。例をあげま
しょう。 >

	:if 0 == "one"
	:  echo "yes"
	:endif

これは"yes"と表示されます。というのは"one"というのは数字列ではありませんから
その変換結果が０となるためです。

文字列にはさらに２つの論理演算子があります。

	a =~ b		パターンと合致する
	a !~ b		パターンと合致しない

左辺の"a"は文字列として扱い、右辺の"b"は何か検索したいパターンとして扱います。
次に例を示します。 >

	:if str =~ " "
	:  echo "str contains a space"
	:endif
	:if str !~ '\.$'
	:  echo "str dows not end in a full stop"
	:endif

パターンにシングルクオートで囲った文字列を使っているのがポイントです。これな
らバックスラッシュをそのまま使えるので便利です。これをダブルクオートで囲むと
バックスラッシュを２重に書く必要があるのでバックスラッシュだらけになってしま
います。

'ignorecase'オプションは文字列の比較でも影響を与えます。影響を避けるには、
大文字小文字を区別する時は"#"、しない時は"?"を演算子につけます。つまり"==?"
とすれば、２つの文字列を大文字小文字を無視して同じ文字列かを返し、"!~#"なら
大文字小文字を区別した上でパターンに合致するかどうかをチェックします。論理演
算子の全リストは|expr-==|をご覧ください。


他のループコマンド
------------------

":while"コマンドについては既に述べましたが、":while"と":endwhile"の中で使え
るステートメントがまだ２つあります。

	:continue		ループの先頭に戻る。ループは脱けない。
	:break			":endwhile"まで進み、ループを脱ける。

例： >

	:while counter < 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile

":sleep"コマンドを使うと一定時間、何もしないようにできます。"50m"という指定
なら、50ミリ秒となります。また":sleep 4"であれば、４秒スリープします。

==============================================================================
*41.5*	式を実行する

ここまではスクリプトのコマンドを直接実行するものばかりでした。":execute"コマ
ンドを使うと、式の評価結果をコマンドとして実行することができます。これは動的
にコマンドを生成して実行させることのできる極めて強力な手法です。
次の例は変数に格納した文字列をタグ名とみなしてタグジャンプするコマンドです。 >

	:execute "tag " . tag_name

"."は文字列"tag "と変数"tag_name"の＊内容＊を連結します。変数"tag_name"には
"get_cmd"という値が入っていたとすると、実際にはこのようなコマンドを実行する
ことになります。 >

	:tag get_cmd

":execute"コマンドはコマンド行のコマンド(コロンコマンド)のみ実行できます。
":normal"コマンドを使うと、通常コマンドを実行できます。ただし、このコマンド
のパラメタは式ではなく、コマンド文字の集合として扱います。例を示します。 >

	:normal gg=G

このコマンドは最初の行にジャンプして"="オペレータを使って全行のフォーマット
を整えます。
":normal"のパラメタとして式を指定したい場合は、":execute"コマンドを組み合せ
ます。例をあげます。 >

	:execute "normal " . normal_commands

"normal_commands"という変数には通常モード用のコマンドが入ってなければなりま
せん。
また、":normal"には完全なコマンドをパラメタとして与えます。そうでないと、vim
はパラメタ数の最後まで走ってから中断してしまいます。例えば、挿入モードを使う
のであればかならずその挿入モードを終了しなくてはなりません。この例はちゃんと
動きます。 
>
	:execute "normal Inew text \<Esc>"

これは"new text "という文字列を現在行に追加します。末尾の"\<Esc>"をご覧くだ
さい。これはスクリプトの中での本当の<Esc>記号が入力されるのを避けるのに必要
です。

==============================================================================
*41.6*	関数の利用

vimは多くの関数を定義しています。また膨大な数の機能をその方法で提供していま
す。この節ではいくつかの例を使って説明を行います。機能の全リストについては
|functions|をご覧ください。

関数の呼び出しは":call"コマンドで行います。パラメタは"("と")"の中に","で区切
って指定します。このようになります。 >

	:call search("Date: ", "W")

上の例では search() 関数を"Date:"と"W"をパラメタとして呼び出しています。
search()関数は最初のパラメタが検索パターンで、２つ目がフラグ指定となります。
"W"フラグはファイルの末尾に達した時に１行目に戻らない(ラップしない)という意
味です。

関数は式の中で使うこともできます。例を示します。 >

	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)

getline() 関数は現在のファイルから１行を抽出する関数です。パラメタには行番号を
指定します。この場合は"."ですが、これは現在カーソルのある行を示します。
substitute()関数は":substitute"コマンドとほぼ同じです。最初のパラメタは置き換
えを実行する文字列で、２つ目のパラメタはパターン、３つ目は置き換える文字列、最
後のパラメタはフラグです。
setline() 関数は１つ目のパラメタでの指定行を、２つ目のパラメタの文字列に設定し
ます。この例ではカーソル位置の行をsubstitute()の結果と置き換えます。ですから、
この３つのステートメントの実行結果はこれと同じです。 >

	:substitute/\a/*/g

関数の利用はsubtitute()呼び出しの前後でより多く動かすようになると、がぜん面白
くなります。


関数							*function-list*

関数には多くの種類があります。ここで使われ方によって分類して説明します。アル
ファベット順のリストは|functions|にあります。関数名の上でCTRL-]を押せば詳細な
説明がご覧いただけます。

文字列繰作:
	char2nr()		文字のASCII値を得る。
	nr2char()		ASCII値から文字を得る
	escape()		'\'で始まるように文字をクオートする
	strtrans()		文字列を印刷可能な状態とする。
	tolower()		文字列を小文字にする
	toupper()		文字列を大文字にする
	match()			文字列の中でパターンが一致する桁位置を返す
	matchend()		文字列の中でパターンと一致する末尾の桁位置を
				返す
	matchstr()		文字列の中で一致したパターンを返す
	stridx()		長い文字列の中にある短かい文字列の最初の位置
	strridx()		長い文字列の中にある短かい文字列の最後の位置
	strlen()		文字列の長さ
	substitute()		パターンに合致する文字列を他のものに入れ換
	submatch()		":substitute"の中で合致した部分を得る
	strpart()		文字列の一部分を得る
	expand()		特定のキーワードを拡張する
	type()			変数のタイプを得る
	iconv()			テキストのエンコーディングを変換する

現在のバッファ内のテキストの繰作
	byte2line()		指定のバイト位置の行番号を得る
	line2byte()		指定の行のバイト位置を得る
	col()			カーソル位置かマーク位置の桁位置を得る
	virtcol()		カーソル位置かマーク位置の画面上の桁位置を得る
	line()			カーソル位置かマーク位置の行番号を得る
	wincol()		カーソルのウィンドウカラム番号
	winline()		カーソル位置の画面上での行数
	cursor()		カーソルを指定した位置に移動させる
	getline()		バッファから行を得る
	setline()		バッファの行を入れ換える
	append()		{lnum}で指定した行の下に{string}を追加する
	indent()		指定の行をインデントする
	cindent()		Ｃ言語のルールに基いてインデントを行う
	lispindent()		Lisp 言語のルールに基いてインデントを行う
	nextnonblank()		次の空行を探す。
	prevnonblank()		逆方向に空行を探す
	search()		パターンに合致する場所を探す
	searchpair()		start/skip/endの呼応しているものを探す

システム関数とファイル繰作
	browse()		指定のファイルを見る
	glob()			ワイルドカードを拡張する
	globpath()		指定のディレクトリのワイルドカードを全部拡張
	resolve()		ショートカットがどこを示しているか探す
	fnamemodify()		ファイル名を変更する。
	executable()		実行形式ファイルかどうかをチェックする
	filereadable()		ファイルが読み込み可能かどうかをチェックする
	filewritable()		ファイルが書き込み可能かどうかをチェックする
	isdirectory()		ディレクトリがあるかどうかをチェックする
	getcwd()		現在のカレントディレクトリを得る
	getfsize()		ファイルのサイズを得る
	getftime()		ファイルの最終更新日時を得る
	localtime()		現在時刻を得る
	strftime()		時刻を文字列に変換する
	tempname()		テンポラリファイルの名前を得る。 
	delete()		ファイルを削除する
	rename()		ファイル名を変える
	system()		シェルコマンドを実行し、その結果を知る
	hostname()		システムの名称を得る

バッファ、ウィンドウ、パラメタリストの繰作
	argc()			パラメタリストの項目数
	argidx()		パラメタリスト中の現在の位置
	argv()			パラメタリストから１つを得る
	bufexists()		バッファがあるかどうかをチェックする
	buflisted()		バッファがあって、リストに入っていることを
				チェックする
	bufloaded()		バッファがあって、ロードされていることを
				チェックする
	bufname()		指定バッファの名前を得る
	bufnr()			指定バッファのバッファ番号を得る
	winnr()			現在バッファのウィンドウ番号を得る
	bufwinnr()		現在バッファのウィンドウ番号を得る
	winbufnr()		指定ウィンドウのバッファ番号を得る
	getbufvar()		指定バッファの変数値を得る
	setbufvar()		指定バッファに変数を設定する
	getwinvar()		指定ウィンドウの変数値を得る
	setwinvar()		指定ウィンドウに変数を設定する

フォールド(折り畳み処理)
	foldclosed()		指定の行に閉じたフォールドがあるかチェック
	foldclosedend()		foldclosed()に似ている。最後の行番号を返す
	foldlevel()		指定の行のフォールドレベルをチェック
	foldtext()		閉じたフォールドの表示行を生成

シンタックスハイライト
	hlexists()		ハイライトグループがあるかチェック
	hlID()			ハイライトグループのＩＤを得る
	synID()			指定の場所のシンタックスＩＤを得る
	synIDattr()		シンタックスＩＤの指定の属性を得る
	synIDtrans()		変換したシンタックスＩＤを得る

履歴
	histadd()		履歴に項目を追加
	histdel()		履歴から項目を削除
	histget()		履歴の項目を得る
	histnr()		履歴の最大番号を得る

会話処理
	confirm()		利用者に選択をさせる
	getchar()		利用者の入力した文字を得る
	getcharmod()		最後に入力した識別子(modifier)を得る
	input()			利用者の入力した行を得る
	inputsecret()		利用者の入力した行を得る。ただし表示はしない
	inputdialog()		ダイアログを使って利用者の入力した行を得る
	inputsave()		先行した入力を保存して状態をクリアする
	inputrestore()		inputsave()で保存した状態に戻す

vimサーバ
	serverlist()		サーバ名のリストを返す
	remote_send()		vimサーバにコマンド文字を送る
	remote_expr()		vimサーバで式を評価する
	server2client()		vimサーバのクライアントに返信を送付する
	remote_peek()		vimサーバから返信があったかどうかをチェック
	remote_read()		vimサーバからの返信を読み込む
	foreground()		vimのウィンドウを前面に持ってくる
	remote_foreground()	vimサーバのウィンドウを前面に持ってくる

その他
	mode()			現在の編集モードを得る
	visualmode()		最後にビジュアルモードを使った時の情報
	hasmapto()		マップがあるかどうかをチェック
	mapcheck()		合致するマップがあるかどうかをチェック
	maparg()		マップのrhsを得る
	exists()		変数、関数などがあるかどうかチェック
	has()			vimが機能をサポートしているかをチェック
	cscope_connection()	cscope接続があるかどうかをチェック
	did_filetype()		FileType自動コマンドを使っているかをチェック
	eventhandler()		イベントハンドラによって起動されたかをチェック
	getwinposx()		GUI版vimウィンドウのX座標
	getwinposy()		GUI版vimウィンドウのY座標
	winheight()		指定ウィンドウの高さを得る
	winwidth()		指定ウィンドウの横巾を得る
	libcall()		外部ライブラリの関数を呼ぶ
	libcallnr()		同上、ただし、復帰値を見る
	getreg()		レジスタの値を得る
	getregtype()		レジスタのタイプを得る
	setreg()		レジスタの値を設定する

==============================================================================
*41.7*	関数の定義

vimでは自作の関数を定義することができます。基本的な関数定義は次のような構造
となります。 >

	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
<
	Note:
	関数名は１文字目が必ず大文字にしなければなりません。

ここで２つの数値のうち小さい方を返す関数を作ってみましょう。関数は次のような
行で始まります。 >

	:function Min(num1, num2)

ここで、関数名が"Min"であること。パラメタは２つで、それぞれ"num1"、"num2"と
いう名前であることがわかります。
最初に行うのはどちらが小さいかをチェックすることです。
   >
	:  if a:num1 < a:num2

"a:"は特殊なプレフィクスで、この変数が関数のパラメタであることを示します。
さて、ここで小さい方の値を変数"smaller"に代入しましょう。 >

	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif

変数"smaller"はローカル変数です。関数内で使っている変数は、その関数内でロー
カルです。但し"g:"や"a:"や":s"といったプレフィクスを関数の前につけた場合は例
外です。

	Note:
	関数内からグローバル変数にアクセスするには、"g:"を変数名の前に付け
	る必要があります。つまり、関数内では"g:count"はグローバル変数"count"
	のことです。しかし"count"というのは関数内にローカルな別の変数です。

ここで呼び出し元に最少値を返すために":return"ステートメントを使います。そし
て、関数を終了します。 >

	:  return smaller
	:endfunction

この関数を通して記述すると次のようになります。 >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction

ユーザ定義関数は組み込み関数の場合と全く同じ方法で呼び出します。違いは名前だ
けです。上で定義した"Min"関数の場合なら次のように使います。 >

	:echo Min(5, 8)

今だけは（？？）、vimは関数の各行を解釈し、関数が実行されます。
未定義の変数や関数を使うといった間違いがあれば、エラーメッセージを表示しま
す。関数を定義している時はエラーは検出されません。

関数が、パラメタなしの":endfunction"や":return"に辿り着くと、復帰値は０にな
ります。

既存の関数を定義し直すには":function"コマンドに"!"を付けます。 >

	:function!  Min(num1, num2, num3)



範囲の利用
----------

":call"コマンドには行範囲を渡すことができます。これには2つの方法のうちどちらか
を適用します。1つは、関数を定義する時に"range"キーワードを使う方法です。これを
使うとコマンド自身に行範囲が指定できるようになります。
関数は"a:firstline"と"a:lastline"という2つの変数を暗黙的に受け取ります。この２
つの変数は関数が呼ばれた時の範囲の開始行番号、最終行番号になります。例を挙げま
しょう。 >

	:function Count_words() range
	:  let n = a:firstline
	:  let count = 0
	:  while n <= a:lastline
	:    let count = count + Wordcount(getline(n))
	:    let n = n + 1
	:  endwhile
	:  echo "found " . count . " words"
	:endfunction

この関数はこのように呼び出すことができます。 >

	:10,30call Count_words()

これを実行させると、関数を１度だけ実行し、単語数の合計を表示します。

もうひとつ、"range"キーワードを使わない関数で行範囲を使う方法があります。
この場合、範囲の各行に対して１度づつ関数が呼び出されます。例を示しましょう。
>
	:function  Number()
	:  echo "line " . line(".") . " contains: " . getline(".")
	:endfunction

この関数を次のように呼び出したとします。 >

	:10,15call Number()

この場合ですと、関数は６回呼び出されます。


可変個のパラメタ
----------------

vimではパラメタが可変個となるような関数を定義できます。例えば、次のコマンド
では少なくとも１つのパラメタ(start)と最大20個の追加パラメタを受けとります。 >

	:function Show(start, ...)

変数"a:1"には１つ目のオプションパラメタ、"a:2"は２つ目、"a:3"は３つ目、とな
ります。変数"a:0"にはオプションパラメタの数が入ります。
このようになります。 >

	:function Show(start, ...)
	:  echohl Title
	:  echo "Show is " . a:start
	:  echohl None
	:  let index = 1
	:  while index <= a:0
	:    echon "  Arg " . index . " is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction

ここでは、後述の":echo"コマンドでハイライト表示をさせるために、":echohl"を使
っています。":echohl None"はそれを停止しています。":echon"コマンドは":echo"
と同様ですが、最後の改行を出力しません。


関数のリスト
------------

":function"コマンドは全てのユーザ定義関数のリストを出力します。 >

	:function
<	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~

関数が何を実行するかを見るには、":function"のパラメタに関数名を指定します。 >

	:function SetSyn
<	1     if &syntax == '' ~
	2       let &syntax = a:name ~
	3     endif ~
	   endfunction ~


デバッグ
--------

デバッグ中やエラーメッセージの表示時に行番号が表示されると助かります。
デバッグモードについては|debug-scripts|をご覧ください。
また、'verbose'オプションを12以上に設定すると全ての関数呼び出しを見ることが
できます。15以上にすると、実行する各行の内容も見ることができます。


関数の削除
----------

例えばShow() 関数を削除するのはこのようにします。 >

	:delfunction Show

存在しない関数を削除しようとするとエラーとなります。

==============================================================================
*41.8*	例外

例題から始めましょう: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

":read"コマンドはファイルがなければ失敗します。このコードはエラーメッセージ
は生成せずに、ユーザーに代りのメッセージを表示します。

":try"と":endtry"コマンドの間のエラーは例外になります。例外は文字列です。エ
ラーのときには文字列がエラーメッセージを含んでいます。また、全てのエラーメッ
セージは番号を持っています。この例題のエラーは"E484:"を含んでいます。この番
号は変わらないことが保証されています(テキストは翻訳されるなどして変わるかも
しれません)。

":read"コマンドが他のエラーを起こした場合、"E484:"というパターンはマッチしな
いでしょう。したがってその例外はキャッチされずに通常のエラーメッセージを表示
します。

あなたはこのようにしたくなるかもしれません: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

これは全ての例外をキャッチするという意味です。しかしこれでは"E21: Cannot
make changes, 'modifiable' is off"のような有効なエラーに気づくことができませ
ん。

ほかにも便利な仕組みに":finally"コマンドがあります: >

	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry

これはカーソル行からファイルの最後までフィルタを通します。"filter"コマンドは
ファイルの名前を引数に取ります。こうすれば、":try"と":finally"の間で問題が起
こったときや、ユーザーがCTRL-Cを押して操作をキャンセルしたときにも"call
delete(tmp)"は必ず呼ばれます。一時ファイルを残す心配はありません。

例外についてさらに詳しい情報はリファレンスマニュアルの|exception-handling|を
参照してください。

==============================================================================
*41.9*	いろいろな留意事項

ここではvimスクリプトに適用される項目の概要を述べます。他の場所でも同じよう
な説明を行っていますが、手頃なチェックリストに使えることでしょう。


行末記号はシステムによって異なります。Unixでは<NL>文字を使いますが、MS-DOS
やWindows、OS/2などでは<CR><LF>を使います。末尾が<CR>となっているようなマッ
プを使う時には気を付けてください。|:source_crnl|もご覧ください。


空白類
------

空行は利用可能です。単に無視します。

行頭の空白類(空白文字とTAB)は常に無視します。パラメタ間の空白類(例えば、後述
の"set"と"coptions"の間)は１つの空白文字に圧縮して、セパレータとなります。
また、最後の文字より後にある空白類は場合によって、無視されたりされなかったり
します。次のようになるわけです。

次のような"="記号を含むような":set"コマンドがあるとします。 >

	:set cpoptions    =aABceFst

"="の直前にある空白類は無視されます。でも"="の後には空白がありません！

オプション値に空白類を含ませるには、次のようにバックスラッシュ("\")でエス
ケープする必要があります。 >

	:set tags=my\ nice\ file

同じ目的で次のように書くと、 >

	:set tags=my nice file

これはエラーとなります。というのは上の行はこのように展開されるためです。 >

	:set tags=my
	:set nice
	:set file


コメント
--------

コメントは " (ダブルクオート)記号で始めます。この文字の後に書いてあるものは
行末に至るまで全てをコメントとみなし、無視します。但しコメントと考えないよう
なコマンドは例外です。例を下にあげておきます。
コメントは行のどこからでも始めることができます。
 
コメントでちょっとした「キャッチ」を作ろうとして次のようにしたとします。 >

	:abbrev dev development		" shorthand
	:map <F3> o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files

短縮形'dev'は'development	" shorthand'に拡張されます。<F3>は実際には
'o# ....'以降、'" insert include'までの行全体となります。また"execute"コマン
ドはエラーとなり、"!"コマンドはそれ以降を全部シェルに渡すため、" 記号が１つ
しかない、というエラーになるでしょう。
結局、":map"、":abbreviate"、":execute"、"!"コマンドでは(このような制限があ
るコマンドは他にもあります)コメントは使えないということです。
":map"、":abbreviate"、":execute"に関しては、こういうズルイ方法を使うと、コ
メントを付けられます。 >

	:abbrev dev development|" shorthand
	:map <F3> o#include|" insert include
	:execute cmd			|" do it

'|'文字を使うと、コマンドを複数に分割できます。この場合、２つ目のコマンドに
はコメントしかないということになります。

":map"と":abbreviate"の場合は'|'の前に空白類を置かないように注意してくださ
い。このコマンドでは行末か'|'の前までの全文字が含まれてしまいます。この振舞
いのため、次のように行末に空白があっても見えないわけです。 >

	:map <F4> o#include  

この問題を避けるには、vimrcを編集する時には'list'オプションをonにするのが
よいでしょう。


落とし穴
--------

次の例には大きな問題があります。

	:map ,ab o#include
	:unmap ,ab 

ここのunmapコマンドはうまく動きません。というのは",ab "(末尾に空白あり)を
unmapしようとするためです。 これはマップシーケンスに存在しません。エラーが発
生しますが、理由を見つけるのが非常に難しいです。これは行末の空白類が見えない
からです。

":unmap"コマンドの後にコメントを追加した場合にも同じことが発生します。 >

	:unmap ,ab     " comment

確かにこのコマンドではコメント部は無視してくれます。でもvimは",ab     "(空白
５個付き)のマップを削除しようとしますが、そんなのはありません。これはこのよ
うに書き直せば大丈夫です。 >

	:unmap ,ab|    " comment


ビューの復元
------------

何らかの変更を加えてから、カーソルのあった場所に戻りたい時があります。
場所自体はマークで復元できますが、画面に表示される行範囲は一致しません。
単にマークした場所を復元するのもいいのですが、そうすると同じ行がウィンドウの最上段
に表示されます。
この例は現在行をヤンクして１行目の上にプットし、ビューを復元します。 >

	map ,p ma"aYHmbgg"aP`bzt`a

これが何をするか見ていきましょう。 >
	ma"aYHmbgg"aP`bzt`a
<	ma			現在のカーソル位置をマーク a をつける
	  "aY			現在行をレジスタ a にヤンク
	     Hmb		画面の最上段にジャンプし、マーク b をつける
		gg		ファイルの１行目にジャンプ
		  "aP		レジスタ a の内容を１行目の上にプット
		     `b		マーク b にジャンプ
		       zt	カーソル行を画面の１行目になるようにスクロール
			 `a	最初にマークした場所にジャンプ


PACKAGING
パッケージ

あなたが作った関数の名前が他の人から入手したものとダブるのを避けるには、次の
ように行ってください。
- 各関数名の前にユニークな文字列を付けます。私はよく短縮形を使っています。
  例えば、"OW_"をオプションウィンドウ関数に使うといった具合です。
- 自作の関数の定義を１つのファイルに入れます。その上で、関数がロードされたか
  どうかをチェックするためのグローバル変数を設定します。そのファイルを再度
  読み込もうとした時は、まずその関数をアンロードするようにします。
例: >

	" これは XXX のパッケージです

	" 再ロードであれば、関数を削除します
	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif

	function XXX_one(a)
		... body of function ...
	endfun

	function XXX_two(b)
		... body of function ...
	endfun

	" ロードが完了した印として、グローバル変数に反映します
	let XXX_loaded = 1

==============================================================================
*41.10*	プラグインを書く 				*write-plugin*

多くの人が使えるようなvimスクリプトを書くこともできます。これをプラグインと呼
びます。vimのユーザはあなたが作ったプラグインを"plugin"ディレクトリにドロップ
するだけで、その機能をきちんと使えます。|add-plugin|も併せてご覧ください。

実際にはプラグインには２種類あります。

  グローバルプラグイン    : 全タイプのファイル用
  ファイルタイププラグイン: 特定タイプのファイル用 

この節では１つ目のグローバルプラグインについて説明します。ほとんどの項目は、
ファイルタイププラグインを書く時も利用できます。ファイルタイププラグイン独自
の点については次節の|write-filetype-plugin|をご覧ください。


名称
----

何よりも最初にしなければならないのはプラグインの名称を決めることです。プラグ
インが提供する機能は名前から明らかになるべきです。また誰か他の人が書いたプラ
グインで名前は同じだけど、内容が違っているようなものは避けるべきです。
名称は８文字以下にしてください。これは古いMS-Windowsシステムの抱える問題を避
けるためです。

入力ミスを集めた"typecorr.vim"というスクリプトがあります。ここではそれを例題
として利用します。

プラグインを誰でも使えるようにするには、いくつかのガイドラインに従ってくださ
い。ここでは１歩づつ説明します。このプラグインの完全なソースはこの節の末尾に
入っています。


ボディ
------

では、プラグインの本体部分に入りましょう。行番行は実際の番号です。 >

 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4

もちろん、本当のリストはもっともっと長いです。

行番号は説明のために追加したものです。本当にプラグインを作る時には入力しない
でください。


へッダ
------

おそらく、新しいセットをプラグインに追加し、いくつかのバージョンができてしまう
でしょう。このファイルを配布すると、それを使った人々は、誰がこの素晴らしいプラ
グインを書いたのかを知りたいと思うでしょうし、意見をメールで送りたい場合にどこ
に送ればよいのでしょうか？
そのため、次のようなヘッダをプラグインに書いておいてください。 >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>

著作権とライセンスについて。プラグインがとても便利で配布を制限するだけの価値が
あるのなら、どうか、ライセンスにパブリックドメインかVimライセンス|license|のど
ちらかを使うことを検討してみてください。次の短い宣言をプラグインの最初のほうに
書いておくだけで十分です。 >

  4	" License:	This file is placed in the public domain.


行連結、副作用の回避					*use-cpo-save*

上の例の18行目では、行連結(|line-continuation|)を使っています。
'compatible'オプションをonにしているユーザはこれが問題となるでしょう。ですが
様々な副作用があるため、システム側で勝手に'compatible'をoffにするわけにはい
きません。これを避けるには'cpoptions'オプションをvimのデフォルト値に設定し、
後でそれを元に戻すようにします。これで行連結が使えますから、そのスクリプトは
たいていの環境で動くようになります。この設定は次のように行います。 >

 11	let s:save_cpo = &cpo
 12	set cpo&vim
 ..
 42	let &cpo = s:save_cpo

最初に'cpoptions'の内容を変数"s:save_cpo"に保存します。プラグインの最後で、
その値を元に戻すわけです。

スクリプトにローカルな変数は|s:var|となる点に注意してください。グローバル変
数だと他のどこかで既に使っている可能性があります。スクリプト内だけで使うよう
な場合は常にスクリプトローカルな変数を使うようにしてください。 


ロードの禁止
------------

あるプラグインをいつもではないけれど、時々ロードして利用したいと思うことがあ
ります。また、システム管理者が全員用のプラグインディレクトリにそのスクリプト
を入れたけれど、一般ユーザには自分で使いたいプラグインを使わせてあげたいこと
もあるでしょう。こういった場合、ユーザ側で特定のプラグインのロードを禁止でき
るように準備してあげないといけません。これは次のようにすれば実現できます。
>
  6	if exists("loaded_typecorr")
  7	  finish
  8	endif
  9	let loaded_typecorr = 1

これを使うとスクリプトの２重ロードを避けることもできます。２重ロードしてしま
うと、関数の２重定義エラーや自動コマンドを２回追加することによるトラブルを防
ぐことになります。
JP補: 要はユーザのvimrcなどで上記の"loaded_typecorr"というグローバル変数を定
JP補: 義してしまえばよいわけです。(本当か？)


マップ
------

さて、プラグインをもっと魅力あるものに仕上げましょう。カーソル下の単語をコレ
クションに追加するようなマップを追加します。このマップ用の一連のキー入力を拾
いますが、ユーザは既にそれを何か他の機能に使っているかもしれません。 プラグ
インを使う時にどのキーに割りあてるかをユーザ側に決めてもらうには、<Leader>
項目を使います。 >

 22	  map <unique> <Leader>a  <Plug>TypecorrAdd

"<Plug>TypecorrAdd"でも動くでしょうが、さらにできることがあります
訳注: The "<Plug>TypecorrAdd" thing will do the work,
訳注: more about that further on.

ユーザは"mapleader"変数にマップさせたい最初のキーシーケンスを設定できます。
ですから、ユーザが次のように実行したとします。 >

	let mapleader = "_"

この機能は最終的に"_a"に定義されます。ユーザがこれをやらなければ、デフォルト
値（バックスラッシュ）を使います。この場合は"\a"がマップとして定義されます。

<unique>の指定があることに注意してください。これは指定のコマンドがマップ済で
ある場合に、エラーを表示します。|:map-<unique>|もご覧ください。

ではユーザが独自のシーケンスを定義したい場合はどうしましょうか？これは次のよ
うな仕組みで実現できます。 >

 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif

ここでは"<Plug>TypecorrAdd"に対するマップが既にあるかどうかを調べ、"<Leader>a"
が未定義の場合に限りそれにマップされまう。ユーザはこれを自分のvimrcファイル
に置く機会が与えられます。 >

	map ,c  <Plug>TypecorrAdd

こうすれば、キーシーケンスを"_a"や"\a"でなく",c"に（自由に)割り合てられます。


パーツ
------

スクリプトが長大になってきた場合、これを複数に分割したくなります。これは関数
やマップを使うことで可能です。ただし、そのような内部用の関数やマップは他のス
クリプトから呼ばれるのは好ましくありません。例えば、Add()という関数を定義で
きます。でも他のスクリプトでも同じ名前の関数を定義しようとする可能性がありま
す。これを避けるには関数に"s:"というプレフィクスを付けてスクリプト内にローカ
ルな関数を定義できます。

新たに入力コレクションを追加する関数を定義します。 >

 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 ..
 36	endfunction

ここで、このスクリプトから s:Add() 関数を呼ぶことができます。他のスクリプト
も s:Add() 関数を定義できますが、いずれもそのスクリプトにローカルであり、同
じスクリプトの中からのみ呼び出すことができる。これ以外にグローバルなAdd()関
数を定義することもできます。これはまた上のいずれとも異なった関数です。

マップ定義では<SID>も使えます。これは現在のスクリプトを識別するためのスクリ
プトIDを生成します。"入力コレクション"プラグインでは次のように利用していま
す。 >

 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 ..
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>

ですから、ユーザが"\a"と入力すると次の手順でコマンドが起動します。 >

	\a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()

もし、他のスクリプトが<SID>Add をマップしていても、スクリプトIDが違ったもの
になりますから、これは違ったマップとして定義できるのです。

ここでは s:Add() と書く代わりに <SID>Add() と書いている点に注意してください。
これはマップはスクリプトの外側でユーザ自身が入力するものであるためです。
<SID>はスクリプトIDに変換されますので、vimはどのスクリプトのAdd()関数をどの
スクリプトから探せばよいかわかるからです。

これはちょっと複雑です。ここではプラグインが別のプラグインと共同で処理を行う
ことを求められるためです。基本的なルールは２つです。１つはマップの<SID>Add()
を使うこと。もう１つは他の場所(スクリプトの中や自動コマンドやユーザ定義コマン
ド)にある s:Add() を使うことです。

メニュー項目を追加する方法でもマップと同じことができます。 >

 26	noremenu <script> Plugin.Add\ Correction      <SID>Add

メニューにプラグインを追加するには"Plugin"ディレクトリを用いることをお勧めし
ます。この場合、選択できるのは１つの項目だけです。２つ以上を追加するにはサブ
メニューを作ることをお勧めします。例えば、"Plubin.CVS"というプラグインがあり
このプラグインはCVSの繰作をする"Plugin.CVS.checkin"と"Plugin.CVS.checkout"を
提供しているといった場合です。 

28行目で":noremap"を使って他のマップが問題を引き起さないようにしているのに
注意してください。例えば、誰かが":call"を再マップしてしまうかも知れません。 
24行目でも":noremap"を使っています。しかしこの場合は <SID>Addを再マップした
いのです。ここで"<script>"を使っているのはこのためです。これを指定するとスク
リプトにローカルな定義だけがマップの対象となるのです(|:map-<script>|)。26行
目でも":noremenu"で同じことをやっています。(|:menu-<script>|)


<SID>と<Plug>					*using-<Plug>*
-------------

<SID>と<Plug>はどちらも、入力したキーのマップが他のマップで使うためだけの
マップを防害するのを避けるのに使います。<SID>と<Plus>の違いに注意してくださ
い。

<Plug>	これはスクリプトの見える側です。これはユーザが一連のキー繰作を割り当
	てたいマップで使います。<plug>は実際に入力されることのない特殊なコー
	ドです。
	他のプラグインが同じ文字シーケンスを使うのと非常に違っていて、次のよ
	うな構造となります。 >
		<Plug> スクリプト名 マップ名
<	今までの例で言えば、スクリプト名は"Typecorr"であり、マップ名 は"Add"
	です。ですから具体的にはこのようになります。 >
		<Plug>TypecorrAdd
<	スクリプト名とマップ名の１文字目だけを大文字にします。こうすれば、ど
	こからがマップ名なのかがわかりやすくなります。

<SID>	これはスクリプトIDです。スクリプトIDは個々のスクリプトに与えられるユ
	ニークな識別子です。
	vimの内部では<SID>は"<SNR>123_"(123の部分はそれぞれ違う番号)に変換し
	ます。ですから関数"<SID>Add()"はあるスクリプトでは"<SNR>11_ADD()"と
	なり、また別のスクリプトでは"<SNR>22_And()"となります。
	これは実際に":function"コマンドを使って関数リストを表示すれば解りま
	す。マップでの<SID>の変換も全く同じです。これはマップからスクリプト
	ローカルな関数を呼び出す方法です。


ユーザ定義コマンド
------------------

今度はユーザ定義コマンドをコレクションに追加しましょう。 >

 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif

ユーザ定義コマンドは同じ名前のコマンドがない場合のみ定義できます。そうでない
場合はエラーとなります。既存のユーザ定義コマンドを上書きするのに":command!"
を使うのは良くありません。ユーザは自分で定義したコマンドがどうして動かなく
なったのかわからなくなるであろうからです。|:command|をご覧ください。


スクリプト変数
--------------

先頭に"s:"が付いた変数はスクリプト変数です。これはスクリプトの中でだけ有効な
ものです。スクリプト外では変数として扱われませんこれは同じ変数名を複数のスク
リプトで使う時のトラブルを避けるための仕組です。変数はvimが稼動中はずっと存
在しています。同じスクリプトを再読み込みしても同じ変数が使われます。
|s:var|をご覧ください。

面白いのは変数はスクリプト内で定義されている関数や自動コマンド、ユーザ定義コ
マンドからでも使える点です。typecorrの例でも集めた単語の数をカウントできるよ
うに数行を追加してみましょう。 >

 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction

最初に s:count をスクリプトの中で４に初期化します。その後、s:Add()関数を呼び
出すと、s:count の値を１増やします。どこから関数が呼ばれても関係ありません。
それはこの関数が同じスクリプトの中で定義されているから、スクリプト内でローカ
ルな変数が使えるからです。


最後に
------

今まで説明してきた例題の最終形はこのようになります。 >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>
  4	" License:	This file is placed in the public domain.
  5
  6	if exists("loaded_typecorr")
  7	  finish
  8	endif
  9	let loaded_typecorr = 1
 10
 11	let s:save_cpo = &cpo
 12	set cpo&vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
 20
 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif
 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 25
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 33	  if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif
 41
 42	let &cpo = s:save_cpo

そうそう、33行目はまだ説明していませんでした。これはカーソル下の単語を新たな
コレクションとして適用します。マップと短縮形はここで拡張されることに気を付け
てください。たとえ":noremap"で定義したマップから呼び出された関数でも、です。

'fileformat'オプションに"unix"を設定する事を推奨します。そうすればVimスクリプ
トはどこでも動くでしょう。スクリプトの'fileformat'が"dos"に設定されていると
Unixでは動きません。|:source_crnl|も見て下さい。ファイルを書き込む前に次のよう
にすれば正しく設定されます。

	:set fileformat=unix


ドキュメント						*write-local-help*
------------

プラグイン用の何らかのドキュメントを作っておくのはとても良いことです。ユーザ
側でその動きを変更できるような場合は特に、です。|add-local-help|ではそれをど
のようにインストールされるかを説明しています。

"typecorr.txt"という名前のプラグイン用ヘルプファイルのサンプルを示します。 >

  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.

最初の行だけはフォーマットに気を付けてください。この行の記述を元に"help.txt"
の"LOCAL ADDSIONS:"の節に概要を埋め込みます|local-additions|。１行目の１桁目に
は必ず"*"がなくてはなりません。ヘルプを追加したら":help"を実行して正しく追加で
きたことを確認してください。

ヘルプファイルに**で囲んでタグを追加することができます。ただし既存のヘルプのタ
グと同じものを使わないように気を付けてください。タグには自分のプラグイン名を使
えばよいでしょう。例えばこの例題であれば、"typecorr-setting"といった具合です。

ヘルプの他の部分を参照する時には || で囲みます。こうすれば簡単にリンク先のヘル
プを見ることができます。


ファイルタイプの定義					*plugin-filetype*
--------------------

ファイルタイプの定義がVimによって提供されていない場合、簡単に定義ファイルを作
ることができます。通常はファイル名がパターンにマッチしたときにファイルタイプを
セットするオートコマンドです。
例: >

	au BufNewFile,BufRead *.foo			set filetype=foofoo

この一行を'runtimepath'の最初にあるディレクトリ内の"ftdetect/foofoo.vim"に保
存してください。Unixなら"~/.vim/ftdetect/foofoo.vim"でしょう。ファイルタイプ
の名前をスクリプトファイルの名前にする決まりになっています。

もし望むならより複雑な検査をすることができます。例えばそのファイルに書かれた
言語を識別するためにファイルの中身を検査するなどです。|new-filetype|を参照し
てください。


サマリー						*plugin-special*

プラグインで使える特殊な記述の概要を以下に示します。

s:name			スクリプト内にローカルな変数

<SID>			スクリプトID。マップや関数をスクリプトローカルにする
			のに使う。

hasmapto()		スクリプトが提供している機能と同じマップが既に定義さ
			れているかどうかをチェックする関数

<Leader>		ユーザ側でプラグイン用のマップ割り当てに使う１文字目
			の文字を"mapleader"で指定できる。<Leader>は"mapleader"
			の値に置換される。

:map <unique>		既にその名前のマップ定義があれば警告を発する。

:noremap <script>	グローバルマップではなく、スクリプト内でローカルな
			マップを使う。

exists(":Cmd")		ユーザ定義コマンドが既にあるかどうかをチェックする。

==============================================================================
*41.11*	ファイルタイププラグインを書く	*write-filetype-plugin* *ftplugin*

ファイルタイププラグインはグローバルプラグインと似ています。違うのは現在の
バッファ専用のマップ定義やオプション設定が行える点です。ファイルタイププラグ
インがどのように使われるかについては|add-filetype-plugin|をご覧ください。

先に|41.10|節のグローバルプラグインをご覧ください。そこで説明してあることは全
てファイルタイププラグインにも適用されます。この節ではファイルタイププラグ
イン独自の機能について説明します。ファイルタイププラグインで最も違うのは現在
のバッファだけに影響を与えるという点です。


ロードの禁止
------------

多くの人々に使ってもらえるようなファイルタイププラグインを書くのであれば、
そのロードを禁止する方法が必要です。プラグインの先頭に次のような記述を追加し
てください。 >

	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1

これは同じプラグインを同じバッファで２重ロード(これは":edit"コマンドをパラメ
タなしで実行した時に発生します)するのを避けるのにも使えます。

これでユーザは自分のファイルタイププラグインに次の一行を追加するだけで、デフォ
ルトプラグインのロードを完全に禁止することができます。 >

	let b:did_ftplugin = 1

これはファイルタイププラグインのディレクトリは'runtimepath'にある$VIMRUNTIME
よりも前に来なければなりません。

もしデフォルトプラグインを使いたいけれど、そのうちのひとつを無効にしたいのな
ら、違う設定をするスクリプトをこのように作ればよいのです。 >

	setlocal textwidth=70

こうして書いたファイルを"after"ディレクトリに入れておけば、"vim.vim"が全ての
ファイルタイププラグインをロードした後に実行されます|after-directory|。例えば
Unixなら"~/.vim/after/ftplugin/vim.vim"となります。デフォルトプラグインは
"b:did_ftplugin"をセットするので、つまり後で再読み込みしても何もしないのです。


オプション
----------

ファイルタイププラグインでは現在のバッファでのみオプション設定が有効となるよ
うに、次のコマンドを使うようにします。 >

	:setlocal

また、設定できるオプションはバッファにローカルなものに限ります。(どのオプ
ションがそうなのかはヘルプで確認してください) |:setlocal|コマンドを使ってグ
ローバルなオプションやウィンドウにローカルなオプションを設定しようとすると、
値は多くのバッファで変更されます。これはファイルタイププラグインがすべきこと
ではありません。

オプションがフラグリストや項目リストの場合、"+="や"-="を使って、既存の値を守
る考えましょう。ユーザが既に値を変更している可能性がある点に注意しましょう。
最初にデフォルト値に再設定しておき、それから変更するというのは良い方法です。
例を示しましょう。 >

	:setlocal formatoptions& formatoptions+=ro


マップ
------

カレントバッファでのみ動くマップを作るには次のコマンドを使います。 >

	:map <buffer>

これは上でも説明したように２段階に分けてマップを作る必要があります。ファイル
タイププラグインでの機能定義の方法を以下に示します。 >

	if !hasmapto('<Plug>JavaImport')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
	endif
	noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>

|hasmapto()| はユーザが既に<Plub>JavaImportというマップを定義しているかどうか
を調べます。未定義ならファイルタイププラグインでデフォルトマップを定義します。
これは|<LocalLeader>|の文字で始まります。ユーザは<LocalLeader>キーを自分で定義
できます。これはマップの最初の１文字目となります。デフォルトではバックスラッ
シュキーになっています。
"<unique>"キーワードを使うと、そのマップが既に定義されている時や既存のマップに
上書きする時にエラーメッセージを出します。
|:noremap|はユーザが既に定義しているマップが防害するのを避けるのに使います。こ
のスクリプトで定義されているマップで<SID>で始まっているを再定義できるようにす
るために":noremap <script>"を使いたくなることもあるでしょう。

利用者にはファイルタイププラグインで定義しているマップを禁止できる仕組みを提供
しなければなりません。以下に"mail"ファイルタイプ用のプラグインでそれをどのよう
に実現しているかの例を示します。 >

	" Add mappings, unless the user didn't want this.
	if !exists("no_plugin_maps") && !exists("no_mail_maps")
	  " Quote text by inserting "> "
	  if !hasmapto('<Plug>MailQuote')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote
	  endif
	  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
	endif

ここでは２つのグローバル変数を使っています。
  no_plugin_maps	全ファイルタイププラグインでのマップを禁止
  no_mail_maps		特定のファイルタイププラグインでのマップを禁止


ユーザ定義コマンド
------------------

特定のファイルタイプ用のユーザ定義コマンドを１つのバッファでのみ実行するには
|:command|実行時に"-buffer" パラメタを用います。例えば次のように使います。 >

	:command -buffer  Make  make %:r.s


変数
----

ファイルタイププラグインは合致するファイルタイプの各バッファ毎に読み込みます。
スクリプト内にローカルな(|s:var|形式の)変数は全バッファで共有されます。バッ
ファ内にローカルな(|b:var|形式の)変数を使えば、バッファ毎に独立した変数が使
用できます。


関数
----

関数の定義は１回だけ行えば、それ以上は必要ありません。しかし上でも述べたよう
に、ファイルタイププラグインは該当するタイプのファイルが開く毎に読み込まれま
す。ですから関数が１度だけ定義されるようにこのような構造としておく必要があり
ます。 >

	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
<

アンドゥ						*undo_ftplugin*
--------

ユーザーが ":setfiletype xyz" としたとき、それ以前のファイルタイプの効果は無
効になるべきです。ファイルタイププラグインの設定を無効にするために
b:undo_ftplugin 変数を設定してください。例: >

	let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"

":setlocal"を使いオプションの名前の後に"<"を使うとそのオプションをグローバル
の値でリセットします。オプションをリセットするにはこの方法が一番です。

これにはコマンド行の連結を可能にするために'cpoptions'から"C"フラグを取り除く
ことが必要です。上述の|use-cpo-save|を参照してください。

ファイル名
----------

ファイルタイププラグインのファイル名にはファイルタイプ名が含まれていなければ
なりません|ftplugin-name|。次の三つのうちのどれかにしてください。

	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim

"stuff"はファイルタイプ名。"foo"と"bar"は責任者の名前です。


まとめ							*ftplugin-special*
------

ファイルタイププラグインの特徴をまとめましょう。

<LocalLeader>		"maplocalleader"の値となります。これを使うとファイル
			タイププラグインのマップの最初に入力する文字がこの値
			に置き換わります。

:map <buffer>		バッファローカルなマップ定義

:noremap <script>	このスクリプトで定義しているうち、<SID>で始まっている
			マップだけを再定義する。

:setlocal		バッファローカルなオプション値の設定を行う。

:command -buffer	バッファローカルなユーザ定義コマンドを定義する。

exists("*s:Func")	関数が既に定義済かどうかをチェック

全プラグインで使える特別な項目については|plugin-special|も併せてご覧ください。

==============================================================================
*41.12*	コンパイラプラグインを書く		*write-compiler-plugin*

コンパイラプラグインでは特定のコンパイラを使うためのオプション設定ができます。
この呼び出しは|:compiler|コマンドで行います。この中心となるのは'errorformat'
と'makeprg'オプションの設定です。

次のようにすれば簡単に実例を見ることができます。このコマンドでデフォルトのコン
パイラプラグインを全て見ることができるでしょう。 >

	:next $VIMRUNTIME/compiler/*.vim

|:next|を使って次のファイルに移ってください。

これらのファイルのための特別な仕組みが２つあります。１つはデフォルトファイルの
ルールを変更したり追加したりできる仕組です。デフォルトファイルは次のようになっ
ています。 >

	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"

コンパイラファイルを書いて、個人用のランタイムディレクトリ(例えばUnixであれ
ば ~/vim/compiler)に置く時に"current_compiler"という変数を設定しておいて、デ
フォルトファイルの設定をスキップさせることができます。

２つめの仕組みは、":set"を使う":compiler!"と":setlocal"を使う":compiler"です。
Vimはこのために":CompilerSet"というユーザーコマンドを定義します。しかしふ
るいVimではそうではないので、あなたのプラグインで定義してください。次に例を示
します。 >

  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&		" use the dfault 'errorformat'
  CompilerSet makeprg=nmake

vimの配布用やステム全体のランタイムディレクトリに置くようなコンパイラプラグ
インを書くのであれば、上で書いたような仕組を作っておいてください。つまり、
"current_compiler"がユーザプラグインで既に設定されていれば、何もしないように
するわけです。

デフォルトプラグインのルールを変更するようなコンパイラプラグインを書くのであ
れば、"current_compiler"をチェックしないようにしてください。このプラグインは
最後にロードされるように、つまり'runtimepath'のディレクトリリストの最後に置
くようにすべきです。例えば、Unixでは~/.vim/after/compilerなどが使えるでしょ
う。

==============================================================================

Next chapter: |usr_42.txt|  新しいメニューの追加

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
