COMMENT: 少ないキータイプ数で入力する方法
STATUS: finished 6.3.054
TRANSLATOR: 清水俊彦(しみず) <mailto:t_smz@syd.odn.ne.jp>

*usr_24.txt*	For Vim version 6.3.  Last change: 2003 Aug 18

		     VIM USER MANUAL - by Bram Moolenaar

				素早く挿入する


テキストを入力する時、キーを押す回数を減らし入力ミスを防ぐために、いろいろな
方法を提供しています。挿入モードで前回に入力した文字列を繰り返してくれる補完
機能があります。長い文字列を短縮形で入力することもできます。キーボード上にな
いような文字を入力する方法もあります。

|24.1|	修正を行う
|24.2|	一致するものを表示する
|24.3|	補完
|24.4|	挿入を繰り返す
|24.5|	他の行をコピーする
|24.6|	レジスタ内容を挿入する
|24.7|	短縮形
|24.8|	特殊な文字を入力する
|24.9|	ダイグラフ（二重字）
|24.10|	通常モードのコマンド

     Next chapter: |usr_25.txt|  フォーマット付きテキストを編集する
 Previous chapter: |usr_23.txt|  他の種類のファイルを編集する
Table of contents: |usr_toc.txt|

==============================================================================
*24.1*	修正を行う

<BS>キーについては既に説明しました。これはカーソルの直前の文字を削除します。
<Del>キーはカーソル下の(次の)文字について同じことを行います。
入力した単語をまるごと削除するのであれば、CTRL-Wを使います。

	The horse had fallen to the sky ~
				       CTRL-W
	The horse had fallen to the ~

行全体がグチャグチャになってしまって、行頭から全部を消すのなら、CTRL-Uを使い
ます。ただしカーソルの後ろにある文字列は消えません。行頭の非空白文示からカー
ソル位置までの文字だけが削除されます。カーソルが"fallen"の"f"にある時にCTRL-U
を押すと、このようになります。

	The horse had fallen to the ~
		      CTRL-U
	fallen to the ~

いくつか前に入力した単語に誤りがあった場合、カーソルを動かして修正する必要が
あります。例えば、このような文があるとします。

	The horse had follen to the ground ~

途中にある"follen"を"fallen"に直す必要があります。カーソルが行末にある場合、
次のようにして修正ができます。 >

					<Esc>4blraA

<	挿入モードを抜ける		<Esc>
	４単語分戻る			     4b
	最初の"o"に移動する		       l
	"a"に置換する				ra
	行末に移動して挿入モードを再開		  A

他にもこういった方法があります。 >

		<C-Left><C-Left><C-Left><C-Left><Right><Del>a<End>

<	４単語文戻る。			<C-Left><C-Left><C-Left><C-Left>
	最初の"o"に移動する			<Right>
	"o"を削除する				       <Del>
	"a"を挿入する					    a
	行末に移動する 					     <End>

この場合は挿入モードのままで移動に特殊キーを使ます。これは普通のモードレスの
エディタと似ています。こちらの方が覚えやすいでしょうが、速くは入力できません。
これは手を文字キーからカーソルキーや<End>キーのように、キーボードを見ないと
押せないような場所にあるキーを押す必要があるからです。
特殊キーを使うと挿入モードから抜ける必要がないので、マップを書く時にとても便
利です。ここでは打鍵数が増えることには触れないことにします。
挿入モードで使える特殊キーの概要を次に示します。

	<C-Home>	ファイルの先頭に移動
	<PageUp>	１画面分、逆スクロール
	<Home>		業頭
	<S-Left>	１単語左へ移動
	<C-Left>	１単語左へ移動
	<S-Right>	１単語右へ移動
	<C-Right>	１単語右へ移動
	<End>		行末へ移動
	<PageDown>	１画面分、スクロール
	<C-End>		ファイルの末尾に移動

さらなる情報が必要であれば、|ins-special-special|をご覧ください。

==============================================================================
*24.2*	呼応したものの表示

")"を入力した時に呼応する"("の場所にカーソルが動くと便利でしょう。vimでこれ
をやるには次のコマンドを入力します。 >

	:set showmatch
"(example)"といった文字列を入力した時、")"を入力した瞬間にカーソルを対応する
カッコ"("まで動かし、0.5秒間そこにいてから、元の入力位置に戻ります。
呼応するカッコがない場合は警告音で知らせます。こういう時は"("をどこかで入力
し忘れたか、")"が多すぎるかのどちらかだということがわかります。
このような呼応のチェックは[ ]や{ }の組み合せでも動きます。カーソルが呼応する
カッコにある時でも次の文字を入力して構いません。その場合はすぐにカーソルが元
の場所に戻って挿入処理を始めてくれます。
呼応するカッコでの待ち時間は'matchtime'オプションで設定できます。例えば、次
の例では1.5秒待つようになります。 >

	:set matchtime=15

時間は1/10秒単位で指定します。

==============================================================================
*24.3*	補完

vimは自動的に挿入時に補完を行います。単語の最初の部分を入力し、CTRL-Pを入力
します。するとvimは残りを補ないます。
例えば、Ｃプログラムを作っていて、次のように入力したいとします。

	total = ch_array[0] + ch_array[1] + ch_array[2]; ~

まずこのように入力を行います。

	total = ch_array[0] + ch_ ~

ここで、vimに単語の補完をさせるためにCTRL-Pコマンドを入力します。vimはカー
ソル位置にある単語の最初の部分と一致する単語を探そうとします。この場合なら、
"ch_"がそうです。これに合致するパターンとして"ch_array"があります。ですか
ら、CTRL-Pを押すことで次のような結果となります。

	total = ch_array[0] + ch_array ~

さらにちょっと入力をおこなって、こうなりました。(行末は空白文字です)

	total = ch_array[0] + ch_array[1] +  ~

さて、ここでCTRL-Pを押すとvimは先ほどと同じようにカーソル位置にある単語と一
致する単語を探そうとします。しかしカーソル位置には何も入力されていませんので
直前の単語、つまり"ch_array"を見つけます。もう一度CTRL-Pを押すと、さらに一つ
前の単語、つまり"total"を見つけます。さらにCTRL-Pを押すともう一つ前に逆登り
ます。それ以上単語がなくなると、最初の状態に戻ります。つまり何もしないわけ
です。CTRL-Pを４回押すと、また"ch_array"から始めます。

前方検索する場合はCTRL-Nを使います。ファイルの末尾まで(もしくは先頭)までたど
り着くと、ファイルの先頭(もしくは末尾)から処理を続けますので、CTRL-NとCTRL-P
は順序は違いますが、同じ単語を見つけることになります。
Hint: CTRL-Nは次(Next)の意味で、CTRL-Pは直前(Previous)の意味です。

vimは補完できる単語を見つけるのに多大な努力を通過します。
smz 意味不明(笑) なんでgo throughなの？結局、努力するの？しないの？
デフォルトでは、次の場所を探します。

	1. 編集中のファイル
	2. 他のウィンドウのファイル
	3. 他のロード済ファイル(隠しバッファ)
	4. ロードしていないファイル(非アクティブバッファ)
	5. タグファイル
	6. 現在のファイルから#include しているファイル


オプション
----------

検索する順序については'complete'オプションでカスタマイズできます。

また検索時には'ignorecase'オプションも使います。これがonの時は、検索する文字
列の大文字小文字は無視します。

補完で使う特別オプションに'infercase'があります。これは大文字小文字を無視す
る('ignorecase'がonであるのが条件)が、その単語を実際に引用する時には入力済の
部分はそちらを使います。つまり、"For"と入力した時、"fortunately"が見つかった
とすると、その結果は"Fortunately"となるわけです。


特定タイプの補完
----------------

ある特定のタイプの項目を探している場合には、次のようなコマンドでそのタイプだ
けを検索することができます。

	CTRL-X CTRL-F		ファイル名
	CTRL-X CTRL-L		行全体
	CTRL-X CTRL-D		マクロ定義(インクルードファイルの中も探す)
	CTRL-X CTRL-I		現在のファイルとインクルードファイル
	CTRL-X CTRL-K		辞書の単語
	CTRL-X CTRL-T		同義語辞書(シソーラス)の単語
	CTRL-X CTRL-]		タグ
	CTRL-X CTRL-V		vimのコマンド行

上記のいずれかの指定の後でCTRL-Nを押すと次の一致項目を探し、CTRL-Pで１つ前の
項目を探します。
各コマンドの詳しい説明は|ins-completion|をご覧ください。


ファイル名の補完
-----------------

例としてCTRL-X CTRL-Fを取り上げましょう。これはファイル名を探すコマンドです。
カレントディレクトリのファイルを検索し、カーソル位置の単語にヒットする単語を
順に表示します。
例えば、カレントディレクトリにこのようなファイル群があるとしましょう。

	main.c  sub_count.c  sub_done.c  sub_exit.c

vimを挿入モードにして、次のように入力します。

	The exit code is in the file sub ~

ここでCTRL-X CTRL-Fを入力します。vimはカーソル位置の単語"sub"を補完しようと
して、カレントディレクトリにあるファイルを見ます。最初に見つかったのは、
"sub_count.c"です。これは望みのファイルではなかったので、次のファイル名を表
示させるために、CTRL-Nを押します。ここでヒットしたのは"sub_done.c"です。もう
一度CTRL-Nを押すと、"sub_exit.c"が出てきます。
結局、次のような表示となります。

	The exit code is in the file sub_exit.c ~

もしファイル名の先頭が"/"(Unix)やC:\(DOSやMS-Windows)の場合は、そのファイル
システムの全ファイルが対象となります。例えば、"/u"と入力した後で、CTRL-X
CTRL-F を入力します。これは例えば"/usr"(Unixの場合)にヒットするでしょう。

	the file is found in /usr/ ~

もし、ここでCTRL-Nを押すと"/u"に戻ることでしょう。そうではなく"/usr/"を受け
入れた上で、さらに１つ深い階層でCTRL-X CTRL-Fを使うこともできます。

	the file is found in /usr/X11R6/ ~

この結果はご利用のファイルシステムで何が見つかったかによって変わってきます。
なお、ヒットした結果はアルファベット順にソートされます。

==============================================================================
*24.4*	挿入を繰り返す

挿入モードでCTRL-Aを押すと、前回の挿入モードの時に入力した内容を挿入します。
例えば、次のような内容で始まるファイルがあるとします。

	"file.h" ~
	/* Main program begins */ ~

このファイルの１行目の行頭に"#include "という文字列を追加するように編集しま
す。

	#include "file.h" ~
	/* Main program begins */ ~

ここで"j^"コマンドで次の行の行頭にカーソルを動かします。ここにもうひとつ
"#include "の行を追加しましょう。このようにします。 >

	i CTRL-A

この結果はこうなります。

	#include "file.h" ~
	#include /* Main program begins */ ~

上で述べたようにCTRL-Aは前回に入力した内容を挿入してくれますので、"#include "
が表示されます。ここで続けて"main.h<Enter>"と入力して行を完成させます。

	#include "file.h" ~
	#include "main.h" ~
	/* Main program begins */ ~

CTRL-@ コマンドを使うと、CTRL-Aを実行してから挿入モードを抜けます。これは前
回と全く同じことを繰り返したい時には便利な方法です

==============================================================================
*24.5*	他の行からコピーする

挿入モードでCTRL-Yを押すと、カーソルの直前の行から１文字複写します。これは直
前の行内容をコピーしたい時に便利です。例えば、次のようなＣコードがあるとしま
す。

	b_array[i]->s_next = a_array[i]->s_next; ~

次にこの行の"s_next"を"s_prev"に置き換えた行を入力したいとします。まず新しい
行を開いて"next"の"n"の直前まで、CTRL-Yを１４回押します。
このように表示されているはずです。

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_ ~

ここで"prev"と入力します。

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev ~

続けて、次の"next"まで１７回CTRL-Yを押します。

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev = a_array[i]->s_ ~

ここで"prev;"と入力すれば、行が完成です。

CTRL-Yと似たコマンドにCTRL-Eがあります。こちらはカーソルの直後の行内容を複写
してくれます。

==============================================================================
*24.6*	レジスタ内容の挿入

CTRL-R {register}コマンドはレジスタの内容を挿入します。長い単語を入力する手間
を省きたい時に便利です。例えば、次の行を入力したいとします。

	r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~

関数名は違ったファイルで定義しています。そのファイルを開いてカーソルを関数名
の先頭に合せて次のコマンドでレジスタｖにヤンクします。 >

	"vyiw

"vはレジスタの指定、"yiw"は現在位置の単語をヤンクするコマンドです。さて、目
的の行を入力したいファイルに戻り、挿入モードを開始して次のように打ちます。

	ir = ~

挿入モードのままで CTRL-R v を入力すると上でヤンクした関数名が挿入されます。

	r = VeryLongFunction ~

こうして、関数のパラメタや関数名を入力し続けます。関数名の入力はCTRL-R vで行
います。
同じことを補完を使ってもできます。レジスタの利用は同じ文字で始まる単語がたく
さんある時に便利です。

もしレジスタ内に<BS>といった特殊な文字を含んでいる場合は、実際にその文示を
キーボードから入力されたかのうように処理します。そうなることを望まない場合、
(例えば、"<BS>"という４文字を入力したい場合)はCTRL-R CTRL-R {register}と指定
します。

==============================================================================
*24.7*	短縮形(abbreviation)

短縮形(abbreviation)とは長い単語を置き換える短い単語のことです。"advertisement"
を例えば、"ad"と略したりするわけです。vimではこのような短縮形を入力して、そ
れを自動的に展開することができます。
"ad"を入力する都度、それを"advertisement"に展開して欲しければ、次のコマンド
を実行します。 >

	:iabbrev ad advertisement

これで、"ad"と入力すると、完全形の"advertisement"を文章中に挿入してくれます。
この機能は単語の区切りとなるような文字、例えば空白文字を入力した時にだけ実行
されます。

	入力した文字		画面上での見え方
	I saw the a		I saw the a ~
	I saw the ad		I saw the ad ~
	I saw the ad<Space>	I saw the advertisement<Space> ~

この展開は"ad"を入力すると同時に行われるわけではありません。これは例えば、
"add"のような単語を入力する時に展開させないためです。単語全体が入力された時
に短縮形のチェックを行います。


複数の単語の短縮形
------------------

展開後に複数の単語となるような短縮形でも定義できます。例えば、"Jack Benny"の
短縮形を"JB"と定義するには、次のようなコマンドを使います。 >

	:iabbrev JB Jack Benny

プログラマとして、私(Bram氏のこと)はちょっと変った短縮形を使っています。 >

	:iabbrev #b /****************************************
	:iabbrev #e <Space>****************************************/

これはコメントを四角い形にする時に使っています。最初の行を入力する時に"#b"を
使って、コメントを開始します。続けて、コメント本体を入力し最後に"#e"で最終行
を作ります。
短縮形"#e"の展開結果が空白文字で始まっている点に気を付けてください。言い代え
ると、展開結果の最初の２文字は「空白＋"*"」です。普通はvimは短縮形と展開結果
の間にある空白を無視します。上の例ではわざと"<Space>"と７文字で書いて、そう
ならないようにしています。

	Note:
	":iabbrev"は入力するには長いので、":iab"でもうまく動きます。
	これは短縮コマンドの短縮形というわけですね！


入力ミスを直す
--------------

毎回、同じような入力ミスをしてしまうことってありますよね。例えば、"the"と入
力するところを"teh"としてしまうとか。これを短縮形を使って直してしまうことが
できます。 >

	:abbreviate teh the

こういった単語を全部追加してもいいです。よくやる間違いを見つけたらその都度
その単語を追加しましょう。


短縮形の一覧リスト
------------------

":abbreviate"コマンドで短縮形の一覧を表示してくれます。

	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!  teh		 the

１桁目の"i"は挿入モード用の意味です。こういった短縮形は挿入モードの時だけ有
効となります。他に使われる文字にはこのようなものがあります。

	c	Command-line mode			:cabbrev
	!	both Insert and Command-line mode	:abbreviate

コマンド行モードでは短縮形はそれほど使うことはありませんので、多くの場合は
"iabbrev"コマンドを使うことになるでしょう。このコマンドなら、次のようなコマ
ンドの場合に"ad"が展開されるのとを防ぐことができます。 >

	:edit ad


短縮形の削除
------------

短縮形を取り除くには":unabbreviate"コマンドを使います。次のような短縮形を登
録してあるとしましょう。 >

	:abbreviate @f fresh

これを削除するにはこのコマンドを使います。 >

	:unabbreviate @f

これを入力すると、@fが"fresh"に展開されてしまうのに気付くでしょう。これにつ
いては心配いりません。vimはどうにかしてそれを解ってくれます。(ただし、"fresh"
という短縮形が定義されている場合は例外です。そうあることではないでしょうが）
全部の短縮形を削除するにはこうします。 >

	:abclear

":unabbreviate"と":abclear"にも、挿入モード用(":iunabbreviate"と":iabclear")
とコマンド行モード用(":cunabbreviate"と":cabclear")のバリエーションがありま
す。


短縮形をマップする
------------------

短縮形を定義する時に注意すべき点がもう一つあります。登録された文字列をマップ
するべきではありません。例をあげましょう。 >

	:abbreviate @a adder
	:imap dd disk-door

ここで"@a"を入力すると、"adisk-doorer"になってしまいます。これは望んでいた結
果ではないでしょう。これを避けるには、":noreabbrev"コマンドを使います。これ
は":abbreviate"と同じですが、展開した結果はマップの対象となりません。 >

	:noreabbrev @a adder

これなら、短縮形の結果がマップされるようなことは起こらなくなります。

==============================================================================
*24.8*	特殊な文字を入力する

CTRL-Vコマンドを使うと、その次に入力した文字をそのまま挿入できます。言い換え
ると、どんな特別な意味を持つキーであっても、その意味が無視されます。例えば、
こうすると >

	CTRL-V <Esc>
<
<ESC>文字自身が挿入されるだけで、挿入モードからは抜けません。(上の例もそうで
すが、CTRL-Vの後にある空白は見やすくするためのもので、入力するものではありま
せん)

	Note:
	MS-WindowsではCTRL-Vはテキストのペーストに使っています。CTRL-Qをその
	代わりに使ってください。Unixでは逆に一部の端末ではCTRL-Qに特別な意味
	づけをしているために使えません。

また、CTRL-V {digits} コマンドを使うと、文字コードを10進数で指定してその文字
を挿入することができます。例えば、文字コード127は<Del>文字(必ずしも<Del>キー
とは限りませんよ)です。で、この文字を挿入するには次のように入力します。 >

	CTRL-V 127

同じやりかたで文字コード255までの文字を入力できます。文字コードが99以下の場
合は、続けて数字以外の文字を入力すれば、それでコマンドは数値を認識できます。
数字以外の文字を入力するのを避けたいのであれば、数値が３桁となるように１桁か
２桁の"0"を入力してください。
次のコマンドはいずれも<Tab>と"."を挿入します。

	CTRL-V 9.
	CTRL-V 09.
	CTRL-V 009.

文字コードを16進数で指定もできます。その場合はCTRL-Vの直後に"x"を使います。
>
	CTRL-V x7f

この場合もコード255の文字(CTRL-V xff)まで使えます。また、"o"で８進数の指定が
できます。この他にも"u"と"U"でそれぞれ16ビットと32ビットの文字コード(例えば
Unicodeの文字)が指定できます。

	CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678

==============================================================================
*24.9*	ダイグラフ(二重字)

JP: 二重字というのは、例えば、"ae"がひっついたような記号が発音記号に使われて
JP: いるアレです。この節の記述はラテン語圏(例えばISO-8859-1)での８ビット文字
JP: の使い方の説明で、ほとんどの日本語環境で意味がないと思います。

一部の文字はキーボード上にありません。例えば、コピーライトに使う文字(丸付き
の"c")がそうです。こういった文字をvimで扱うには２文字を１文字にしたダイグラ
フを使います。例えば、コピーライトの文字を出すには次のように入力します。

	CTRL-K Co

JP: このコマンドを使っても日本語環境ではいわゆる半角カナのウが表示されるだけ
JP: です。どうしても見たい方はvimの表示フォントを欧文フォントに変更してくだ
JP: さい。その場合は当然ですが、日本語は表示されません。あしからず。

使えるダイグラフを知りたければ、次のコマンドを入力してください。 >

	:digraphs

ダイグラフの一覧表を表示します。(表及びその説明は省略)

  AC ~_ 159  NS |  160  !I ¡  161  Ct ¢  162  Pd £  163  Cu ¤  164  Ye ¥  165 ~
  BB ¦  166  SE §  167  ': ¨  168  Co ©  169  -a ª  170  << «  171  NO ¬  172 ~
  -- ­  173  Rg ®  174  'm ¯  175  DG °  176  +- ±  177  2S ²  178  3S ³  179 ~

ポンド記号のダイグラフは"Pd"です。ほとんどのダイグラフは生成される文字から想
像しやすい文字を選んであります。リストをご覧になれば、どういうルールか解って
いただけるでしょう。
どのダイグラフもその組み合せを使っていなければ、１文字目と２文字目を入れ換え
ても構いません。ですからCTRL-K dPもポンド記号の意味になります。これは"dP"と
いうダイグラフはなく、"Pd"ダイグラフを探し当てるためです。

	Note:
	ダイグラフはvimが使用中と認識しているキャラクタセットに依存していま
	す。MS-DOSのそれはMS-Windowsのとは違うでしょう。その時点でどのダイグ
	ラフが有効かは":digraphs"コマンドで確認するようにしてください。

独自のダイグラフを定義することもできます。例えばこのようにします。 >

	:digraph a" ä

これはCTRL-K a" を入力した時にａウムラウトとなる定義です。文字コードを10
進数で指定することもできます。この指定は上での指定と同じことです。 >

	:digraph a" 228

ダイグラフについてより詳しいことは|digraphs|をご覧ください。
他にもキーマップを使って特殊な文字を挿入することができます。詳しくは|45.5|
をご覧ください。

==============================================================================
*24.10*	通常モードのコマンド

挿入モードで提供しているコマンドはそれほど多くはありません。通常モードに
はもっといろいろあります。通常コマンドを使いたければ、普通は一度<Esc>で挿
入モードを抜けて、通常モードのコマンドを実行し、また"i"や"a"で挿入モード
に戻るという手順が必要です。
ですが、もっと簡単な方法があります。CTRL-O {command}であれば、通常モード
のコマンドを挿入モードで実行できます。例えば、カーソル位置から行末までを
削除するには次のようにします。 >

	CTRL-O D

この方法で実行できるのは１つのコマンドだけです。カウンタによる回数指定は
可能です。これはもう少し複雑な例です。

	CTRL-O "g3dw

これは３つの単語を削除してレジスタＧに格納します。

==============================================================================

Next chapter: |usr_25.txt|  フォーマット付きテキストを編集する

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
