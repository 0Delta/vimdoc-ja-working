*channel.txt*      For Vim バージョン 8.0.  Last change: 2016 Sep 11


		  VIMリファレンスマニュアル    by Bram Moolenaar


		      プロセス間通信				*channel*

Vimは別のプロセスと通信するのにチャンネルを用います。
チャンネルはソケットまたはパイプを用います。		*socket-interface*
Jobs can be used to start processes and communicate with them.
Netbeansインターフェイスもチャンネルを使っています。 |netbeans|

1. 概要					|job-channel-overview|
2. チャンネルデモ			|channel-demo|
3. チャンネルを開く			|channel-open|
4. JSON、JSチャンネルを使う		|channel-use|
5. チャンネルコマンド			|channel-commands|
6. RAW、NLチャンネルをつかう		|channel-raw|
7. More channel functions		|channel-more|
8. Starting a job with a channel	|job-start|
9. Starting a job without a channel	|job-start-nochannel|
10. ジョブオプション			|job-options|
11. ジョブを制御する			|job-control|

{Vi にはこれらの機能はありません}
{only when compiled with the |+channel| feature for channel stuff}
	You can check this with: `has('channel')`
{only when compiled with the |+job| feature for job stuff}
	You can check this with: `has('job')`

==============================================================================
1. 概要							*job-channel-overview*

There are four main types of jobs:
1. A daemon, serving several Vim instances.
   Vim connects to it with a socket.
2. One job working with one Vim instance, asynchronously.
   Uses a socket or pipes.
3. A job performing some work for a short time, asynchronously.
   Uses a socket or pipes.
4. Running a filter, synchronously.
   Uses pipes.

For when using sockets See |job-start|, |job-start-nochannel| and
|channel-open|.  For 2 and 3, one or more jobs using pipes, see |job-start|.
For 4 use the ":{range}!cmd" command, see |filter|.

Over the socket and pipes these protocols are available:
RAW	nothing known, Vim cannot tell where a message ends
NL	every message ends in a NL (newline) character
JSON	JSON encoding |json_encode()|
JS	JavaScript style JSON-like encoding |js_encode()|

Common combination are:
- Using a job connected through pipes in NL mode.  E.g., to run a style
  checker and receive errors and warnings.
- Using a deamon, connecting over a socket in JSON mode.  E.g. to lookup
  cross-references in a database.

==============================================================================
2. チャンネルデモ			*channel-demo* *demoserver.py*

デモにはPythonが必要です。デモプログラムは次の場所にあります。
$VIMRUNTIME/tools/demoserver.py
それをあるターミナルで実行しましょう。そのターミナルをT1と呼びます。

次に別のターミナルでVimを実行します。そして以下のコマンドでサーバーに接続しま
す: >
	let channel = ch_open('localhost:8765')

T1の中に次のように表示されます:
	=== socket opened === ~

ついにサーバーにメッセージを送信できます: >
	echo ch_evalexpr(channel, 'hello!')

このメッセージはT1で受信され、Vimには応答が送り返されます。
T1ではVimが送った生のメッセージを確認できます:
	[1,"hello!"] ~
そしてレスポンスはこうなります:
	[1,"got it"] ~
この数値はメッセージを送るたびに増加していきます。

サーバーはVimにコマンドを送信できます。T1に於いて、次のように正確に(引用符を含
めて文字通りに)タイプしてください:
	["ex","echo 'hi there'"] ~
するとそのメッセージがVimに表示されます。You can move the cursor a word forward:
	["normal","w"] ~

非同期通信を取り扱うためにはコールバック(以下ハンドラー)が必要です: >
	func MyHandler(channel, msg)
	  echo "from the handler: " . a:msg
	endfunc
	call ch_sendexpr(channel, 'hello!', {'callback': "MyHandler"})
Vim will not wait for a response.  Now the server can send the response later
and MyHandler will be invoked.

sendを呼ぶたびに毎回コールバックを指定する代わりに、チャンネルを開く際に指定す
ることもできます: >
	call ch_close(channel)
	let channel = ch_open('localhost:8765', {'callback': "MyHandler"})
	call ch_sendexpr(channel, 'hello!')

When trying out channels it's useful to see what is going on.  You can tell
Vim to write lines in log file: >
	call ch_logfile('channellog', 'w')
See |ch_logfile()|.

==============================================================================
3. チャンネルを開く					*channel-open*

チャンネルを開くには次のようにします: >
    let channel = ch_open({address} [, {options}])
    if ch_status(channel) == "open"
      " use the channel

Use |ch_status()| to see if the channel could be opened.

{address} は "ホスト名:ポート番号" の形式です。 例:"localhost:8765"

{options} is a dictionary with optional entries:	*channel-open-options*

"mode" でモード(通信フォーマット)を指定します:		*channel-mode*
	"json" - JSONを使う(詳しくは下記を参照。もっとも使いやすい方法。既定)
	"js"   - Use JS (JavaScript) encoding, more efficient than JSON.
	"nl"   - Use messages that end in a NL character
	"raw"  - rawメッセージを使う
						*channel-callback* *E921*
"callback"	メッセージ受信時に他のハンドラーで扱われない時に呼ばれます。
		これはチャンネルのハンドルと、受信したメッセージの2つの引数を
		取ります。例: >
	func Handle(channel, msg)
	  echo '受信した: ' . a:msg
	endfunc
	let channel = ch_open("localhost:8765", {"callback": "Handle"})
<
		"mode" が "json", "js" の時には、"msg" 引数は受信したメッセー
		ジの本文で、Vimの型に変換されています。
		When "mode" is "nl" the "msg" argument is one message,
		excluding the NL.
		"mode" が "raw" の時には、 "msg" 引数はメッセージ全体を格納し
		た文字列です。

		For all callbacks: Use |function()| to bind it to arguments
		and/or a Dictionary.  Or use the form "dict.function" to bind
		the Dictionary.

		Callbacks are only called at a "safe" moment, usually when Vim
		is waiting for the user to type a character.  Vim does not use
		multi-threading.

							*close_cb*
"close_cb"	A function that is called when the channel gets closed, other
		than by calling ch_close().  It should be defined like this: >
	func MyCloseHandler(channel)
<		Vim will invoke callbacks that handle data before invoking
		close_cb, thus when this function is called no more data will
		be received.
							*waittime*
"waittime"	The time to wait for the connection to be made in
		milliseconds.  A negative number waits forever.

		The default is zero, don't wait, which is useful if a local
		server is supposed to be running already.  On Unix Vim
		actually uses a 1 msec timeout, that is required on many
		systems.  Use a larger value for a remote server, e.g.  10
		msec at least.
							*channel-timeout*
"timeout"	The time to wait for a request when blocking, E.g. when using
		ch_evalexpr().  In milliseconds.  The default is 2000 (2
		seconds).

"mode" が "json" か "js" の時には "callback" はオプションです。これを省略した
場合、メッセージを1つ受信するにはメッセージを1つ送信する必要があります。

To change the channel options after opening it use |ch_setoptions()|.  The
arguments are similar to what is passed to |ch_open()|, but "waittime" cannot
be given, since that only applies to opening the channel.

例えば、ハンドラーは後から追加したり、変更したりできます: >
    call ch_setoptions(channel, {'callback': callback})
"callback" が空の場合 (一度も指定しないか、空文字列を指定した場合) ハンドラー
は削除されます。

After a callback has been invoked Vim will update the screen and put the
cursor back where it belongs.  Thus the callback should not need to do
`:redraw`.

The timeout can be changed: >
    call ch_setoptions(channel, {'timeout': msec})
<
							  *channel-close* *E906*
チャンネルを使い終わったら、以下のように切断してください: >
    call ch_close(channel)
When a socket is used this will close the socket for both directions.  When
pipes are used (stdin/stdout/stderr) they are all closed.  This might not be
what you want!  Stopping the job with job_stop() might be better.
All readahead is discarded, callbacks will no longer be invoked.

Note that a channel is closed in three stages:
  - The I/O ends, log message: "Closing channel". There can still be queued
    messages to read or callbacks to invoke.
  - The readahead is cleared, log message: "Clearing channel".  Some variables
    may still reference the channel.
  - The channel is freed, log message: "Freeing channel".

When the channel can't be opened you will get an error message.  There is a
difference between MS-Windows and Unix: On Unix when the port doesn't exist
ch_open() fails quickly.  On MS-Windows "waittime" applies.
*E898* *E901* *E902*

If there is an error reading or writing a channel it will be closed.
*E630* *E631* 

==============================================================================
4. JSON、JSチャンネルを使う					*channel-use*

"mode" が JSON の場合は、以下のようにメッセージを同期的に送信できます: >
    let response = ch_evalexpr(channel, {expr})
これは通信相手から応答があるまで待ち合わせます。

When mode is JS this works the same, except that the messages use
JavaScript encoding.  See |js_encode()| for the difference.

To send a message, without handling a response or letting the channel callback
handle the response: >
    call ch_sendexpr(channel, {expr})

メッセージを送信し、応答を特別な関数で非同期的に処理する場合には、このようにし
ます: >
    call ch_sendexpr(channel, {expr}, {'callback': Handler})

Vim will match the response with the request using the message ID.  Once the
response is received the callback will be invoked.  Further responses with the
same ID will be ignored.  If your server sends back multiple responses you
need to send them with ID zero, they will be passed to the channel callback.

{expr} は JSON に変換され、配列で包まれます。{expr} として文字列 "hello" を送
信した場合に、通信相手が受け取るメッセージの例は次のようになります:
	[12,"hello"] ~

送信されるJSONのフォーマットはこのようになっています:
    [{number},{expr}]

{number} には毎回異なる値が入ります。これは応答があるならば、必ず使われます:

    [{number},{response}]

このようにして、受信したメッセージがどの送信メッセージに対応するかを知ることが
でき、正しいハンドラーを呼び出すことができます。これによって応答メッセージの到
着順序を気にしなくても良くなります。

A newline character is terminating the JSON text.  This can be used to
separate the read text.  For example, in Python:
	splitidx = read_text.find('\n')
	message = read_text[:splitidx]
	rest = read_text[splitidx + 1:]

送信側はかならず有効なJSONをVimへ送らなければなりません。VimはJSONとして解釈す
ることで、受信メッセージの終端をチェックします。終端を受信することが、
メッセージを受理する唯一の方法です。A newline after the message is optional.

サーバープロセスがVimからのメッセージを受信すること無く、メッセージを送信する
には、数値に 0 を使う必要があります。
    [0,{response}]

するとチャンネルのハンドラーが {response} をVimの方に変換したものを受け取るで
しょう。チャンネルにハンドラーが関連付けられていない場合には、メッセージは破棄
されます。

It is also possible to use ch_sendraw() and ch_evalraw() on a JSON or JS
channel.  The caller is then completely responsible for correct encoding and
decoding.

==============================================================================
4. Vimコマンド						*channel-commands*

ま　だ　実　装　さ　れ　て　い　ま　せ　ん

"json" チャンネルを使用すると、サーバープロセス側はVimへコマンドを送信できま
す。そのコマンドはチャンネルのハンドラーを介さずに、Vimの内部で実行されます。

実行可能なコマンドは以下のとおりです: >
    ["ex",     {Ex コマンド}]
    ["normal", {ノーマルモードコマンド}]
    ["eval",   {数値}, {式}]
    ["expr",   {式}]

これらを使うときは、これらのコマンドが何をするかに十分気をつけてください!
ユーザーが何をしているかによっては容易に干渉してしまいます。トラブルを避けるに
は |mode()| を使い、エディタが期待した状態にあるかチェックしてください。例え
ば、コマンド実行ではなくテキストとして入力させたい文字列を送るには、以下のよう
にします: >
    ["ex","if mode() == 'i' | call feedkeys('ClassName') | endif"]

"ex" コマンドは Ex コマンドを実行します。完了やエラーの応答はありませ
ん。|autoload| スクリプトの中の関数を使えます。何かを入力するのに |feedkeys()|
を実行することもできます。

"normal" コマンドは |:normal| のように実行されます。

"eval" コマンドは式の評価結果を以下の様に返信します: >
	[{数値}, {result}]
{数値} は、リクエストに指定したのと同じものです。

"expr" コマンドはそれに近いのですが、応答を返信しません。例: >
	["expr","setline('$', ['one', 'two', 'three'])"]

==============================================================================
5. rawチャンネルを使う					*channel-raw*

{mode} が "raw" の場合には、以下のようにしてメッセージを送信します: >
    let response = sendraw(handle, {string})
{string} はそのまま送信されます。受信した応答メッセージは直ちにチャンネルから
読み込み可能になります。この時、Vimにはメッセージの終了をどう判断するかがわか
りませんから、あなた自身が面倒を見る必要があります。

応答を必要としないメッセージを送信するには以下のようにします: >
    call sendraw(handle, {string}, 0)
プロセス(訳注:サーバーのこと)はレスポンスを返し、チャンネルのハンドラーに渡さ
れます。

メッセージを送信し、レスポンスを特定の関数で非同期的に取り扱うには以下のように
します: >
    call sendraw(handle, {string}, {callback})

この {string} はJSONにもできます。その場合 |jsonencode()| それを作成し
|jsondecode()| で受信したJSONメッセージを取り扱います。

==============================================================================
6. ジョブ制御						*job-control*

ま　だ　実　装　さ　れ　て　い　ま　せ　ん

別のプロセスを開始するには: >
    call startjob({command})

これは {command} の終了を待ちません。

TODO:

    let handle = startjob({command}, 's')            # 標準入出力を使う
    let handle = startjob({command}, '', {address})  # ソケットを使う
    let handle = startjob({command}, 'd', {address}) # 接続に失敗したら開始


 vim:tw=78:ts=8:ft=help:norl:
