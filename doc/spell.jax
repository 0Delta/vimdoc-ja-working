*spell.txt*	For Vim バージョン 8.1.  Last change: 2018 Jan 29


		  VIMリファレンスマニュアル	  by Bram Moolenaar


スペルチェック						*spell*

1. はじめに			|spell-quickstart|
2. スペルチェックの注意点	|spell-remarks|
3. スペルファイルの生成		|spell-mkspell|
4. スペルファイルの形式		|spell-file-format|

{Vi にはこれらのコマンドはない}

コンパイル時に |+syntax| 機能を無効にした場合にはスペルチェックは利用すること
ができない。

Note: 他にも vimspell プラグインがある。そのプラグインを入れていれば ":help
vimspell" を実行することでそれについて調べることができる。しかし、おそらくその
プラグインを削除し、代わりにオプション 'spell' を使いたいと思うだろう。そちら
のほうがうまくいく。

==============================================================================
1. はじめに					*spell-quickstart* *E756*

このコマンドで、スペルチェックがオンになる: >

	:setlocal spell spelllang=en_us

これはオプション 'spell' をオンにし、アメリカ英語のチェックを指定する。

認識されない単語は以下のようにハイライトされる:
	SpellBad	認識されない単語			|hl-SpellBad|
	SpellCap	頭文字が大文字になっていない単語	|hl-SpellCap|
	SpellRare	まれな単語				|hl-SpellRare|
	SpellLocal	選択された地域では間違った綴り		|hl-SpellLocal|

Vim は単語の綴りのみをチェックし、文法はチェックしない。

もし、'mousemodel' オプションが "popup" にセットされてカーソルが間違った単語の
上にあるか、"popup_setpos" に設定されてマウスポインタが間違った単語の上にある
なら、ポップアップメニューは間違った単語を置き換えるサブメニューが含まれるよう
になる。Note: これはポップアップメニューの表示を遅くする。Note: GTKについては
メニューが現れるまでマウスの右ボタンを離してはいけない。そうしなければ機能しな
い。

次の綴りの間違った単語を探すには:

							*]s*
]s			カーソルの後の、次の綴りの間違った単語に移動する。コマ
			ンドの前に count を指定することで、繰り返しができる。
			'wrapscan' が適用される。

							*[s*
[s			"]s" と同様だが後方検索を行い、カーソルより前の綴りの
			間違った単語を探す。2行に渡った単語は認識しないため、
			間違いとしてハイライトされていない単語で止まることがあ
			る。行頭が大文字になっていない単語では止まらない。

							*]S*
]S			"]s" と同様だが、間違った単語のみで止まり、まれな単語
			や他の地域の単語では止まらない。

							*[S*
[S			"]S" と同様だが、後方検索を行う。


単語をあなた自身の単語リストに追加するには:

							*zg*
zg			カーソルの下の単語を正しい (good) 単語として、
			'spellfile' の最初のファイルに追加する。
			コマンドの前に count を指定することで、'spellfile' 内
			の項目を指定することができる。count として 2 を指定す
			ると、2 番目の項目が使われる。

			ビジュアルモードで選択された文字は単語として追加される
			(スペースを含む!)。
			カーソルが間違った綴りとしてマークされた文章の上にある
			時、そのマークされた文章が使われる。
			そうでなければ、単語ではない文字で分けられたカーソルの
			下の単語が使われる。

			もしその単語が明示的に別のスペルファイルで間違った単語
			としてマークされているなら、その結果は予測できない。

							*zG*
zG			"zg" と同様であるが、その単語を内部単語リスト
			|internal-wordlist| に加える。

							*zw*
zw			"zg" と同様であるが、間違った (wrong) 単語としてマーク
			する。もしその単語がすでに 'spellfile' にある場合は、
			コメント行に変更される。それらを取り除くには
			|spellfile-cleanup| を参照する。

							*zW*
zW			"zw" と同様であるが、その単語を内部単語リスト
			|internal-wordlist| に加える。

zuw							*zug* *zuw*
zug			|zw| や |zg| をundoして、'spellfile' の項目からその単
			語を削除する。count は |zg| と同様に使われる。

zuW							*zuG* *zuW*
zuG			|zW| や |zG| をundoして、内部単語リストからその単語を
			削除する。count は |zg| と同様に使われる。

							*:spe* *:spellgood*
:[count]spe[llgood] {word}
			|zg| と同様に、{word} を正しい単語として 'spellfile' に
			加える。count が無いときは最初の名前が使われ、count に
			2 を指定したときは 2 番目の項目が使われる。以下同様。

:spe[llgood]! {word}	|zG| と同様に、{word} を正しい単語として内部単語リスト
			に加える。

							*:spellw* *:spellwrong*
:[count]spellw[rong] {word}
			|zw| と同様に、{word} を間違った (wrong) 単語として
			'spellfile' に加える。count が無いときは最初の名前が使
			われ、count に 2 を指定したときは 2 番目の項目が使われ
			る。以下同様。

:spellw[rong]! {word}	|zW| と同様に、{word} を間違った (wrong) 単語として内
			部単語リストに追加する。

:[count]spellu[ndo] {word}				*:spellu* *:spellundo*
			|zuw| と同様である。[count] は |:spellgood| と同様に使
			われる。

:spellu[ndo]! {word}	|zuW| と同様である。[count] は |:spellgood| と同様に使
			われる。


上記のコマンドで 'spellfile' に単語を追加した後、その関連付けられた ".spl" ファ
イルは自動的に更新され再読み込みされる。もし手動で 'spellfile' を変更するなら
|:mkspell| コマンドを用いる必要がある。このコマンドの順序でたいていうまくいく:
>
	:edit <'spellfile' にあるファイル>
<	(スペルファイルに変更を加える) >
	:mkspell! %

'spellfile' の形式に関する詳細は下記の |spell-wordlist-format| を参照。

							*internal-wordlist*
内部単語リストは 'spell' がセットされた全てのバッファで使われる。内部単語リス
トは蓄えられず、Vim が終了する時に失われる。また 'encoding' がセットされた時に
クリアされる。


間違った単語に対しての提案を調べるには:
							*z=*
z=			カーソルの下や後の単語に対して正しい綴りの単語を提案す
			る。これはまた間違った単語としてハイライトされていない
			単語に対しての代わりを調べることもできる。例えば、その
			後の単語が間違っている場合など。
			ビジュアルモードでハイライトされたテキストは置換される
			単語として見なされる。
			結果は、置換されようとしている単語との類似度でソートさ
			れる。
			これには長い時間が掛かることがある。うんざりした場合は
			CTRL-C を打つこと。

			count なしでこのコマンドを使う場合、選択肢がリストアッ
			プされ、選びたい選択肢の番号を入力することができる。置
			き換えたくない場合は <Enter> を押す。また、マウスを使っ
			て選択肢をクリックすることもできる(マウスがノーマルモー
			ドで使われ、行の折り返しがない時のみ働く)。キャンセル
			するには最初の行(ヘッダー)をクリックする。

			リストアップされた提案はふつうハイライトされた間違った
			単語を置き換える。その提案は時々他のテキストを含むこと
			があるが、その場合は置き換えられるテキストが "<" の後
			にリストアップされる。

			count を用いた場合、プロンプトは出ずにその提案が使われ
			る。例えば、"1z=" は常に最初の提案を利用する。

			'verbose' が 0 以外の場合、間違った単語との類似度を示
			すスコアが提案と共に表示される。（高いスコアは、違いが
			大きいことを示す。）
			単語が置換された後は、リドゥコマンド "." はその単語の
			置換を繰り返す。これは、"ciw" の後に正しい単語を入力し
			<Esc> を入力したように動作する。これは、単語の間にス
			ペースを含まないタイ語やその他の言語に対しては動かな
			い。

					*:spellr* *:spellrepall* *E752* *E753*
:spellr[epall]		|z=| によって行われた置換を、現在のウィンドウの全ての
			マッチする単語に対して繰り返す。

挿入モードでは、カーソルが間違った綴りの単語の後にある場合、提案を見つけるため
に CTRL-X s を使うことができる。これは挿入モード補完のように動作する。次の提案
を使うには CTRL-N を、戻るには CTRL-P を使うこと。|i_CTRL-X_s|

オプション 'spellsuggest' は候補のリストがどのように生成、ソートされるかに影響
する。|'spellsuggest'| を参照せよ。

オプション 'spellcapcheck' は文の最初の単語が大文字で始まるかをチェックするの
に用いる。これはファイルの最初の単語には働かない。文の直後に改行があるとき、次
の行のハイライティングが後回しにされるかもしれない。必要であれば |CTRL-L| を使
用せよ。また、'spelllang' が設定される時にどのように自動で設定されるのかについ
ては |set-spc-auto| を参照せよ。

Vim は見つけた正しい単語の数を数える。これは提案候補をソートするのに使用される。
前に見つけた単語は小さな評価、よく見られる単語は大きな評価を得る。接辞ファイル
に共通する要素は共通の単語を定義するのに使用することができる。そのため、この機
構は新規もしくは小さいファイルでも機能する |spell-COMMON| 。

==============================================================================
2. スペルチェックの注意点				*spell-remarks*

性能

Vim はオンザフライのスペルチェックをする。スペルチェックを速くするために単語リ
ストはメモリにロードされる。だがこのために多くのメモリ(1 Mbyte以上)が使われる。
さらに、単語リストがロードされている時に著しい遅延が生じるかもしれない。これは
'spell' が既に設定されていたのに、'spell' を設定する時や 'spelllang' を設定す
る時に発生する。遅延を最小限にするには各単語リストが1回だけ読み込まれるように
する。そうすれば、'spelllang' が空になる時か 'spell' がリセットされる時に単語
リストは削除されない。'encoding' を設定して全ての単語リストが再読み込みされる
時に、上のようにまた遅延に気づくかもしれない。


地域

単語はそれぞれの地域で綴りが異なるかもしれない。例えば、英語は少なくともこれ
らの差異がある。

	en		全ての地域
	en_au		オーストラリア
	en_ca		カナダ
	en_gb		イギリス
	en_nz		ニュージーランド
	en_us		アメリカ

ある地域では使われないが別の地域では使われる単語は SpellLocal |hl-SpellLocal|
でハイライトされる。

常に言語名や地域名には小文字を使う。

|zg| や他のコマンドで単語が追加された時、その単語は常に全ての地域に追加される。
これは 'spellfile' を手動で編集することで変更できる。|spell-wordlist-format|
を参照せよ。'spellfile' にあるファイル内で指定される地域は'spelllang'にあるす
べてのエントリが同じ地域(.spl の名前によって特定されるファイルは数えない)を指
定するときにのみ使用されることに注意すること。

							*spell-german*
特有の例外: ドイツ語ではこれらの特別な地域が使われる:
	de		全てのドイツ語単語を許容する
	de_de		新旧正書法
	de_19		旧正書法
	de_20		新正書法
	de_at		オーストリア
	de_ch		スイス

							*spell-russian*
特有の例外: ロシア語ではこれらの特別な地域が使われる:
	ru		全てのロシア語単語を許容する
	ru_ru		"IE" letter spelling
	ru_yo		"YO" letter spelling

							*spell-yiddish*
イディッシュ語は特有の文字を使用するため、"utf-8" エンコーディングを使用する必
要がある。もし latin1 を使っているのなら、Vimは代わりに字訳された(ローマ字化さ
れた)イディッシュ語を使用するだろう。もしあなたが字訳されたイディッシュ語を
utf-8 で使用したいのなら、"yi-tr" を使用せよ。
一覧:
	'encoding'	'spelllang'
	utf-8		yi		イディッシュ語
	latin1		yi		ローマ字化されたイディッシュ語
	utf-8		yi-tr		ローマ字化されたイディッシュ語

							*spell-cjk*
中国語、日本語、あるいはその他の東アジアの文字に対するスペルチェックはサポート
されていないため、これらの文字は通常、エラーとしてマークされる。'spelllang' が
"cjk" を含んでいる場合、これらの文字はエラーとしてマークされなくなる。これは、
いくつかのアジアの単語が含まれるテキストを、スペルチェックを有効にして編集する
際に有用である。


スペルファイル						*spell-load*

Vim は 'runtimepath' のディレクトリの中の "spell" という名前のサブディレクトリ
にあるスペルファイルを探す。ファイル名は LL.EEE.spl のようになる:
	LL	言語名
	EEE	'encoding' の値

"LL" の値は 'spelllang' の値が使われるが、地域名は除外される。
例:
	'spelllang'	LL ~
	en_us		en
	en-rare		en-rare
	medical_ca	medical

'runtimepath' の中の最初のファイルだけがロードされる。これが成功した場合、
LL.EEE.add.spl という名前のファイルが追加でロードされる。追加ファイルは、見つ
かったものが全てロードされる。

スペルファイルが見つからなければ、自動コマンドイベント |SpellFileMissing| が発
生する。これによってスペルファイルをダウンロードする |spellfile.vim| プラグイ
ンを呼び出せる。

加えて、'spellfile' の名前に関連したファイルは読み込まれる。これらは |zg| や
|zw| で正しい単語や間違った単語を追加するファイルである。

例外:
- Vim は、'encoding' が "iso-8859-15" のとき "latin1" を使う。ユーロマークは
  スペルチェックに影響しない。
- 'encoding' 用のスペルファイルが見つからないときは "ascii" が試される。これは
  全ての単語が英語などの ASCII に近い言語に対してのみうまく働く。'encoding' が
  iso-8859-2 のように "latin1" でないときや英文を編集しているときに役に立つ。
  ".add" ファイルのために見つかったメインのスペルファイルとして同じ名前のファ
  イルが使用される。

例えば、以下の値が設定されている場合:
	'runtimepath' が "~/.vim,/usr/share/vim70,~/.vim/after"
	'encoding'    が "iso-8859-2"
	'spelllang'   が "pl"

Vim は以下を探す:
1. ~/.vim/spell/pl.iso-8859-2.spl
2. /usr/share/vim70/spell/pl.iso-8859-2.spl
3. ~/.vim/spell/pl.iso-8859-2.add.spl
4. /usr/share/vim70/spell/pl.iso-8859-2.add.spl
5. ~/.vim/after/spell/pl.iso-8859-2.add.spl

ここでは、1. が見つからず、2. が見つかったと仮定している。

もし 'encoding' が "latin1" ならば Vim は以下を探す:
1. ~/.vim/spell/pl.latin1.spl
2. /usr/share/vim70/spell/pl.latin1.spl
3. ~/.vim/after/spell/pl.latin1.spl
4. ~/.vim/spell/pl.ascii.spl
5. /usr/share/vim70/spell/pl.ascii.spl
6. ~/.vim/after/spell/pl.ascii.spl

これはこれらが見つからないことを想定する(ポーランド語は non-ASCII 文字を抜くと
意味をなさない)。

EBCDIC 向けのスペルチェックは現在サポートされていない。

現在の 'encoding' でスペルファイルが利用できないかもしれない。スペルファイルの
作成の仕方については |spell-mkspell| を参照せよ。"iconv" でスペルファイルを変
換するのは機能しないだろう!

Note: VMS ではファイル名によるトラブルを避けるため、".{enc}.spl" は
"_{enc}.spl" に変更されている。

						    *spell-sug-file* *E781*
もしまさしく同じ名前の ".spl" ファイルがあるが、その最後に ".sug" がついていな
いのであれば、このファイルはよりよいサジェスチョンを与えるのに使われる。メモリ
の使用率を減らすため、サジェスチョンが作られる前には読み込まれない。

				    *E758* *E759* *E778* *E779* *E780* *E782*
スペルファイルを読み込む時、Vim はそれが正しくフォーマットされているかチェック
する。もしエラーが生じたなら、そのファイルが不完全であるか、変更されているか、
Vim の他のバージョン向けのものかもしれない。


スペルファイルのクリーンアップ				*spellfile-cleanup*

|zw| コマンドは 'spellfile' に存在するエントリをコメント行に変更する。これは毎
回新しいファイルに書き込まれることを避けるが、結果としてファイルは長くなるのみ
で短くなることはない。すべての ".all" スペルファイル内のコメント行をクリーンアッ
プするには次のようにする: >
	:runtime spell/cleanadd.vim

これは行頭が "##" で始まるものを除いて、すべてのコメント行を削除する。保持して
おきたいコメントには "##" を使う。

好きなだけ、このスクリプトを呼び出すことができる。直近で変更されたファイルのアッ
プデートをスキップするための変数を提供している。そのファイルが最後に変更されて
からクリーンアップされるまでの秒数を設定する。例えば、この1時間で変更されなかっ
たファイルだけをクリーンアップするには次のようにする: >
      let g:spell_clean_limit = 60 * 60
デフォルトでは1秒。


単語

Vim は単語を認識するのに定型的な方法を使う。これは 'iskeyword' とは独立してい
るので、ヘルプファイル内や 'iskeyword' 内に '-' のような文字を含む言語に対して
も機能する。この単語の文字は 'encoding' に依存する。

単語の文字テーブルはメインの .spl ファイルに保存される。それゆえ .spl ファイル
を生成するときの現在のロケールがなんであるかが重要である! 従って .add.spl ファ
イルは単語テーブルを含まない。

数字で始まる単語に関しては、全体で単語であると認識するまで先頭の数字は無視され
る。したがって、もし "3D" が一つの単語で "D" が単語でないのなら、"3D" は単語と
して認識される。しかし、もし "3D" が単語で無ければ "D" は不正としてマークされ
る。0x12ab や 0X12AB のような16進数は認識される。


単語の組み合わせ

スペースを含む単語のスペルチェックが可能である。これは例えば、"et al." のよう
な単語によって使われる場合に無効な単語を認識するために使われる。これは更に
"the the" を評価したり、ハイライトするために使われる。

スペースの個数は無関係だ。多くの場合、改行が現れるかもしれない。しかしながら、
これはスペルミスのチェックを開始する場所を見つけるのを困難にする。あなたが1行
の変更をし、その行が再描画されただけであれば、Vim は前の行を見ない。それゆえ、
前の行の最後が "et" であると "al." はエラーとみなされる。また、"the<CR>the" と
タイプしたときは初めの行が再描画されるまでハイライトされない。すぐに再描画を行
うには |CTRL-L| を使う。"[s" は改行を含む単語にも止まる。

改行があると、Vim は '*' や '>'、'"' のような単語をスキップするので、C、シェル、
Vim コードでのコメントをスペルチェックすることができる。


構文ハイライト						*spell-syntax*

構文ハイライトを使用するファイルでは、どこでスペルチェックを行うべきか指定する
ことができる:

1.  どこでも			   既定
2.  指定の要素			   "contains=@Spell" を使用する
3.  指定の要素以外どこでも	   "contains=@NoSpell" を使用する

@NoSpell クラスタを追加する2番目の方法はスペルチェックを再度無効にすることだろ
う。これが使われれば、例えば @Spell をプログラムのコメントに加えたり、チェック
するべきでないアイテムを @NoSell に追加できる。シンタックスアイテムにないテキ
ストについては、|:syn-spell| を参照。


Vim script

スペルに関するVim script を書きたいと思うと、これらの関数が役に立つことが分
かるだろう:

    spellbadword()	カーソル下の間違ったつづりの単語を見つける
    spellsuggest()	正しいつづりの候補を得る
    soundfold()		同音(sound-a-like)の単語を得る


'spellcapcheck' の自動設定				*set-spc-auto*

'spelllang' オプションがうまく設定された後は、Vim は　'runtimepath' にある
"spell/LANG.vim" ファイルを読み込む。"LANG" は 'spelllang' が初めのコンマ、ドッ
ト、またはアンダースコアーまでの値である。これは言語のための特別なオプション、
とりわけ 'spellcapcheck' を設定するのに使われる。

ディストリビューションはこれらのファイルをいくつか含んでいる。これらが何をして
いるかを知るためには次のコマンドを使う >
	:next $VIMRUNTIME/spell/*.vim

Note: デフォルトのスクリプトは初期値が変更されているなら 'spellcapcheck' を設
定しない。これはユーザーが好む値を設定することを想定する。


二重スコア付け						*spell-double-scoring*

"double" 方式のスコア付けを選択するために 'spellsuggest' オプションを使用でき
る。この機構は、綴り間違いには2種類あるという原則に基づいている:

1. 単語の綴りは知っているが、何らかのミスタイプをする場合。これは小さな編集に
   よる変更 (文字の入れ替わり/文字抜け/文字の混入) の結果であり、単語は完全に
   間違っているようにみえるかもしれない。

2. 単語の綴りを知らず、単語が正しく聞こえるようにタイプする場合。
   編集による差異は大きくなり得るが、単語は後の sound-folding と同様である。

これら2つの間違いのスコアは大きく異なるので、互いに1つのリストを使って、組み合
わせる。

sound-folding は遅く、言語を知っている人は2種類の間違いをしたくないだろう。そ
れゆえ、'spellsuggest' にサジェスチョンのスコアリングに用いる好きな方法を設定
できる。

==============================================================================
3. スペルファイルの生成					*spell-mkspell*

Vimはつづりのためのバイナリフォーマットを使用する。このことにより単語リストの
読み込みを大幅に速くし、単語リストを小さく保つ。
						    *.aff* *.dic* *Myspell*
Myspell が使用する .aff と .dic ファイルからVimが使用するスペルファイルを生成
することができます。Myspell は OpenOffice.org と Mozilla によって使用されます。
OpenOffice の .oxt ファイルは .aff と .dic ファイルを含む zip ファイルです。こ
れらはここから探すことができる。
	http://extensions.services.openoffice.org/dictionary
これが機能しない場合、以前の OpenOffice 2 のファイルが使用されることがある。
	http://wiki.services.openoffice.org/wiki/Dictionaries
加えて、プレーンテキストの単語リストも使用できます。選択肢はあなたが見つけた単
語のリストによって決まり、結果は同じになる。

Aap (www.a-a-p.org) をインストールしたのなら、runtime/spell/??/ ディレクトリで
レシピを使用することができる。Aap はファイルをダウンロードし、Vim に必要なパッ
チを適用し .spl ファイルをビルドする。

現在のロケールが適切に設定されているか確認してください。適切に設定がなされてい
ない場合、Vim は 大文字と小文字の区別ができない。もしロケールが利用できない場
合 (例えば Unix 上で MS-Windows コードページを使用している場合) は .aff ファイ
ルにテーブルを追加してください |spell-affix-chars| 。.aff ファイルがテーブルを
定義していないなら、現在有効なスペリングのテーブルが使われる。スペリングが有効
でないなら Vim はスペリングを推測しようとする。

							*:mksp* *:mkspell*
:mksp[ell][!] [-ascii] {outname} {inname} ...
			単語リストからVimスペルファイルを生成する。例: >
		:mkspell /tmp/nl nl_NL.words
<								*E751*
			{outname} が ".spl" で終わっている場合、出力ファイル名
			として使われる。そうでなければ、地域名を除いた "en" の
			ような言語名が使われる。書き込まれたファイルは
			"{outname}.{encoding}.spl" とない、{encoding} には
			'encoding' オプションの値が入る。

			出力ファイルがすでに存在する場合は、上書きするために
			[!] を使用しなければならない。

			[-ascii] 引数が存在している場合は、non-ascii 文字で構
			成された単語がスキップされる。結果のファイルは
			"ascii.spl" で終わる。

			入力は Myspell 形式の {inname}.aff と {inname}.dic ファ
			イルが使用できる。もし {inname}.aff が存在していなけれ
			ば、{inname} はプレーン単語リストのファイル名として使
			われる。

			複数の {inname} 引数を使うと、1つの Vim スペルファイル
			に複数の地域の組み合わせを与えることができる。例: >
		:mkspell ~/.vim/spell/en /tmp/en_US /tmp/en_CA /tmp/en_AU
<                        これはUS, CA そしてAUの英単語リストの組み合わせを1つの
			en.spl.file にする。
			8つの地域まで組み合わせることができる。*E754* *E755*
			上記のコマンドで出現する .aff ファイルの初めにある REP
			と SAL 項目が使われる。|spell-REP| |spell-SAL|
								*E845*
			このコマンドは多くのメモリを使用し、最適な単語ツリーを
			見つけることが求められる (ポーランド語、イタリア語、ハ
			ンガリー語は数百バイトのメモリを要求する)。最終的な結
			果は圧縮が使用されるので、非常に小さくなるだろう。メモ
			リ外で動作しないようにするため、圧縮は適便行われる。こ
			れは 'mkspellmem' オプションで設定できる。

			バッファ内でスペルファイルが書き込まれた後、使われ始め
			ると自動的に再読み込みされる。

:mksp[ell] [-ascii] {name}.{enc}.add
			上記の ":mkspell" と似ている。入力ファイルとして
			{name}.{enc}.add を使用すると、同じディレクトリに
			".spl" が付加された出力ファイルが生成される。

:mksp[ell] [-ascii] {name}
			上記の ":mkspell" と似ている。入力ファイルとして {name}
			を使用すると、同じディレクトリに ".{enc}.spl" が付加さ
			れた出力ファイルが生成される。

Vim は重複した単語の出現回数を報告する。これは単語リスト中の誤りであるかもしれ
ない。しかし、時には同じ基本単語に対して、結合しないようにするために異なる接頭
辞と接尾辞が使用される (例えば、チェコ語はこれを使う)。もしすべての重複する単
語を Vim に報告させたい場合は、'verbose' オプションを設定する。

Vim で使うために Myspell の単語リストを変更したいならば、次のような手順で行う
ことをお薦めする:

1. Myspell から xx_YY.aff と xx_YY.dic ファイルを入手する。
2. これらのファイルを xx_YY.orig.aff と xx_YY.orig.dic のようにコピーする。
3. 良くない単語を取り除くために xx_YY.aff とxx_YY.dic ファイルを変更し、足りな
   い単語を加え、FOL/LOW/UPP の単語を定義したりする。配布されている "*.diff"
   ファイルを使用できる。
4. Vim を正しいロケールで起動し、Vim スペルファイルを生成するために |:mkspell|
   を使う。
5. 'runtimepath' 内のスペルファイルディレクトリに書き込むなら、
   "set spelllang=xx" でスペルファイルを試してみる。その他のディレクトリに書き
   込む場合は、":set spelllang=xx.enc.spl" を試す。

Myspell ファイルが更新されたとき、差異をマージすることができる:
1. 新しい Myspell ファイルを xx_YY.new.aff と xx_UU.new.dic として取得する。
2. 変更箇所を確認するために Vimdiff を使う: >
	vimdiff xx_YY.orig.dic xx_YY.new.dic
3. xx_YY.dic の変更点を引き継ぐ
   xx.YY.aff の変更点も必要とするかもしれない。
4. xx_YY.new.dic を xx_YY.orig.dic へ、xx_YY.new.aff を xx_YY.new.aff へリネー
   ムする


スペルファイルのバージョン				*E770* *E771* *E772*

スペルチェックは Vim の比較的新しい機能なので、.spl ファイル形式はより多くの言
語をサポートするために変更されるかもしれない。Vim はスペルファイルの有効性を確
認し、間違いがあれば報告する。

	E771: Old spell file, needs to be updated ~
スペルファイルが使用している Vim のバージョンよりも古いものなので、.spl ファイ
ルを更新する必要がある。

	E772: Spell file is for newer version of Vim ~
これはスペルファイルが使用している Vim よりも新しいバージョンに対応したものな
ので、Vim を更新する必要があることを意味する。

	E770: Unsupported section in spell file ~
これはスペルファイルが使用している Vim よりも新しいバージョンに対応したもの
で、スペルファイルを動作させるために必要なセクションを含むことを意味する。この
場合は、Vim を更新することが良い考えとなるだろう。


スペルファイルのダンプ

もし何らかの理由で、現在使っているスペルファイルでどんな単語がサポートされてい
るかをチェックしたい場合、以下のコマンドを使用できる:

							*:spelldump* *:spelld*
:spelld[ump]		新規ウィンドウを開き、すべての有効な単語で埋め尽くす。
			複合語は含まれない。
			Note: いくつかの言語では、結果が非常に大きくなり、Vim
			がメモリ不足を引き起こすかもしれない。

:spelld[ump]!		":spelldump" と同様に、単語数を含む。これは画面を更新
			している間に発見した単語の個数である。COMMON アイテム
			にある単語は10から数えられる。

単語リストの形式は |spell-wordlist-format| が使われる。全ての単語を含む1つの
.spl ファイルを生成するために、":mkspell" で読み込むことができるようにすべきだ。

すべての 'spelllang' に対するエントリが同じ地域を使用しているか、または全く地
域使用しない場合、地域情報がダンプワードに含まれる。そうでなければ、現在の地域
に関する単語のみが含まれ、"/regions" 行は生成されない。

.spl ファイルの名前を持つコメント行は、.spl ファイルから生成された単語の上記の
ヘッダーとして使われる。


スペルファイルがないとき	*spell-SpellFileMissing* *spellfile.vim*

使用している言語のスペルファイルが利用できないならば、エラーメッセージを受け取
るだろう。しかし、"spellfile.vim" プラグインがアクティブであるならば、スペルファ
イルをダウンロードするように薦められる。指示に従ったのならば、プラグインはダウ
ンロードしたスペルファイルを保存する場所を尋ねるだろう (このため、
'runtimepath' 内の書き込み可能な場所でなければならない)。

プラグインは、Vim ftp サーバー上にスペルファイルを探すデフォルトの場所を持つ。
他の場所や他のプロトコルを使用したいならば、スペルファイルが存在するディレクト
リに対して、g:spellfile_URL を設定する。|netrw| プラグインはファイルを取得する
ために使われ、そこに URL の特定の構文があるかを調べる。例: >
	let g:spellfile_URL = 'http://ftp.vim.org/vim/runtime/spell'
特殊文字をエスケープする必要があるかもしれない。

このプラグインは一度、ある1つの言語をダウンロードすることについてのみ質問する
だろう。もし再度行おうとする場合は、Vim を再起動するか g:spellfile_URL を他の
値 (例えば、スペースを前置する) に設定する。

"spellfile.vim" プラグインの使用を避けるためには、vimrc ファイルないで次のよう
にする: >

	let loaded_spellfile_plugin = 1

プラグインを使用するかわりに 欠落したファイルを扱うために |SpellFileMissing|
自動コマンドを定義することができる。次のように使う: >

	:au SpellFileMissing * call Download_spell_file(expand('<amatch>'))

それゆえ <amatch> アイテムは言語の名前を含む。もう一つの重要な値はどのエンコー
ディングも自分自身のスペルファイルがあるので 'encoding'である。2つの例外: >
- ISO-8859-15 (latin9) の場合、"latin1" という名前が使用される (このエンコーディ
  ングでのみ、辞書の単語で使用されていない文字が異なる。)。
- "ascii" という名前は単語の多くで ASCII 文字のみを使用するいくつかの言語につ
  いて使われることがある。

デフォルトの "spellfile.vim" プラグインはこの自動コマンドを使う。もし後で自分
の自動コマンドを定義するなら、これを無効にするために ":au! SpellFileMissing"
を使いたいかもしれない。プラグインが読み込まれる前に自分の自動コマンドを定義す
る場合は、これを警告し、また何もしないだろう。
							*E797*
Note SpellFileMissing 自動コマンドはユーザーが編集しているバッファを変更や削除
してはいけない。

==============================================================================
4. スペルファイルの形式					*spell-file-format*

これは単語リストを作成、管理する人が使うファイルのフォーマットである。

Note ここでは辞書 ("dictionary") という単語の使用を避ける。スペルチェックの目
的は (本のような) 辞書を書くこととは違うからだ。スペリングのために、間違いのな
い単語のリストが必要となる。それゆえ、ハイライトされるべきではない。人と会社の
名前は辞書内に現れることはないが、単語リストには現れる。共通のミススペルとして
まれに古い単語が使われる。これらは辞書には現れるが、単語リストには現れない。

2つのフォーマットがある: 単語の率直なリストと接辞圧縮を使ったリストである。接
辞圧縮を使ったファイルは Myspell (Mozilla and OpenOffice.org) によって使われる。
これは2つのファイルを必要とし、1つは .aff、もう1つは .dic の拡張子をもつファイ
ルだ。


率直な単語リストのフォーマット				*spell-wordlist-format*

単語は1行に1つずつ現れなければならない。これが必要とされることのすべてだ。

加えて、次の項目が評価される:

- 何もない、もしくは空行は無視される。

	# comment ~
- # で始まる行は無視される (コメント行)。

	/encoding=utf-8 ~
- どんな単語よりも前でにある "/encoding=" で始まる行はファイルのエンコーディン
  グを指定する。'=' の後にはエンコーディング名がくる。これは Vim に指定された
  エンコーディングから 'encoding' への変換のセットアップをするように伝える。そ
  れゆえ1つの単語リストを複数のエンコーディング向けに使うことができる。

	/regions=usca ~
- "/regions=" で始まる行はサポートする地域の名前を指定する。どの地域も2つの
  ASCII 文字でなければならない。その1めは地域 1。それゆえ "/regions=usca" は地
  域 1の "us" と地域 2の "ca" を持つ。加えて、単語リストの地域名は主となる単語
  リストと同じでなければならない!

- それ以外の '/' で始まる行は、今後使うために予約されている。評価されない行は
  無視される。警告のメッセージを受け取るので、動作しないのが何かを知ることがで
  きる。

- "/" は下記の項目にある単語を伴うことができる。
    =		ケースは正確にマッチしなければならない。
    ?		珍しい単語
    !		悪い (誤った) 単語
    1 to 9	単語が有効である地域。地域が指定されていないならば、すべての地
		域で単語が有効である。

例:

	# 単語リストの例			コメント
	/encoding=latin1			ファイルのエンコーディング
	/regions=uscagb				地域 "us", "ca", "gb"
	example					全ての地域の単語
	blah/12					"us", "ca" 地域の単語
	vim/!					誤った単語
	Campbell/?3				地域 3 "gb" での珍しい単語
	's mornings/=				ケースを伴った単語

Note "/=" が使われたとき、すべてが大文字の同じ単語は受理されない。これは自動的
にケースを保ったものとしてマークされた大文字小文字が混ざった単語とは異なる。こ
れらの単語はすべての文字が大文字であるように見えるだろう。


.AFF と .DIC ファイルのフォーマット			*aff-dic-format*

2つのファイルがある: 基本の単語のリストと接辞ファイルだ。接辞ファイルは言語の
設定を指定し、接辞を含むことを可能にする。接辞は十分な単語リストを得るために、
基本単語を修正するのに使われる。このことは特にポーランド語のような言語において
著しく単語の数を減らす。これは接辞圧縮と呼ばれる。

基本の単語リストと接辞ファイルは ":mkspell" コマンドで結び付けられ、その成果は
バイナリのスペルファイルになる。すべての前処理が完了すると、ファイルの読み込み
は高速になる。バイナリのスペルファイルのフォーマットはソースコード
(src/spell.c) に書き込まれている。しかし、このことについて知る必要があるのは開

前処理はまた 私達がMyspell 言語ファイルを取得し、Vim の単語リストが作られる前
に変更することを許す。これらのツールは "src/spell" ディレクトリで見つけること
ができる。

接辞と単語リストファイルのフォーマットは Myspell が使用しているもの (Mozillaと
OpenOffice.org のスペルチェッカー) に基づく。説明書は次の場所で見つけることが
できる。
	http://lingucomponent.openoffice.org/affix.readme ~
Note 接辞は大文字小文字を区別することに注意。これは説明書からははっきりとわか
らない。

Vim は多数の拡張をサポートしている。これらは以下の |spell-affix-vim| で説明さ
れている。他のスペルチェッカーと互換性を保つように作られているので、同じファイ
ルがしばしば使われる。Myspell を超えるもう一つのプロジェクトの1つに　Hunspell
( http://hunspell.sf.net ) がある。


単語リストのフォーマット			*spell-dic-format*

行番号をつけた簡潔な例:

	1	1234 ~
	2	aan ~
	3	Als ~
	4	Etten-Leur ~
	5	et al. ~
	6	's-Gravenhage ~
	7	's-Gravenhaags ~
	8	# 地域間で異なる単語~
	9	kado/1 ~
	10	cadeau/2 ~
	11	TCP,IP ~
	12	/the S affix may add a 's' ~
	13	bedel/S ~

最初の行は単語の数が含まれている。Vim はこれを無視するが、ここにこれがない場合
はエラーメッセージを受け取る。*E760*

これに続くのは、1行につき1つの単語。行末の空白は無視され、その他の空白は問題と
なる。エンコーディングは接辞ファイル内で指定される |spell-SET|。

コメント行は '#' か '/' で始まる。例の8行目と12行目を参照。Note 単語の後ろにコ
メントを書くことは許可されていないことに注意:

		someword   # comment that causes an error! ~

単語の後にはオプションのスラッシュとフラグがある。フラグのほとんどは、その単語
で使用できる接辞を示す文字である。.aff ファイルの SFX や PFX 行で指定されてい
る。|spell-SFX| と |spell-PFX| を参照。Vim では接辞ファイルの FLAG 項目で、ほか
の形式のフラグを使ってもよい |spell-FLAG|。

単語が小文字のみである場合、大文字で始まる単語にもマッチするだろう。

単語が大文字を含んでいる場合、その場所に大文字が必要とされていることを意味する。
その場所が小文字である同じ単語はマッチしないだろう。他の文字が大文字である場合
もマッチしない。

すべてが大文字の単語はいつも OK になるだろう。
The word with all upper-case characters will always be OK,

	単語リスト	マッチする		マッチしない~
	als		als Als ALS		ALs AlS aLs aLS
	Als		Als  ALS		als ALs AlS aLs aLS
	ALS		ALS			als Als ALs AlS aLs aLS
	AlS		AlS ALS			als Als ALs aLs aLS

KEEPCASE の接辞 ID は特定のケースのマッチ指定に使うことができる。下記の
|spell-KEEPCASE| を参照。

Note: 5 から 7 行目は単語ではない文字が使われていることに注意。単語にはどのよ
うな文字でも含めることができる。テキストをチェックする際に、単語の前後に単語で
はない文字が現れたときにのみマッチする。Myspell は単語ではない文字で始まる単語
ではたぶん動作しないだろう。

12 行目に "TCP/IP" が定義されている。スラッシュには特別な意味があるので、代わ
りにコンマが使われる。これは接辞ファイルの SLASH 要素に定義されている。
|spell-SLASH| を参照。Note SLASH 要素なしでは、単語は "TCP,IP" となるだろう。


接辞ファイルフォーマット		*spell-aff-format* *spell-affix-vim*

							*spell-affix-comment*
.aff ファイルのコメント行は '#' で始まる:

	# comment line ~

引数の固定された要素はコメントによって続けることができる。しかし、引数がない場
合に限り空白を含むことができる。コメントは "#" 文字で始まらなければならない。
例:

	KEEPCASE =  # fix case for words with this flag ~


エンコーディング						*spell-SET*

接辞ファイルは "iconv" によってサポートされているエンコーディングであれば、ど
のようなものでもよい。しかしながら、いくつかの場合で現在のロケールはまた、プロ
パティを |:mkspell| が呼び出された時に設定されるべきだ。加えて、 FOL/LOW/UPP
行は |spell-FOL| の要求を削除する。

エンコーディングに関するものの何よりも前にエンコーディングは指定されるべきだ。
エンコーディングは接辞ファイルと辞書ファイルの両方に適用される。これは SET 行
において行われる。

	SET utf-8 ~

エンコーディングは ":mkspell" が使われた時に 'encoding' オプションにセットされ
た値とは異なっていてもよい。Vim はすべてを 'encoding' に変換し、'encoding' に
関係するスペルファイルを生成するだろう。もしも 'encoding' に適合していない文字
が使われているなら、エラーメッセージを受け取るだろう。
							*spell-affix-mbyte*
マルチバイトのエンコーディングが使われている場合、より多くの異なった接辞フラグ
を使うことができる。しかし、Myspell はこれをサポートしないので、これをどのよう
な方法でも使おうとはしないかもしれない。互換性のために 8-bit エンコーディング
を使う。


情報

接辞ファイルのエントリは、スペルファイルに情報を追加するのに使うことができる。
フォーマットに制限はないが、正しいエンコーディングであるべきだ。

				*spell-NAME* *spell-VERSION* *spell-HOME*
				*spell-AUTHOR* *spell-EMAIL* *spell-COPYRIGHT*
	NAME		言語名
	VERSION		1.0.1  with fixes
	HOME		http://www.myhome.eu
	AUTHOR		John Doe
	EMAIL		john AT Doe DOT net
	COPYRIGHT	LGPL

これらのフィールドは .spl ファイルにそのままの状態で置かれる。|:spellinfo| コ
マンドは info を閲覧するために使われる。

							*:spellinfo* *:spelli*
:spelli[nfo]		現在のバッファで使われているスペルファイルの情報を表示
			する。


文字テーブル
							*spell-affix-chars*
8-bit エンコーディングを使う場合、接辞ファイルは、単語の文字が何であるかを定義
するべきだ。これはどうしてかというと、":mkspell" が使われたシステムはこのエン
コーディングのロケールをサポートしていないかもしれないし、 isalpha() が動作し
ないだろうからだ。例えば Unix 上で "cp1250" を使う場合である。
						*E761* *E762* *spell-FOL*
						*spell-LOW* *spell-UPP*
接辞ファイルの3行は必要だ。簡単な例:

	FOL  áëñ ~
	LOW  áëñ ~
	UPP  ÁËÑ ~

3 行すべては全く同じ文字番号を持っていなければいけない。

"FOL" 行は case-folded 文字を指定する。これらは大文字小文字を区別しない単語の
比較に使われる。ほとんどのエンコーディングでは、小文字の行と同じである。

"LOW 行は lower-case 文字を指定する。大部分は "FOL" 行に等しい。

"UPP" 行は upper-case 文字を指定する。これは "FOL" の同じ場所にある文字とは異
なる大文字である。

An exception is made for the German sharp s ß.  The upper-case version is
"SS".  In the FOL/LOW/UPP lines it should be included, so that it's recognized
as a word character, but use the ß character in all three.

ASCII 文字は省略されるべきだ。Vim は常に同じ方法でこれらを扱う。エンコーディン
グが UTF-8 である場合、単語文字の指定は必要ない。

							*E763*
Vim は同じファイルでいくつかの言語のスペルチェックを使うことを許可する。
'spelllang' オプションでこれらを列記できる。結果として、同じエンコーディングに
対するすべてのスペルファイルは同じ単語文字を使用しなければならない。そうでなけ
れば、これらをエラーなしに結合できない。

もし単語テーブルが異なるという警告 E763 を受け取ったのなら、".spl" スペルファ
イルをアップデートする必要がある。ファイルをダウンロードした場合、使用している
すべてのスペルファイルの最新版を取得しよう。もしも1つの言語だけを使っているな
らば、例えばドイツ語、さらに最新の英語スペルファイルをダウンロードしよう。そう
でなければ、再度 |:mkspell| で .spl ファイルを生成しよう。もしエラーを受け取っ
たのであれば、 使用している .aff ファイルの FOL と LOW、UPP 行を確認しよう。

"-ascii" 引数で生成される XX.ascii.spl スペルファイルは文字テーブルを含まない
だろう。そのため、どんなエンコーディングのスペルファイルとも結合することができ
る。加えて .add.spl ファイルはテーブルを含まない。


中間語の文字
							*spell-midword*
いくつかの文字は、普通の単語文字の間で使われているなら、単に単語文字だとみなさ
れる。一例はシングルクォートだ: テキストを引用するのにしばしば使われる。それゆ
えその単語は一語の文字として認識されない。しかし、単語文字の間に現れた場合、単
語の一部にならなければならない。これは they'are のようなスペルミスを検出するた
めに必要だ。they're になるべきだが、"they" と "are" はそれ自身が単語であるので、
気づかれないだろう。

これらの文字は .aff ファイルの MIDWORD で定義される。例:

	MIDWORD	'- ~


フラグタイプ						*spell-FLAG*

フラグは単語と共に使われる接辞や単語の他の特徴を指定するために使われる。通常は
シングルキャラクタのフラグが使われる。これは受け入れられるフラグの数、特に 8
ビットエンコーディングで、制限する。より多くの接辞が使われるならば、フラグ項目
は使われることがある。取りうる値:

	FLAG long	2 文字フラグを使う
	FLAG num	1 から 65000 までの数値を使う
	FLAG caplong	A-Z を除く 1 文字フラグと A-Z で始まる 2 文字フラグを
			使う

接辞リストにおける "FLAG num" の値は、コンマで区切られている必要がある:
"234,2143,1435"。この方式は非効率的だが、ファイルをプログラムで生成する場合に
は便利である。

"caplong" を使う場合、2 文字フラグは "Aa", "B1", "BB" などのようにすべて大文字
で始まる。これは多くの共通項目に関する 1 文字フラグと 非共通項目に関する 2 文
字フラグを使うのに便利である。

Note: UTF-8 を使用している場合、65000 までの文字だけがフラグとして使われるだろ
う。

Note: "num" や "long" を使用している時でさえ、フラグの数値を混ぜることができ、
接頭辞は約 250 に制限される。


接辞
					    *spell-PFX* *spell-SFX*
PFX (接頭辞) と SFX (接尾辞) 行がサポートされている (Myspell のドキュメント、
もしくは Aspell のマニュアルを参照:
http://aspell.net/man-html/Affix-Compression.html).

概要:
	SFX L Y 2 ~
	SFX L 0 re [^x] ~
	SFX L 0 ro x ~

最初の行はヘッダーで 4 つのフィールドを持つ:
	SFX {flag} {combine} {count}

{flag}		接尾辞に使われる名前。たいていは 1 文字だが、他の文字も使うこ
		とができる。|spell-FLAG| を参照。

{combine}	'Y' か 'N' である。'Y' の場合、単語 + 接尾辞はさらに接頭辞を持
		つことができます。'N' の場合、接頭辞を持つことはできない。

{count}		次に続いている行数。これが間違っている場合、エラーメッセージを
		受け取るだろう。

PFX のためのフィールドは全く同じである。

次に続いている行数の基本的なフォーマットは:
	SFX {flag} {strip} {add} {condition} {extra}

{flag}		最初の行で使われている {flag} と同じでなければならない。

{strip}		基本単語から削除された文字。文字が実際にあるなら、チェックせず、
		(バイトの) 長さだけが使われる。これは {condition} のより良いマッ
		チで、これ以外の方法ではおかしなことが起こる。{strip} の長さが
		基本語と等しいかそれ以上なら、接尾辞は使われないだろう。{strip}
		が 0 (zero) の場合は何も取り除かない。

{add}		{strip} を取り除いた後の基本単語に加えられた文字。オプションに
		フラグに続く '/' がある。フラグは単語に接辞を付け加える。
		|spell-affix-flags| を参照。

{condition}	単純なパターン。これが基本語とマッチした場合のみ、その単語に対
		してのみ接尾辞が使われるだろう。通常、これは異なる
		エンコーディングの単語のための {add} や {strip} フィールドと異
		なり、接尾辞が使われる。
		{condition} が . (ドット) である場合は条件はない。
		パターンは次のものを含む:
		- リテラル文字。
		- [] 内の文字セット。[abc] は a, b, c にマッチする。[a-c] の範
		  囲のためにダッシュが使えるが、これは Vim に特有のものである。
		- ^ で始まる文字セットは特定の文字を補完することを意味する。
		  [^abc] は a, b, c を除いた全ての文字にマッチする。

{extra}		オプションの特別なテキスト
		    # comment		コメントは無視される
		    -			Hunspell はこれを使い、無視される

PFX 向けにはフィールドは同じであるが、{strip}、{add}、{condition} は単語のはじ
めに適用する。

Note: Myspell は関連情報の後にある特別なテキストはどんなものでも無視する。Vim
は "#" で始まるこの行を必要とする。そのため、間違いは気づかれずには済まない。
例:

	SFX F 0 in   [^i]n      # Spion > Spionin  ~
	SFX F 0 nen  in		# Bauerin > Bauerinnen ~

しかしながら、Myspell のために書かれた接辞ファイルの多くのエラーを回避するため
に、IGNOREEXTRA フラグを加えることができる。

明らかに Myspell は一度ならず何度も接辞名が現れることを許す。これは間違いかも
しれないので、Vim は特別な "S" をチェックする。この機能を使う Myspell のための
接辞ファイルは、明らかにこのフラグを持つ。例:

	SFX a Y 1 S ~
	SFX a 0 an . ~

	SFX a Y 2 S ~
	SFX a 0 en . ~
	SFX a 0 on . ~


接辞フラグ						*spell-affix-flags*

これは Hunspell 由来の機能: 接辞はフラグを明記するかもしれない。基本語を明示す
るフラグと同じように動作する。フラグは基本語に接辞 (制限付きの) を加えるように
適用する。例:

	SFX S Y 1 ~
	SFX S 0 s . ~

	SFX A Y 1 ~
	SFX A 0 able/S . ~

辞書ファイルが "drink/AS" を含む場合、これらの単語が適合する。

	drink
	drinks		S suffix を使う
	drinkable	A suffix を使う
	drinkables	A suffix を使い、それから S suffix を使う

一般に、接尾辞のフラグは基本語のフラグに付加され、どちらのフラグも基本語に接尾
辞を加えるために使われる。しかし、基本語のフラグが接辞尾のために使われるのは次
を除いて 1 度だけである。その例外とは、双方が結合をサポートしている時に、双方
の 1 つの接頭辞と 1 つの接尾辞が使われる場合である。

特に、接辞尾フラグは次のために使うことができる:
- 上記の例と同じだが、接尾辞の接尾辞。これは一度だけ動作するので、1 つの単語は
  2 つの接尾辞を持つことができる (それと 1 つの接頭辞)。
- |spell-RARE| フラグを使って、珍しい接辞尾を持つ単語を作る。
- |spell-COMPOUNDFORBIDFLAG| フラグを使って、複合語から接辞尾を持つ単語を除外
  する。
- 接辞を持つ単語が、|spell-COMPOUNDPERMITFLAG| を持つ接辞側の複合語の一部とな
  ることを許す。
- NEEDCOMPOUND フラグを使う: 接辞を加えた単語は複合語のいち部としてのみ使われ
  る。|spell-NEEDCOMPOUND|
- 複合語フラグ: 接辞を加えた単語は尾、中間、頭などで複合語の一部となることがで
  きる。フラグは基本後のフラグと組み合わされる。|spell-compound|
- NEEDAFFIX: その他のフラグは妥当な単語を作るのに必要とされる。
- CIRCUMFIX は下記で説明される。


IGNOREEXTRA						*spell-IGNOREEXTRA*

通常、Vim は '#' で始まらない特別フィールドにエラーを与える。これは気づかれず
に進行しているエラーを回避する。しかしながら、いくつかの Myspell か Hunspell の
ために作られるファイルは特別なフィールドを持つエントリを多く含んでいるかも知れ
ない。多くのエラーを回避するために IGNOREEXTRA フラグを使用する。


CIRCUMFIX						*spell-CIRCUMFIX*

CIRCUMFIX フラグは同時に付加されなければならない接頭辞と接尾辞を意味する。もし
も接頭辞が CIRCUMFIX フラグを持つのなら、CIRCUMFIX フラグを持つ接尾辞のみが追
加される。そして、その反対も。
代替としては、接尾辞を指定しその接尾辞に 2 つのフラグを与えることだけである。:
それは必要とされる接頭辞と NEEDAFFIX フラグである。|spell-NEEDAFFIX|


PFXPOSTPONE						*spell-PFXPOSTPONE*

接辞ファイルが多くの単語に適用可能なたくさんの接辞を含む場合、全ての単語リスト
をメモリ内でビルドすることはできない。これはヘブライ語 (全ての単語のリストはギ
ガバイトを超える) に適用する。この場合、適用されている接辞は後回しにされなけれ
ばならない。これはスペルチェックを遅くする。これは .aff ファイル内の次のキーワー
ドによって示される:

	PFXPOSTPONE ~

途切れた文字列やフラグなしの接頭辞だけ延期されることができる。途切れた文字列や
フラグのある接頭辞は単語リストに含まれたままだろう。もしも途切れた文字列が 1
文字で、加えられた文字列の最後の文字と等しいのならば、小文字を除いて例外である。
それゆえ、途切れた文字列は大文字で始まる単語を続けることは認められている。


スラッシュ付きの単語					*spell-SLASH*

スラッシュは .dic ファイルで基本後と接頭語や他のフラグを区切ることに使われる。
不幸なことに、これは単語中でスラッシュを使えないことを意味している。それゆえ、
"TCP/IP" は単語ではなく、"IP" フラグをもつ "TCP" ということになる。単語中にス
ラッシュを含むためには、その前にバックスラッシュを挿入する: "TCP\/IP"。単語中
にバックスラッシュを使いたいというような稀な場合があるならバックスラッシュを 2
つ続ける必要がある。それ以外のバックスラッシュの使用は将来の拡張のために予約さ
れている。


大文字小文字を保つ単語					*spell-KEEPCASE*

接辞ファイル内の KEEPCASE 行は大文字小文字を保つ単語のために使われる接辞ファイ
ルを定義するのに使われる。例:

	KEEPCASE = ~

このフラグは Myspell によってサポートされない。大文字小文字問題があることを意
味する。もしも文章のはじめの単語が大文字で始まっていないのであれば、これを使う
ことができる。例:

    単語リスト	    マッチする		    マッチしない ~
    's morgens/=    's morgens		    'S morgens 's Morgens 'S MORGENS
    's Morgens	    's Morgens 'S MORGENS   'S morgens 's morgens

フラグはまた、全てが大文字である場合に単語がマッチすることを回避するために使わ
れる。


稀な単語						*spell-RARE*

接辞ファイルで稀な単語のために使われる接辞名を定義するのに RARE 行は使われる。
例:

	RARE ? ~

稀な単語は誤りの単語とは異なるハイライトをされる。これは言語向けの正しい単語の
ために使われるのだが、めったに使われず、入力ミスとなる。同じ単語が正しい単語と
して見つかると稀な単語としてはハイライトされないだろう。

このフラグはさらに接辞に使われる。そのため、接辞の付いた基本語が稀な場合を除き、
基本後は稀な単語ではない |spell-affix-flags| 。しかしながら、もしも単語が他の
使い方 (例: 他の地域) で正しい単語として現れたのなら、稀な単語としてマークされな
い。


誤った単語						*spell-BAD*

接辞ファイル内の BAD 行は、誤った単語のために使われる接辞名を定義するのに使わ
れる。例:

	BAD ! ~

これは他では正しいであろう単語を除外するのに使われる。例えば、.dic ファイル内
の "the the" である。

	the the/! ~

ひとたび誤った単語としてマークされると、同じ単語が正しいものであるとしてももと
に戻すことはできない。

フラグはまた単語に接辞を適用する。それゆえ、関連する単語群全体を誤ったものとし
てマークするのに使われる。

							*spell-FORBIDDENWORD*
FORBIDDENWORD は BAD とほとんど同じように使うことができる。Hunspell と互換。

							*spell-NEEDAFFIX*
NEEDAFFIX フラグは単語が接辞と共に使われることを要求するために使われる。単語そ
れ自身は正しい単語ではない (接辞が空でない限り) 。例:

	NEEDAFFIX + ~


複合語							*spell-compound*

複合語は .dic ファイル内にある単語を連結することによって作られた長い単語である。
連結されているかもしれない単語を明示するために、文字が使われる。この文字は単語
の後の接辞リストに書かれる。この文字をここではフラグと呼ぼう。明らかに、これら
のフラグは接辞の IDs で使われているどんなものとも異なっていなければならない。

							*spell-COMPOUNDFLAG*
Myspell 互換の方法は COMPOUNDFLAG で指定された 1 つのフラグを使う。このフラグ
を持つ単語は全て任意の順番に結合する。これはどの単語が最初にくるのかを制御しな
いことを意味する。例:
	COMPOUNDFLAG c ~

							*spell-COMPOUNDRULE*
複合語がどのように合成されるかを示すより進んだ方法は、複数のフラグを持った複数
の要素を使うことである。これは Myspell 3.0 と互換性を持たない。次の例から始めよ
う:
	COMPOUNDRULE c+ ~
	COMPOUNDRULE se ~

最初の行は "c" フラグを持つ単語が任意の順番で繋がれることを定義する。2 行目は
"s" フラグを持つ単語 1 つと "e" フラグを持つ単語 1 つからなる複合語を定義して
いる。次の内容の辞書からは:
	bork/c ~
	onion/s ~
	soup/e ~

これらの単語を作ることができる:
	bork
	borkbork
	borkborkbork
	(etc.)
	onion
	soup
	onionsoup

COMPOUNDRULE 要素は何度も目にするかもしれない。引数は 1 つもしくはそれ以上のグ
ループを作り上げる。それぞれのグループは次のようになる:
	one flag			e.g., c
	alternate flags inside []	e.g., [abc]
任意に次の記号を続けられる:
	*	the group appears zero or more times, e.g., sm*e
	+	the group appears one or more times, e.g., c+
	?	the group appears zero times or once, e.g., x?

これは正規表現の文法に似ている (しかし、同じではない!)。いくつかの必要な単語フ
ラグの順の例:
    COMPOUNDRULE x+	    x xx xxx etc.
    COMPOUNDRULE yz	    yz
    COMPOUNDRULE x+z	    xz xxz xxxz etc.
    COMPOUNDRULE yx+	    yx yxx yxxx etc.
    COMPOUNDRULE xy?z	    xz xyz

    COMPOUNDRULE [abc]z    az bz cz
    COMPOUNDRULE [abc]+z   az aaz abaz bz baz bcbz cz caz cbaz etc.
    COMPOUNDRULE a[xyz]+   ax axx axyz ay ayx ayzz az azy azxy etc.
    COMPOUNDRULE sm*e	    se sme smme smmme etc.
    COMPOUNDRULE s[xyz]*e  se sxe sxye sxyxe sye syze sze szye szyxe  etc.

特別な例: 2 つの単語とダッシュから作られる合成を許す:
	.aff ファイル内で:
	    COMPOUNDRULE sde ~
	    NEEDAFFIX x ~
	    COMPOUNDWORDMAX 3 ~
	    COMPOUNDMIN 1 ~
	.dic ファイル内で:
	    start/s ~
	    end/e ~
	    -/xd ~

これは単語 "start-end" を許すが、"startend" は許可しない。

さらに含まれるルールには次のようなものがある。これ以上のフラグなしで、接頭辞を
持つ単語は他の単語の後ろに結合されない。接尾辞を持つ単語は単語の前に結合されな
い。それゆえ、接辞は複合語の内側には現れない。これは
|spell-COMPOUNDPERMITFLAG| で変更することができる。

							*spell-NEEDCOMPOUND*
NEEDCOMPOUND フラグは単語が複合語の一部として使われることを要求するのに使われ
る。単語それ自身は正しい単語ではない。例:

	NEEDCOMPOUND & ~

							*spell-ONLYINCOMPOUND*
ONLYINCOMPOUND は NEEDCOMPOUND とまったく同じである。Hunspell との互換性をサポー
トする。

							*spell-COMPOUNDMIN*
合成するのに使われる単語の最小文字数は COMPOUNDMIN で指定される。例:
	COMPOUNDMIN 5 ~

省略された時は最小値はない。それよりも、明らかに短い単語からの合成フラグを省く
だけでよい。この機能は Myspell との互換性のためにある。

							*spell-COMPOUNDWORDMAX*
複合語の中に結合されうる単語の最大値は COMPOUNDWORDMAX で指定される。例:
	COMPOUNDWORDMAX 3 ~

省略されているときに最大値はない。すべての複合単語を適用する。

特定のフラグをもつ単語の制限を設定するために、COMPOUNDRULE 内の項目を確認する。
ここでは多すぎる単語を許可しないようだ。

							*spell-COMPOUNDSYLMAX*
複合語が含まれているかもしれない音節の最大値は COMPOUNDSYLMAX で指定される。
例:
	COMPOUNDSYLMAX 6 ~

SYLLABLE 項目がなければ効果はない。COMPOUNDSYLMAX がないと、音節の数に制限はな
い。

COMPOUNDWORDMAX と COMPOUNDSYLMAX の双方が定義されているなら、基準の 1 つに適
合している場合は複合語は認められる。それゆえ、COMPOUNDWORDMAX 単語まで作られた、
もしくは COMPOUNDSYLMAX 音節までを含んでいるかのどちらかである。

						    *spell-COMPOUNDFORBIDFLAG*
COMPOUNDFORBIDFLAG は 1 つの接辞で使われるフラグを指定する。接辞を加える単語は
複合語の中で使うことができないことを意味する。例:
	接辞ファイル:
		COMPOUNDFLAG c ~
		COMPOUNDFORBIDFLAG x ~
		SFX a Y 2 ~
		SFX a 0 s   . ~
		SFX a 0 ize/x . ~
	辞書:
		word/c ~
		util/ac ~

これは "wordutil" と "wordutils" は認めるが、"wordutilize" は認めない。
Note: これは伸ばされた接頭辞にはまだ作用しない。

						    *spell-COMPOUNDPERMITFLAG*
COMPOUNDPERMITFLAG は接辞に使われるフラグを明示する。接辞を加える単語はまた、
接辞が単語の途中で終わるような複合語の中で使うことができることを意味する。この
フラグなしでは、認められない。
Note: これは伸ばされた接頭辞にはまだ作用しない。

						    *spell-COMPOUNDROOT*
COMPOUNDROOT フラグはすでに合成される辞書の単語のために使われる。これは結合の
ルールを確認したときに、2 つの単語を数えることを意味する。接辞を複合語として数
えるための接辞として使うこともできる。

						*spell-CHECKCOMPOUNDPATTERN*
CHECKCOMPOUNDPATTERN はパターンを定義するのに使われる。そのパターンというのは
2 つの単語がお互いに合成されている位置が一致しているときに結合を禁止するという
ものだ。例:
	CHECKCOMPOUNDPATTERN o e ~

これは、最初の単語が "o" で終わり、2 つ目の単語が "e" で始まる場合に結合を禁止
するというものだ。

引数がプレーンテキストでなければならず、項目名にもかかわらず、実際にサポートさ
れるパターンはない。事例は常に無視される。

3 つの引数とフラグを使用する Hunspell 機能はサポートされない。

							*spell-NOCOMPOUNDSUGS*
この項目は、提案するために合成を使うことは良いアイデアではないことを示す。合成
がとても短い、もしくは 1 文字の単語で使われる場合、これを使用する。例えば、桁
外の数字を作るときである。このフラグがないと、提案を作るために奇妙な複合語のす
べてを試す膨大な時間を費やすことになるだろう。

	NOCOMPOUNDSUGS ~

							*spell-SYLLABLE*
SYLLABLE 項目は、文字もしくは単語の音節の数字を数えるために使われる文字の並び
を定義する。例:
	SYLLABLE aáeéiíoóöõuúüûy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui ~

最初のスラッシュの前は 1 つの音節として数えられた文字セットで、また、繰り返し
や混合された場合は、このセット内でない次の文字までになる。スラッシュの後には 1
つの音節として数えられる文字列が来る。これらは、セットから文字を使うよりも望ま
しい。例として、"ideeen" は 3 つの音節を持っていて、"i" と "ee" そして、"e" の
ように数えられる。

折り畳まれたケースの文字だけが含まれる必要がある。

合成を制限する他の方法は、上で述べられている: |spell-COMPOUNDFORBIDFLAG| フラ
グを接辞に加えることは、その接辞から作られるすべての単語が合成のために使われな
いことの原因となる。


UNLIMITED COMPOUNDING					*spell-NOBREAK*

For some languages, such as Thai, there is no space in between words.  This
looks like all words are compounded.  To specify this use the NOBREAK item in
the affix file, without arguments:
	NOBREAK ~

Vim will try to figure out where one word ends and a next starts.  When there
are spelling mistakes this may not be quite right.


							*spell-COMMON*
Common words can be specified with the COMMON item.  This will give better
suggestions when editing a short file.  Example:

	COMMON  the of to and a in is it you that he was for on are ~

The words must be separated by white space, up to 25 per line.
When multiple regions are specified in a ":mkspell" command the common words
for all regions are combined and used for all regions.

							*spell-NOSPLITSUGS*
This item indicates that splitting a word to make suggestions is not a good
idea.  Split-word suggestions will appear only when there are few similar
words.

	NOSPLITSUGS ~

							*spell-NOSUGGEST*
The flag specified with NOSUGGEST can be used for words that will not be
suggested.  Can be used for obscene words.

	NOSUGGEST % ~


REPLACEMENTS						*spell-REP*

In the affix file REP items can be used to define common mistakes.  This is
used to make spelling suggestions.  The items define the "from" text and the
"to" replacement.  Example:

	REP 4 ~
	REP f ph ~
	REP ph f ~
	REP k ch ~
	REP ch k ~

The first line specifies the number of REP lines following.  Vim ignores the
number, but it must be there (for compatibility with Myspell).

Don't include simple one-character replacements or swaps.  Vim will try these
anyway.  You can include whole words if you want to, but you might want to use
the "file:" item in 'spellsuggest' instead.

You can include a space by using an underscore:

	REP the_the the ~


SIMILAR CHARACTERS					*spell-MAP* *E783*

In the affix file MAP items can be used to define letters that are very much
alike.  This is mostly used for a letter with different accents.  This is used
to prefer suggestions with these letters substituted.  Example:

	MAP 2 ~
	MAP eéëêè ~
	MAP uüùúû ~

The first line specifies the number of MAP lines following.  Vim ignores the
number, but the line must be there.

Each letter must appear in only one of the MAP items.  It's a bit more
efficient if the first letter is ASCII or at least one without accents.


.SUG FILE						*spell-NOSUGFILE*

When soundfolding is specified in the affix file then ":mkspell" will normally
produce a .sug file next to the .spl file.  This file is used to find
suggestions by their sound-a-like form quickly.  At the cost of a lot of
memory (the amount depends on the number of words, |:mkspell| will display an
estimate when it's done).

To avoid producing a .sug file use this item in the affix file:

	NOSUGFILE ~

Users can simply omit the .sug file if they don't want to use it.


SOUND-A-LIKE						*spell-SAL*

In the affix file SAL items can be used to define the sounds-a-like mechanism
to be used.  The main items define the "from" text and the "to" replacement.
Simplistic example:

	SAL CIA			 X ~
	SAL CH			 X ~
	SAL C			 K ~
	SAL K			 K ~

There are a few rules and this can become quite complicated.  An explanation
how it works can be found in the Aspell manual:
http://aspell.net/man-html/Phonetic-Code.html.

There are a few special items:

	SAL followup		true ~
	SAL collapse_result	true ~
	SAL remove_accents	true ~

"1" has the same meaning as "true".  Any other value means "false".


SIMPLE SOUNDFOLDING				*spell-SOFOFROM* *spell-SOFOTO*

The SAL mechanism is complex and slow.  A simpler mechanism is mapping all
characters to another character, mapping similar sounding characters to the
same character.  At the same time this does case folding.  You can not have
both SAL items and simple soundfolding.

There are two items required: one to specify the characters that are mapped
and one that specifies the characters they are mapped to.  They must have
exactly the same number of characters.  Example:

    SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ~
    SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkes ~

In the example all vowels are mapped to the same character 'e'.  Another
method would be to leave out all vowels.  Some characters that sound nearly
the same and are often mixed up, such as 'm' and 'n', are mapped to the same
character.  Don't do this too much, all words will start looking alike.

Characters that do not appear in SOFOFROM will be left out, except that all
white space is replaced by one space.  Sequences of the same character in
SOFOFROM are replaced by one.

You can use the |soundfold()| function to try out the results.  Or set the
'verbose' option to see the score in the output of the |z=| command.


UNSUPPORTED ITEMS				*spell-affix-not-supported*

These items appear in the affix file of other spell checkers.  In Vim they are
ignored, not supported or defined in another way.

ACCENT		(Hunspell)				*spell-ACCENT*
		Use MAP instead. |spell-MAP|

BREAK		(Hunspell)				*spell-BREAK*
		Define break points.  Unclear how it works exactly.
		Not supported.

CHECKCOMPOUNDCASE  (Hunspell)			*spell-CHECKCOMPOUNDCASE*
		Disallow uppercase letters at compound word boundaries.
		Not supported.

CHECKCOMPOUNDDUP  (Hunspell)			*spell-CHECKCOMPOUNDDUP*
		Disallow using the same word twice in a compound.  Not
		supported.

CHECKCOMPOUNDREP  (Hunspell)			*spell-CHECKCOMPOUNDREP*
		Something about using REP items and compound words.  Not
		supported.

CHECKCOMPOUNDTRIPLE  (Hunspell)			*spell-CHECKCOMPOUNDTRIPLE*
		Forbid three identical characters when compounding.  Not
		supported.

COMPLEXPREFIXES  (Hunspell)				*spell-COMPLEXPREFIXES*
		Enables using two prefixes.  Not supported.

COMPOUND	(Hunspell)				*spell-COMPOUND*
		This is one line with the count of COMPOUND items, followed by
		that many COMPOUND lines with a pattern.
		Remove the first line with the count and rename the other
		items to COMPOUNDRULE |spell-COMPOUNDRULE|

COMPOUNDFIRST	(Hunspell)				*spell-COMPOUNDFIRST*
		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|

COMPOUNDBEGIN	(Hunspell)				*spell-COMPOUNDBEGIN*
		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|

COMPOUNDEND	(Hunspell)				*spell-COMPOUNDEND*
		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|

COMPOUNDMIDDLE	(Hunspell)				*spell-COMPOUNDMIDDLE*
		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|

COMPOUNDRULES	(Hunspell)				*spell-COMPOUNDRULES*
		Number of COMPOUNDRULE lines following.  Ignored, but the
		argument must be a number.

COMPOUNDSYLLABLE  (Hunspell)			*spell-COMPOUNDSYLLABLE*
		Use SYLLABLE and COMPOUNDSYLMAX instead. |spell-SYLLABLE|
		|spell-COMPOUNDSYLMAX|

KEY		(Hunspell)				*spell-KEY*
		Define characters that are close together on the keyboard.
		Used to give better suggestions.  Not supported.

LANG		(Hunspell)				*spell-LANG*
		This specifies language-specific behavior.  This actually
		moves part of the language knowledge into the program,
		therefore Vim does not support it.  Each language property
		must be specified separately.

LEMMA_PRESENT	(Hunspell)				*spell-LEMMA_PRESENT*
		Only needed for morphological analysis.

MAXNGRAMSUGS	(Hunspell)				*spell-MAXNGRAMSUGS*
		Set number of n-gram suggestions.  Not supported.

PSEUDOROOT	(Hunspell)				*spell-PSEUDOROOT*
		Use NEEDAFFIX instead. |spell-NEEDAFFIX|

SUGSWITHDOTS	(Hunspell)				*spell-SUGSWITHDOTS*
		Adds dots to suggestions.  Vim doesn't need this.

SYLLABLENUM	(Hunspell)				*spell-SYLLABLENUM*
		Not supported.

TRY		(Myspell, Hunspell, others)		*spell-TRY*
		Vim does not use the TRY item, it is ignored.  For making
		suggestions the actual characters in the words are used, that
		is much more efficient.

WORDCHARS	(Hunspell)				*spell-WORDCHARS*
		Used to recognize words.  Vim doesn't need it, because there
		is no need to separate words before checking them (using a
		trie instead of a hashtable).

 vim:tw=78:sw=4:ts=8:noet:ft=help:norl:
