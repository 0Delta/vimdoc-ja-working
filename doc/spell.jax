*spell.txt*	For Vim バージョン 8.1.  Last change: 2018 Jan 29


		  VIMリファレンスマニュアル	  by Bram Moolenaar


スペルチェック						*spell*

1. はじめに			|spell-quickstart|
2. スペルチェックの注意点	|spell-remarks|
3. スペルファイルの生成		|spell-mkspell|
4. スペルファイルの形式		|spell-file-format|

{Vi にはこれらのコマンドはない}

コンパイル時に |+syntax| 機能を無効にした場合にはスペルチェックは利用すること
ができない。

Note: 他にも vimspell プラグインがある。そのプラグインを入れていれば ":help
vimspell" を実行することでそれについて調べることができる。しかし、おそらくその
プラグインを削除し、代わりにオプション 'spell' を使いたいと思うだろう。そちら
のほうがうまくいく。

==============================================================================
1. はじめに					*spell-quickstart* *E756*

このコマンドで、スペルチェックがオンになる: >

	:setlocal spell spelllang=en_us

これはオプション 'spell' をオンにし、アメリカ英語のチェックを指定する。

認識されない単語は以下のようにハイライトされる:
	SpellBad	認識されない単語			|hl-SpellBad|
	SpellCap	頭文字が大文字になっていない単語	|hl-SpellCap|
	SpellRare	まれな単語				|hl-SpellRare|
	SpellLocal	選択された地域では間違った綴り		|hl-SpellLocal|

Vim は単語の綴りのみをチェックし、文法はチェックしない。

もし、'mousemodel' オプションが "popup" にセットされてカーソルが間違った単語の
上にあるか、"popup_setpos" に設定されてマウスポインタが間違った単語の上にある
なら、ポップアップメニューは間違った単語を置き換えるサブメニューが含まれるよう
になる。Note: これはポップアップメニューの表示を遅くする。Note: GTKについては
メニューが現れるまでマウスの右ボタンを離してはいけない。そうしなければ機能しな
い。

次の綴りの間違った単語を探すには:

							*]s*
]s			カーソルの後の、次の綴りの間違った単語に移動する。コマ
			ンドの前に count を指定することで、繰り返しができる。
			'wrapscan' が適用される。

							*[s*
[s			"]s" と同様だが後方検索を行い、カーソルより前の綴りの
			間違った単語を探す。2行に渡った単語は認識しないため、
			間違いとしてハイライトされていない単語で止まることがあ
			る。行頭が大文字になっていない単語では止まらない。

							*]S*
]S			"]s" と同様だが、間違った単語のみで止まり、まれな単語
			や他の地域の単語では止まらない。

							*[S*
[S			"]S" と同様だが、後方検索を行う。


単語をあなた自身の単語リストに追加するには:

							*zg*
zg			カーソルの下の単語を正しい (good) 単語として、
			'spellfile' の最初のファイルに追加する。
			コマンドの前に count を指定することで、'spellfile' 内
			の項目を指定することができる。count として 2 を指定す
			ると、2 番目の項目が使われる。

			ビジュアルモードで選択された文字は単語として追加される
			(スペースを含む!)。
			カーソルが間違った綴りとしてマークされた文章の上にある
			時、そのマークされた文章が使われる。
			そうでなければ、単語ではない文字で分けられたカーソルの
			下の単語が使われる。

			もしその単語が明示的に別のスペルファイルで間違った単語
			としてマークされているなら、その結果は予測できない。

							*zG*
zG			"zg" と同様であるが、その単語を内部単語リスト
			|internal-wordlist| に加える。

							*zw*
zw			"zg" と同様であるが、間違った (wrong) 単語としてマーク
			する。もしその単語がすでに 'spellfile' にある場合は、
			コメント行に変更される。それらを取り除くには
			|spellfile-cleanup| を参照する。

							*zW*
zW			"zw" と同様であるが、その単語を内部単語リスト
			|internal-wordlist| に加える。

zuw							*zug* *zuw*
zug			|zw| や |zg| をundoして、'spellfile' の項目からその単
			語を削除する。count は |zg| と同様に使われる。

zuW							*zuG* *zuW*
zuG			|zW| や |zG| をundoして、内部単語リストからその単語を
			削除する。count は |zg| と同様に使われる。

							*:spe* *:spellgood*
:[count]spe[llgood] {word}
			|zg| と同様に、{word} を正しい単語として 'spellfile' に
			加える。count が無いときは最初の名前が使われ、count に
			2 を指定したときは 2 番目の項目が使われる。以下同様。

:spe[llgood]! {word}	|zG| と同様に、{word} を正しい単語として内部単語リスト
			に加える。

							*:spellw* *:spellwrong*
:[count]spellw[rong] {word}
			|zw| と同様に、{word} を間違った (wrong) 単語として
			'spellfile' に加える。count が無いときは最初の名前が使
			われ、count に 2 を指定したときは 2 番目の項目が使われ
			る。以下同様。

:spellw[rong]! {word}	|zW| と同様に、{word} を間違った (wrong) 単語として内
			部単語リストに追加する。

:[count]spellu[ndo] {word}				*:spellu* *:spellundo*
			|zuw| と同様である。[count] は |:spellgood| と同様に使
			われる。

:spellu[ndo]! {word}	|zuW| と同様である。[count] は |:spellgood| と同様に使
			われる。


上記のコマンドで 'spellfile' に単語を追加した後、その関連付けられた ".spl" ファ
イルは自動的に更新され再読み込みされる。もし手動で 'spellfile' を変更するなら
|:mkspell| コマンドを用いる必要がある。このコマンドの順序でたいていうまくいく:
>
	:edit <'spellfile' にあるファイル>
<	(スペルファイルに変更を加える) >
	:mkspell! %

'spellfile' の形式に関する詳細は下記の |spell-wordlist-format| を参照。

							*internal-wordlist*
内部単語リストは 'spell' がセットされた全てのバッファで使われる。内部単語リス
トは蓄えられず、Vim が終了する時に失われる。また 'encoding' がセットされた時に
クリアされる。


間違った単語に対しての提案を調べるには:
							*z=*
z=			カーソルの下や後の単語に対して正しい綴りの単語を提案す
			る。これはまた間違った単語としてハイライトされていない
			単語に対しての代わりを調べることもできる。例えば、その
			後の単語が間違っている場合など。
			ビジュアルモードでハイライトされたテキストは置換される
			単語として見なされる。
			結果は、置換されようとしている単語との類似度でソートさ
			れる。
			これには長い時間が掛かることがある。うんざりした場合は
			CTRL-C を打つこと。

			count なしでこのコマンドを使う場合、選択肢がリストアッ
			プされ、選びたい選択肢の番号を入力することができる。置
			き換えたくない場合は <Enter> を押す。また、マウスを使っ
			て選択肢をクリックすることもできる(マウスがノーマルモー
			ドで使われ、行の折り返しがない時のみ働く)。キャンセル
			するには最初の行(ヘッダー)をクリックする。

			リストアップされた提案はふつうハイライトされた間違った
			単語を置き換える。その提案は時々他のテキストを含むこと
			があるが、その場合は置き換えられるテキストが "<" の後
			にリストアップされる。

			count を用いた場合、プロンプトは出ずにその提案が使われ
			る。例えば、"1z=" は常に最初の提案を利用する。

			'verbose' が 0 以外の場合、間違った単語との類似度を示
			すスコアが提案と共に表示される。（高いスコアは、違いが
			大きいことを示す。）
			単語が置換された後は、リドゥコマンド "." はその単語の
			置換を繰り返す。これは、"ciw" の後に正しい単語を入力し
			<Esc> を入力したように動作する。これは、単語の間にス
			ペースを含まないタイ語やその他の言語に対しては動かな
			い。

					*:spellr* *:spellrepall* *E752* *E753*
:spellr[epall]		|z=| によって行われた置換を、現在のウィンドウの全ての
			マッチする単語に対して繰り返す。

挿入モードでは、カーソルが間違った綴りの単語の後にある場合、提案を見つけるため
に CTRL-X s を使うことができる。これは挿入モード補完のように動作する。次の提案
を使うには CTRL-N を、戻るには CTRL-P を使うこと。|i_CTRL-X_s|

オプション 'spellsuggest' は候補のリストがどのように生成、ソートされるかに影響
する。|'spellsuggest'| を参照せよ。

オプション 'spellcapcheck' は文の最初の単語が大文字で始まるかをチェックするの
に用いる。これはファイルの最初の単語には働かない。文の直後に改行があるとき、次
の行のハイライティングが後回しにされるかもしれない。必要であれば |CTRL-L| を使
用せよ。また、'spelllang' が設定される時にどのように自動で設定されるのかについ
ては |set-spc-auto| を参照せよ。

Vim は見つけた正しい単語の数を数える。これは提案候補をソートするのに使用される。
前に見つけた単語は小さな評価、よく見られる単語は大きな評価を得る。接辞ファイル
に共通する要素は共通の単語を定義するのに使用することができる。そのため、この機
構は新規もしくは小さいファイルでも機能する |spell-COMMON| 。

==============================================================================
2. スペルチェックの注意点				*spell-remarks*

性能

Vim はオンザフライのスペルチェックをする。スペルチェックを速くするために単語リ
ストはメモリにロードされる。だがこのために多くのメモリ(1 Mbyte以上)が使われる。
さらに、単語リストがロードされている時に著しい遅延が生じるかもしれない。これは
'spell' が既に設定されていたのに、'spell' を設定する時や 'spelllang' を設定す
る時に発生する。遅延を最小限にするには各単語リストが1回だけ読み込まれるように
する。そうすれば、'spelllang' が空になる時か 'spell' がリセットされる時に単語
リストは削除されない。'encoding' を設定して全ての単語リストが再読み込みされる
時に、上のようにまた遅延に気づくかもしれない。


地域

単語はそれぞれの地域で綴りが異なるかもしれない。例えば、英語は少なくともこれ
らの差異がある。

	en		全ての地域
	en_au		オーストラリア
	en_ca		カナダ
	en_gb		イギリス
	en_nz		ニュージーランド
	en_us		アメリカ

ある地域では使われないが別の地域では使われる単語は SpellLocal |hl-SpellLocal|
でハイライトされる。

常に言語名や地域名には小文字を使う。

|zg| や他のコマンドで単語が追加された時、その単語は常に全ての地域に追加される。
これは 'spellfile' を手動で編集することで変更できる。|spell-wordlist-format|
を参照せよ。'spellfile' にあるファイル内で指定される地域は'spelllang'にあるす
べてのエントリが同じ地域(.spl の名前によって特定されるファイルは数えない)を指
定するときにのみ使用されることに注意すること。

							*spell-german*
特有の例外: ドイツ語ではこれらの特別な地域が使われる:
	de		全てのドイツ語単語を許容する
	de_de		新旧正書法
	de_19		旧正書法
	de_20		新正書法
	de_at		オーストリア
	de_ch		スイス

							*spell-russian*
特有の例外: ロシア語ではこれらの特別な地域が使われる:
	ru		全てのロシア語単語を許容する
	ru_ru		"IE" letter spelling
	ru_yo		"YO" letter spelling

							*spell-yiddish*
イディッシュ語は特有の文字を使用するため、"utf-8" エンコーディングを使用する必
要がある。もし latin1 を使っているのなら、Vimは代わりに字訳された(ローマ字化さ
れた)イディッシュ語を使用するだろう。もしあなたが字訳されたイディッシュ語を
utf-8 で使用したいのなら、"yi-tr" を使用せよ。
一覧:
	'encoding'	'spelllang'
	utf-8		yi		イディッシュ語
	latin1		yi		ローマ字化されたイディッシュ語
	utf-8		yi-tr		ローマ字化されたイディッシュ語

							*spell-cjk*
中国語、日本語、あるいはその他の東アジアの文字に対するスペルチェックはサポート
されていないため、これらの文字は通常、エラーとしてマークされる。'spelllang' が
"cjk" を含んでいる場合、これらの文字はエラーとしてマークされなくなる。これは、
いくつかのアジアの単語が含まれるテキストを、スペルチェックを有効にして編集する
際に有用である。


スペルファイル						*spell-load*

Vim は 'runtimepath' のディレクトリの中の "spell" という名前のサブディレクトリ
にあるスペルファイルを探す。ファイル名は LL.EEE.spl のようになる:
	LL	言語名
	EEE	'encoding' の値

"LL" の値は 'spelllang' の値が使われるが、地域名は除外される。
例:
	'spelllang'	LL ~
	en_us		en
	en-rare		en-rare
	medical_ca	medical

'runtimepath' の中の最初のファイルだけがロードされる。これが成功した場合、
LL.EEE.add.spl という名前のファイルが追加でロードされる。追加ファイルは、見つ
かったものが全てロードされる。

スペルファイルが見つからなければ、自動コマンドイベント |SpellFileMissing| が発
生する。これによってスペルファイルをダウンロードする |spellfile.vim| プラグイ
ンを呼び出せる。

加えて、'spellfile' の名前に関連したファイルは読み込まれる。これらは |zg| や
|zw| で正しい単語や間違った単語を追加するファイルである。

例外:
- Vim は、'encoding' が "iso-8859-15" のとき "latin1" を使う。ユーロマークは
  スペルチェックに影響しない。
- 'encoding' 用のスペルファイルが見つからないときは "ascii" が試される。これは
  全ての単語が英語などの ASCII に近い言語に対してのみうまく働く。'encoding' が
  iso-8859-2 のように "latin1" でないときや英文を編集しているときに役に立つ。
  ".add" ファイルのために見つかったメインのスペルファイルとして同じ名前のファ
  イルが使用される。

例えば、以下の値が設定されている場合:
	'runtimepath' が "~/.vim,/usr/share/vim70,~/.vim/after"
	'encoding'    が "iso-8859-2"
	'spelllang'   が "pl"

Vim は以下を探す:
1. ~/.vim/spell/pl.iso-8859-2.spl
2. /usr/share/vim70/spell/pl.iso-8859-2.spl
3. ~/.vim/spell/pl.iso-8859-2.add.spl
4. /usr/share/vim70/spell/pl.iso-8859-2.add.spl
5. ~/.vim/after/spell/pl.iso-8859-2.add.spl

ここでは、1. が見つからず、2. が見つかったと仮定している。

もし 'encoding' が "latin1" ならば Vim は以下を探す:
1. ~/.vim/spell/pl.latin1.spl
2. /usr/share/vim70/spell/pl.latin1.spl
3. ~/.vim/after/spell/pl.latin1.spl
4. ~/.vim/spell/pl.ascii.spl
5. /usr/share/vim70/spell/pl.ascii.spl
6. ~/.vim/after/spell/pl.ascii.spl

これはこれらが見つからないことを想定する(ポーランド語は non-ASCII 文字を抜くと
意味をなさない)。

EBCDIC 向けのスペルチェックは現在サポートされていない。

現在の 'encoding' でスペルファイルが利用できないかもしれない。スペルファイルの
作成の仕方については |spell-mkspell| を参照せよ。"iconv" でスペルファイルを変
換するのは機能しないだろう!

Note: VMS ではファイル名によるトラブルを避けるため、".{enc}.spl" は
"_{enc}.spl" に変更されている。

						    *spell-sug-file* *E781*
もしまさしく同じ名前の ".spl" ファイルがあるが、その最後に ".sug" がついていな
いのであれば、このファイルはよりよいサジェスチョンを与えるのに使われる。メモリ
の使用率を減らすため、サジェスチョンが作られる前には読み込まれない。

				    *E758* *E759* *E778* *E779* *E780* *E782*
スペルファイルを読み込む時、Vim はそれが正しくフォーマットされているかチェック
する。もしエラーが生じたなら、そのファイルが不完全であるか、変更されているか、
Vim の他のバージョン向けのものかもしれない。


スペルファイルのクリーンアップ				*spellfile-cleanup*

|zw| コマンドは 'spellfile' に存在するエントリをコメント行に変更する。これは毎
回新しいファイルに書き込まれることを避けるが、結果としてファイルは長くなるのみ
で短くなることはない。すべての ".all" スペルファイル内のコメント行をクリーンアッ
プするには次のようにする: >
	:runtime spell/cleanadd.vim

これは行頭が "##" で始まるものを除いて、すべてのコメント行を削除する。保持して
おきたいコメントには "##" を使う。

好きなだけ、このスクリプトを呼び出すことができる。直近で変更されたファイルのアッ
プデートをスキップするための変数を提供している。そのファイルが最後に変更されて
からクリーンアップされるまでの秒数を設定する。例えば、この1時間で変更されなかっ
たファイルだけをクリーンアップするには次のようにする: >
      let g:spell_clean_limit = 60 * 60
デフォルトでは1秒。


単語

Vim は単語を認識するのに定型的な方法を使う。これは 'iskeyword' とは独立してい
るので、ヘルプファイル内や 'iskeyword' 内に '-' のような文字を含む言語に対して
も機能する。この単語の文字は 'encoding' に依存する。

単語の文字テーブルはメインの .spl ファイルに保存される。それゆえ .spl ファイル
を生成するときの現在のロケールがなんであるかが重要である! 従って .add.spl ファ
イルは単語テーブルを含まない。

数字で始まる単語に関しては、全体で単語であると認識するまで先頭の数字は無視され
る。したがって、もし "3D" が一つの単語で "D" が単語でないのなら、"3D" は単語と
して認識される。しかし、もし "3D" が単語で無ければ "D" は不正としてマークされ
る。0x12ab や 0X12AB のような16進数は認識される。


単語の組み合わせ

スペースを含む単語のスペルチェックが可能である。これは例えば、"et al." のよう
な単語によって使われる場合に無効な単語を認識するために使われる。これは更に
"the the" を評価したり、ハイライトするために使われる。

スペースの個数は無関係だ。多くの場合、改行が現れるかもしれない。しかしながら、
これはスペルミスのチェックを開始する場所を見つけるのを困難にする。あなたが1行
の変更をし、その行が再描画されただけであれば、Vim は前の行を見ない。それゆえ、
前の行の最後が "et" であると "al." はエラーとみなされる。また、"the<CR>the" と
タイプしたときは初めの行が再描画されるまでハイライトされない。すぐに再描画を行
うには |CTRL-L| を使う。"[s" は改行を含む単語にも止まる。

改行があると、Vim は '*' や '>'、'"' のような単語をスキップするので、C、シェル、
Vim コードでのコメントをスペルチェックすることができる。


構文ハイライト						*spell-syntax*

構文ハイライトを使用するファイルでは、どこでスペルチェックを行うべきか指定する
ことができる:

1.  どこでも			   既定
2.  指定の要素			   "contains=@Spell" を使用する
3.  指定の要素以外どこでも	   "contains=@NoSpell" を使用する

@NoSpell クラスタを追加する2番目の方法はスペルチェックを再度無効にすることだろ
う。これが使われれば、例えば @Spell をプログラムのコメントに加えたり、チェック
するべきでないアイテムを @NoSell に追加できる。シンタックスアイテムにないテキ
ストについては、|:syn-spell| を参照。


Vim script

スペルに関するVim script を書きたいと思うと、これらの関数が役に立つことが分
かるだろう:

    spellbadword()	カーソル下の間違ったつづりの単語を見つける
    spellsuggest()	正しいつづりの候補を得る
    soundfold()		同音(sound-a-like)の単語を得る


'spellcapcheck' の自動設定				*set-spc-auto*

'spelllang' オプションがうまく設定された後は、Vim は　'runtimepath' にある
"spell/LANG.vim" ファイルを読み込む。"LANG" は 'spelllang' が初めのコンマ、ドッ
ト、またはアンダースコアーまでの値である。これは言語のための特別なオプション、
とりわけ 'spellcapcheck' を設定するのに使われる。

ディストリビューションはこれらのファイルをいくつか含んでいる。これらが何をして
いるかを知るためには次のコマンドを使う >
	:next $VIMRUNTIME/spell/*.vim

Note: デフォルトのスクリプトは初期値が変更されているなら 'spellcapcheck' を設
定しない。これはユーザーが好む値を設定することを想定する。


二重スコア付け						*spell-double-scoring*

"double" 方式のスコア付けを選択するために 'spellsuggest' オプションを使用でき
る。この機構は、綴り間違いには2種類あるという原則に基づいている:

1. 単語の綴りは知っているが、何らかのミスタイプをする場合。これは小さな編集に
   よる変更 (文字の入れ替わり/文字抜け/文字の混入) の結果であり、単語は完全に
   間違っているようにみえるかもしれない。

2. 単語の綴りを知らず、単語が正しく聞こえるようにタイプする場合。
   編集による差異は大きくなり得るが、単語は後の sound-folding と同様である。

これら2つの間違いのスコアは大きく異なるので、互いに1つのリストを使って、組み合
わせる。

sound-folding は遅く、言語を知っている人は2種類の間違いをしたくないだろう。そ
れゆえ、'spellsuggest' にサジェスチョンのスコアリングに用いる好きな方法を設定
できる。

==============================================================================
3. スペルファイルの生成					*spell-mkspell*

Vimはつづりのためのバイナリフォーマットを使用する。このことにより単語リストの
読み込みを大幅に速くし、単語リストを小さく保つ。
						    *.aff* *.dic* *Myspell*
Myspellが使用する .aff と .dic ファイルからVimが使用するスペルファイルを生成す
ることができます。Myspell は OpenOffice.org と Mozilla によって使用されます。
OpenOffice の .oxt ファイルは .aff と .dic ファイルを含む zip ファイルです。こ
れらはここから探すことができる。
	http://extensions.services.openoffice.org/dictionary
これが機能しない場合、以前の OpenOffice 2 のファイルが使用されることがある。
	http://wiki.services.openoffice.org/wiki/Dictionaries
加えて、プレーンテキストの単語リストも使用できます。選択肢はあなたが見つけた単
語のリストによって決まり、結果は同じになる。

Aap (www.a-a-p.org) をインストールしたのなら、runtime/spell/??/ ディレクトリで
レシピを使用することができる。Aap はファイルをダウンロードし、Vim に必要なパッ
チを適用し .spl ファイルをビルドする。

現在のロケールが適切に設定されているか確認してください。適切に設定がなされてい
ない場合、Vim は 大文字と小文字の区別ができない。もしロケールが利用できない場
合 (例えば Unix 上で MS-Windows コードページを使用している場合) は .aff ファイ
ルにテーブルを追加してください |spell-affix-chars| 。.aff ファイルがテーブルを
定義していないなら、現在有効なスペリングのテーブルが使われる。スペリングが有効
でないなら Vim はスペリングを推測しようとする。

							*:mksp* *:mkspell*
:mksp[ell][!] [-ascii] {outname} {inname} ...
			単語リストからVimスペルファイルを生成する。例: >
		:mkspell /tmp/nl nl_NL.words
<								*E751*
			{outname} が ".spl" で終わっている場合、出力ファイル名
			として使われる。そうでなければ、地域名を除いた "en" の
			ような言語名が使われる。書き込まれたファイルは
			"{outname}.{encoding}.spl" とない、{encoding} には
			'encoding' オプションの値が入る。

			出力ファイルがすでに存在する場合は、上書きするために
			[!] を使用しなければならない。

			[-ascii] 引数が存在している場合は、non-ascii 文字で構
			成された単語がスキップされる。結果のファイルは
			"ascii.spl" で終わる。

			入力は Myspell 形式の {inname}.aff と {inname}.dic ファ
			イルが使用できる。もし {inname}.aff が存在していなけれ
			ば、{inname} はプレーン単語リストのファイル名として使
			われる。

			複数の {inname} 引数を使うと、1つの Vim スペルファイル
			に複数の地域の組み合わせを与えることができる。例: >
		:mkspell ~/.vim/spell/en /tmp/en_US /tmp/en_CA /tmp/en_AU
<                        これはUS, CA そしてAUの英単語リストの組み合わせを1つの
			en.spl.file にする。
			8つの地域まで組み合わせることができる。*E754* *E755*
			上記のコマンドで出現する .aff ファイルの初めにある REP
			と SAL 項目が使われる。|spell-REP| |spell-SAL|
								*E845*
			このコマンドは多くのメモリを使用し、最適な単語ツリーを
			見つけることが求められる (ポーランド語、イタリア語、ハ
			ンガリー語は数百バイトのメモリを要求する)。最終的な結
			果は圧縮が使用されるので、非常に小さくなるだろう。メモ
			リ外で動作しないようにするため、圧縮は適便行われる。こ
			れは 'mkspellmem' オプションで設定できる。

			バッファ内でスペルファイルが書き込まれた後、使われ始め
			ると自動的に再読み込みされる。

:mksp[ell] [-ascii] {name}.{enc}.add
			上記の ":mkspell" と似ている。入力ファイルとして
			{name}.{enc}.add を使用すると、同じディレクトリに
			".spl" が付加された出力ファイルが生成される。

:mksp[ell] [-ascii] {name}
			上記の ":mkspell" と似ている。入力ファイルとして {name}
			を使用すると、同じディレクトリに ".{enc}.spl" が付加さ
			れた出力ファイルが生成される。

Vim は重複した単語の出現回数を報告する。これは単語リスト中の誤りであるかもしれ
ない。しかし、時には同じ基本単語に対して、結合しないようにするために異なる接頭
辞と接尾辞が使用される (例えば、チェコ語はこれを使う)。もしすべての重複する単
語を Vim に報告させたい場合は、'verbose' オプションを設定する。

Vim で使うために Myspell の単語リストを変更したいならば、次のような手順で行う
ことをお薦めする:

1. Myspell から xx_YY.aff と xx_YY.dic ファイルを入手する。
2. これらのファイルを xx_YY.orig.aff と xx_YY.orig.dic のようにコピーする。
3. 良くない単語を取り除くために xx_YY.aff とxx_YY.dic ファイルを変更し、足りな
   い単語を加え、FOL/LOW/UPP の単語を定義したりする。配布されている "*.diff"
   ファイルを使用できる。
4. Vim を正しいロケールで起動し、Vim スペルファイルを生成するために |:mkspell|
   を使う。
5. 'runtimepath' 内のスペルファイルディレクトリに書き込むなら、
   "set spelllang=xx" でスペルファイルを試してみる。その他のディレクトリに書き
   込む場合は、":set spelllang=xx.enc.spl" を試す。

Myspell ファイルが更新されたとき、差異をマージすることができる:
1. 新しい Myspell ファイルを xx_YY.new.aff と xx_UU.new.dic として取得する。
2. 変更箇所を確認するために Vimdiff を使う: >
	vimdiff xx_YY.orig.dic xx_YY.new.dic
3. xx_YY.dic の変更点を引き継ぐ
   xx.YY.aff の変更点も必要とするかもしれない。
4. xx_YY.new.dic を xx_YY.orig.dic へ、xx_YY.new.aff を xx_YY.new.aff へリネー
   ムする


スペルファイルのバージョン				*E770* *E771* *E772*

スペルチェックは Vim の比較的新しい機能なので、.spl ファイル形式はより多くの言
語をサポートするために変更されるかもしれない。Vim はスペルファイルの有効性を確
認し、間違いがあれば報告する。

	E771: Old spell file, needs to be updated ~
スペルファイルが使用している Vim のバージョンよりも古いものなので、.spl ファイ
ルを更新する必要がある。

	E772: Spell file is for newer version of Vim ~
これはスペルファイルが使用している Vim よりも新しいバージョンに対応したものな
ので、Vim を更新する必要があることを意味する。

	E770: Unsupported section in spell file ~
これはスペルファイルが使用している Vim よりも新しいバージョンに対応したもの
で、スペルファイルを動作させるために必要なセクションを含むことを意味する。この
場合は、Vim を更新することが良い考えとなるだろう。


スペルファイルのダンプ

もし何らかの理由で、現在使っているスペルファイルでどんな単語がサポートされてい
るかをチェックしたい場合、以下のコマンドを使用できる:

							*:spelldump* *:spelld*
:spelld[ump]		新規ウィンドウを開き、すべての有効な単語で埋め尽くす。
			複合語は含まれない。
			Note: いくつかの言語では、結果が非常に大きくなり、Vim
			がメモリ不足を引き起こすかもしれない。

:spelld[ump]!		":spelldump" と同様に、単語数を含む。これは画面を更新
			している間に発見した単語の個数である。COMMON アイテム
			にある単語は10から数えられる。

単語リストの形式は |spell-wordlist-format| が使われる。全ての単語を含む1つの
.spl ファイルを生成するために、":mkspell" で読み込むことができるようにすべきだ。

すべての 'spelllang' に対するエントリが同じ地域を使用しているか、または全く地
域使用しない場合、地域情報がダンプワードに含まれる。そうでなければ、現在の地域
に関する単語のみが含まれ、"/regions" 行は生成されない。

.spl ファイルの名前を持つコメント行は、.spl ファイルから生成された単語の上記の
ヘッダーとして使われる。


スペルファイルがないとき	*spell-SpellFileMissing* *spellfile.vim*

使用している言語のスペルファイルが利用できないならば、エラーメッセージを受け取
るだろう。しかし、"spellfile.vim" プラグインがアクティブであるならば、スペルファ
イルをダウンロードするように薦められる。指示に従ったのならば、プラグインはダウ
ンロードしたスペルファイルを保存する場所を尋ねるだろう (このため、
'runtimepath' 内の書き込み可能な場所でなければならない)。

プラグインは、Vim ftp サーバー上にスペルファイルを探すデフォルトの場所を持つ。
他の場所や他のプロトコルを使用したいならば、スペルファイルが存在するディレクト
リに対して、g:spellfile_URL を設定する。|netrw| プラグインはファイルを取得する
ために使われ、そこに URL の特定の構文があるかを調べる。例: >
	let g:spellfile_URL = 'http://ftp.vim.org/vim/runtime/spell'
特殊文字をエスケープする必要があるかもしれない。

このプラグインは一度、ある1つの言語をダウンロードすることについてのみ質問する
だろう。もし再度行おうとする場合は、Vim を再起動するか g:spellfile_URL を他の
値 (例えば、スペースを前置する) に設定する。

"spellfile.vim" プラグインの使用を避けるためには、vimrc ファイルないで次のよう
にする: >

	let loaded_spellfile_plugin = 1

プラグインを使用するかわりに 欠落したファイルを扱うために |SpellFileMissing|
自動コマンドを定義することができる。次のように使う: >

	:au SpellFileMissing * call Download_spell_file(expand('<amatch>'))

それゆえ <amatch> アイテムは言語の名前を含む。もう一つの重要な値はどのエンコー
ディングも自分自身のスペルファイルがあるので 'encoding'である。2つの例外: >
- ISO-8859-15 (latin9) の場合、"latin1" という名前が使用される (このエンコーディ
  ングでのみ、辞書の単語で使用されていない文字が異なる。)。
- "ascii" という名前は単語の多くで ASCII 文字のみを使用するいくつかの言語につ
  いて使われることがある。

デフォルトの "spellfile.vim" プラグインはこの自動コマンドを使う。もし後で自分
の自動コマンドを定義するなら、これを無効にするために ":au! SpellFileMissing"
を使いたいかもしれない。プラグインが読み込まれる前に自分の自動コマンドを定義す
る場合は、これを警告し、また何もしないだろう。
							*E797*
Note SpellFileMissing 自動コマンドはユーザーが編集しているバッファを変更や削除
してはいけない。

==============================================================================
4. スペルファイルの形式					*spell-file-format*

これは単語リストを作成、管理する人が使うファイルのフォーマットである。

Note ここでは辞書 ("dictionary") という単語の使用を避ける。スペルチェックの目
的は (本のような) 辞書を書くこととは違うからだ。スペリングのために、間違いのな
い単語のリストが必要となる。それゆえ、ハイライトされるべきではない。人と会社の
名前は辞書内に現れることはないが、単語リストには現れる。共通のミススペルとして
まれに古い単語が使われる。これらは辞書には現れるが、単語リストには現れない。

2つのフォーマットがある: 単語の率直なリストと接辞圧縮を使ったリストである。接
辞圧縮を使ったファイルは Myspell (Mozilla and OpenOffice.org) によって使われる。
これは2つのファイルを必要とし、1つは .aff、もう1つは .dic の拡張子をもつファイ
ルだ。


率直な単語リストのフォーマット				*spell-wordlist-format*

単語は1行に1つずつ現れなければならない。これが必要とされることのすべてだ。

加えて、次の項目が評価される:

- 何もない、もしくは空行は無視される。

	# comment ~
- # で始まる行は無視される (コメント行)。

	/encoding=utf-8 ~
- どんな単語よりも前でにある "/encoding=" で始まる行はファイルのエンコーディン
  グを指定する。'=' の後にはエンコーディング名がくる。これは Vim に指定された
  エンコーディングから 'encoding' への変換のセットアップをするように伝える。そ
  れゆえ1つの単語リストを複数のエンコーディング向けに使うことができる。

	/regions=usca ~
- "/regions=" で始まる行はサポートする地域の名前を指定する。どの地域も2つの
  ASCII 文字でなければならない。その1めは地域 1。それゆえ "/regions=usca" は地
  域 1の "us" と地域 2の "ca" を持つ。加えて、単語リストの地域名は主となる単語
  リストと同じでなければならない!

- それ以外の '/' で始まる行は、今後使うために予約されている。評価されない行は
  無視される。警告のメッセージを受け取るので、動作しないのが何かを知ることがで
  きる。

- "/" は下記の項目にある単語を伴うことができる。
    =		ケースは正確にマッチしなければならない。
    ?		珍しい単語
    !		悪い (誤った) 単語
    1 to 9	単語が有効である地域。地域が指定されていないならば、すべての地
		域で単語が有効である。

例:

	# 単語リストの例			コメント
	/encoding=latin1			ファイルのエンコーディング
	/regions=uscagb				地域 "us", "ca", "gb"
	example					全ての地域の単語
	blah/12					"us", "ca" 地域の単語
	vim/!					誤った単語
	Campbell/?3				地域 3 "gb" での珍しい単語
	's mornings/=				ケースを伴った単語

Note "/=" が使われたとき、すべてが大文字の同じ単語は受理されない。これは自動的
にケースを保ったものとしてマークされた大文字小文字が混ざった単語とは異なる。こ
れらの単語はすべての文字が大文字であるように見えるだろう。


.AFF と .DIC ファイルのフォーマット			*aff-dic-format*

2つのファイルがある: 基本の単語のリストと接辞ファイルだ。接辞ファイルは言語の
設定を指定し、接辞を含むことを可能にする。接辞は十分な単語リストを得るために、
基本単語を修正するのに使われる。このことは特にポーランド語のような言語において
著しく単語の数を減らす。これは接辞圧縮と呼ばれる。

基本の単語リストと接辞ファイルは ":mkspell" コマンドで結び付けられ、その成果は
バイナリのスペルファイルになる。すべての前処理が完了すると、ファイルの読み込み
は高速になる。バイナリのスペルファイルのフォーマットはソースコード
(src/spell.c) に書き込まれている。しかし、このことについて知る必要があるのは開

前処理はまた 私達がMyspell 言語ファイルを取得し、Vim の単語リストが作られる前
に変更することを許す。これらのツールは "src/spell" ディレクトリで見つけること
ができる。

接辞と単語リストファイルのフォーマットは Myspell が使用しているもの (Mozillaと
OpenOffice.org のスペルチェッカー) に基づく。説明書は次の場所で見つけることが
できる。
	http://lingucomponent.openoffice.org/affix.readme ~
Note 接辞は大文字小文字を区別することに注意。これは説明書からははっきりとわか
らない。

Vim は多数の拡張をサポートしている。これらは以下の |spell-affix-vim| で説明さ
れている。他のスペルチェッカーと互換性を保つように作られているので、同じファイ
ルがしばしば使われる。Myspell を超えるもう一つのプロジェクトの1つに　Hunspell
( http://hunspell.sf.net ) がある。


単語リストのフォーマット			*spell-dic-format*

行番号をつけた簡潔な例:

	1	1234 ~
	2	aan ~
	3	Als ~
	4	Etten-Leur ~
	5	et al. ~
	6	's-Gravenhage ~
	7	's-Gravenhaags ~
	8	# 地域間で異なる単語~
	9	kado/1 ~
	10	cadeau/2 ~
	11	TCP,IP ~
	12	/the S affix may add a 's' ~
	13	bedel/S ~

最初の行は単語の数が含まれている。Vim はこれを無視するが、ここにこれがない場合
はエラーメッセージを受け取る。*E760*

これに続くのは、1行につき1つの単語。行末の空白は無視され、その他の空白は問題と
なる。エンコーディングは接辞ファイル内で指定される |spell-SET|。

コメント行は '#' か '/' で始まる。例の8行目と12行目を参照。Note 単語の後ろにコ
メントを書くことは許可されていないことに注意:

		someword   # comment that causes an error! ~

単語の後にはオプションのスラッシュとフラグがある。フラグのほとんどは、その単語
で使用できる接辞を示す文字である。.aff ファイルの SFX や PFX 行で指定されてい
る。|spell-SFX| と |spell-PFX| を参照。Vim では接辞ファイルの FLAG 項目で、ほか
の形式のフラグを使ってもよい |spell-FLAG|。

単語が小文字のみである場合、大文字で始まる単語にもマッチするだろう。

単語が大文字を含んでいる場合、その場所に大文字が必要とされていることを意味する。
その場所が小文字である同じ単語はマッチしないだろう。他の文字が大文字である場合
もマッチしない。

すべてが大文字の単語はいつも OK になるだろう。
The word with all upper-case characters will always be OK,

	単語リスト	マッチする		マッチしない~
	als		als Als ALS		ALs AlS aLs aLS
	Als		Als  ALS		als ALs AlS aLs aLS
	ALS		ALS			als Als ALs AlS aLs aLS
	AlS		AlS ALS			als Als ALs aLs aLS

KEEPCASE の接辞 ID は特定のケースのマッチ指定に使うことができる。下記の
|spell-KEEPCASE| を参照。

Note: 5 から 7 行目は単語ではない文字が使われていることに注意。単語にはどのよ
うな文字でも含めることができる。テキストをチェックする際に、単語の前後に単語で
はない文字が現れたときにのみマッチする。Myspell は単語ではない文字で始まる単語
ではたぶん動作しないだろう。

12 行目に "TCP/IP" が定義されている。スラッシュには特別な意味があるので、代わ
りにコンマが使われる。これは接辞ファイルの SLASH 要素に定義されている。
|spell-SLASH| を参照。Note SLASH 要素なしでは、単語は "TCP,IP" となるだろう。


接辞ファイルフォーマット		*spell-aff-format* *spell-affix-vim*

							*spell-affix-comment*
.aff ファイルのコメント行は '#' で始まる:

	# comment line ~

引数の固定された要素はコメントによって続けることができる。しかし、引数がない場
合に限り空白を含むことができる。コメントは "#" 文字で始まらなければならない。
例:

	KEEPCASE =  # fix case for words with this flag ~


エンコーディング						*spell-SET*

接辞ファイルは "iconv" によってサポートされているエンコーディングであれば、ど
のようなものでもよい。しかしながら、いくつかの場合で現在のロケールはまた、プロ
パティを |:mkspell| が呼び出された時に設定されるべきだ。加えて、 FOL/LOW/UPP
行は |spell-FOL| の要求を削除する。

エンコーディングに関するものの何よりも前にエンコーディングは指定されるべきだ。
エンコーディングは接辞ファイルと辞書ファイルの両方に適用される。これは SET 行
において行われる。

	SET utf-8 ~

エンコーディングは ":mkspell" が使われた時に 'encoding' オプションにセットされ
た値とは異なっていてもよい。Vim はすべてを 'encoding' に変換し、'encoding' に
関係するスペルファイルを生成するだろう。もしも 'encoding' に適合していない文字
が使われているなら、エラーメッセージを受け取るだろう。
							*spell-affix-mbyte*
マルチバイトのエンコーディングが使われている場合、より多くの異なった接辞フラグ
を使うことができる。しかし、Myspell はこれをサポートしないので、これをどのよう
な方法でも使おうとはしないかもしれない。互換性のために 8-bit エンコーディング
を使う。


情報

接辞ファイルのエントリは、スペルファイルに情報を追加するのに使うことができる。
フォーマットに制限はないが、正しいエンコーディングであるべきだ。

				*spell-NAME* *spell-VERSION* *spell-HOME*
				*spell-AUTHOR* *spell-EMAIL* *spell-COPYRIGHT*
	NAME		言語名
	VERSION		1.0.1  with fixes
	HOME		http://www.myhome.eu
	AUTHOR		John Doe
	EMAIL		john AT Doe DOT net
	COPYRIGHT	LGPL

これらのフィールドは .spl ファイルにそのままの状態で置かれる。|:spellinfo| コ
マンドは info を閲覧するために使われる。

							*:spellinfo* *:spelli*
:spelli[nfo]		現在のバッファで使われているスペルファイルの情報を表示
			する。


文字テーブル
							*spell-affix-chars*
8-bit エンコーディングを使う場合、接辞ファイルは、単語の文字が何であるかを定義
するべきだ。これはどうしてかというと、":mkspell" が使われたシステムはこのエン
コーディングのロケールをサポートしていないかもしれないし、 isalpha() が動作し
ないだろうからだ。例えば Unix 上で "cp1250" を使う場合である。
						*E761* *E762* *spell-FOL*
						*spell-LOW* *spell-UPP*
接辞ファイルの3行は必要だ。簡単な例:

	FOL  áëñ ~
	LOW  áëñ ~
	UPP  ÁËÑ ~

3 行すべては全く同じ文字番号を持っていなければいけない。

"FOL" 行は case-folded 文字を指定する。これらは大文字小文字を区別しない単語の
比較に使われる。ほとんどのエンコーディングでは、小文字の行と同じである。

"LOW 行は lower-case 文字を指定する。大部分は "FOL" 行に等しい。

"UPP" 行は upper-case 文字を指定する。これは "FOL" の同じ場所にある文字とは異
なる大文字である。

An exception is made for the German sharp s ß.  The upper-case version is
"SS".  In the FOL/LOW/UPP lines it should be included, so that it's recognized
as a word character, but use the ß character in all three.

ASCII 文字は省略されるべきだ。Vim は常に同じ方法でこれらを扱う。エンコーディン
グが UTF-8 である場合、単語文字の指定は必要ない。

							*E763*
Vim は同じファイルでいくつかの言語のスペルチェックを使うことを許可する。
'spelllang' オプションでこれらを列記できる。結果として、同じエンコーディングに
対するすべてのスペルファイルは同じ単語文字を使用しなければならない。そうでなけ
れば、これらをエラーなしに結合できない。

もし単語テーブルが異なるという警告 E763 を受け取ったのなら、".spl" スペルファ
イルをアップデートする必要がある。ファイルをダウンロードした場合、使用している
すべてのスペルファイルの最新版を取得しよう。もしも1つの言語だけを使っているな
らば、例えばドイツ語、さらに最新の英語スペルファイルをダウンロードしよう。そう
でなければ、再度 |:mkspell| で .spl ファイルを生成しよう。もしエラーを受け取っ
たのであれば、 使用している .aff ファイルの FOL と LOW、UPP 行を確認しよう。

"-ascii" 引数で生成される XX.ascii.spl スペルファイルは文字テーブルを含まない
だろう。そのため、どんなエンコーディングのスペルファイルとも結合することができ
る。加えて .add.spl ファイルはテーブルを含まない。


中間語の文字
							*spell-midword*
いくつかの文字は、普通の単語文字の間で使われているなら、単に単語文字だとみなさ
れる。一例はシングルクォートだ: テキストを引用するのにしばしば使われる。それゆ
えその単語は一語の文字として認識されない。しかし、単語文字の間に現れた場合、単
語の一部にならなければならない。これは they'are のようなスペルミスを検出するた
めに必要だ。they're になるべきだが、"they" と "are" はそれ自身が単語であるので、
気づかれないだろう。

これらの文字は .aff ファイルの MIDWORD で定義される。例:

	MIDWORD	'- ~


フラグタイプ						*spell-FLAG*

Flags are used to specify the affixes that can be used with a word and for
other properties of the word.  Normally single-character flags are used.  This
limits the number of possible flags, especially for 8-bit encodings.  The FLAG
item can be used if more affixes are to be used.  Possible values:

	FLAG long	use two-character flags
	FLAG num	use numbers, from 1 up to 65000
	FLAG caplong	use one-character flags without A-Z and two-character
			flags that start with A-Z

With "FLAG num" the numbers in a list of affixes need to be separated with a
comma: "234,2143,1435".  This method is inefficient, but useful if the file is
generated with a program.

When using "caplong" the two-character flags all start with a capital: "Aa",
"B1", "BB", etc.  This is useful to use one-character flags for the most
common items and two-character flags for uncommon items.

Note: When using utf-8 only characters up to 65000 may be used for flags.

Note: even when using "num" or "long" the number of flags available to
compounding and prefixes is limited to about 250.


AFFIXES
					    *spell-PFX* *spell-SFX*
The usual PFX (prefix) and SFX (suffix) lines are supported (see the Myspell
documentation or the Aspell manual:
http://aspell.net/man-html/Affix-Compression.html).

Summary:
	SFX L Y 2 ~
	SFX L 0 re [^x] ~
	SFX L 0 ro x ~

The first line is a header and has four fields:
	SFX {flag} {combine} {count}

{flag}		The name used for the suffix.  Mostly it's a single letter,
		but other characters can be used, see |spell-FLAG|.

{combine}	Can be 'Y' or 'N'.  When 'Y' then the word plus suffix can
		also have a prefix.  When 'N' then a prefix is not allowed.

{count}		The number of lines following.  If this is wrong you will get
		an error message.

For PFX the fields are exactly the same.

The basic format for the following lines is:
	SFX {flag} {strip} {add} {condition} {extra}

{flag}		Must be the same as the {flag} used in the first line.

{strip}		Characters removed from the basic word.  There is no check if
		the characters are actually there, only the length is used (in
		bytes).  This better match the {condition}, otherwise strange
		things may happen.  If the {strip} length is equal to or
		longer than the basic word the suffix won't be used.
		When {strip} is 0 (zero) then nothing is stripped.

{add}		Characters added to the basic word, after removing {strip}.
		Optionally there is a '/' followed by flags.  The flags apply
		to the word plus affix.  See |spell-affix-flags|

{condition}	A simplistic pattern.  Only when this matches with a basic
		word will the suffix be used for that word.  This is normally
		for using one suffix letter with different {add} and {strip}
		fields for words with different endings.
		When {condition} is a . (dot) there is no condition.
		The pattern may contain:
		- Literal characters.
		- A set of characters in []. [abc] matches a, b and c.
		  A dash is allowed for a range [a-c], but this is
		  Vim-specific.
		- A set of characters that starts with a ^, meaning the
		  complement of the specified characters. [^abc] matches any
		  character but a, b and c.

{extra}		Optional extra text:
		    # comment		Comment is ignored
		    -			Hunspell uses this, ignored

For PFX the fields are the same, but the {strip}, {add} and {condition} apply
to the start of the word.

Note: Myspell ignores any extra text after the relevant info.  Vim requires
this text to start with a "#" so that mistakes don't go unnoticed.  Example:

	SFX F 0 in   [^i]n      # Spion > Spionin  ~
	SFX F 0 nen  in		# Bauerin > Bauerinnen ~

However, to avoid lots of errors in affix files written for Myspell, you can
add the IGNOREEXTRA flag.

Apparently Myspell allows an affix name to appear more than once.  Since this
might also be a mistake, Vim checks for an extra "S".  The affix files for
Myspell that use this feature apparently have this flag.  Example:

	SFX a Y 1 S ~
	SFX a 0 an . ~

	SFX a Y 2 S ~
	SFX a 0 en . ~
	SFX a 0 on . ~


AFFIX FLAGS						*spell-affix-flags*

This is a feature that comes from Hunspell: The affix may specify flags.  This
works similar to flags specified on a basic word.  The flags apply to the
basic word plus the affix (but there are restrictions).  Example:

	SFX S Y 1 ~
	SFX S 0 s . ~

	SFX A Y 1 ~
	SFX A 0 able/S . ~

When the dictionary file contains "drink/AS" then these words are possible:

	drink
	drinks		uses S suffix
	drinkable	uses A suffix
	drinkables	uses A suffix and then S suffix

Generally the flags of the suffix are added to the flags of the basic word,
both are used for the word plus suffix.  But the flags of the basic word are
only used once for affixes, except that both one prefix and one suffix can be
used when both support combining.

Specifically, the affix flags can be used for:
- Suffixes on suffixes, as in the example above.  This works once, thus you
  can have two suffixes on a word (plus one prefix).
- Making the word with the affix rare, by using the |spell-RARE| flag.
- Exclude the word with the affix from compounding, by using the
  |spell-COMPOUNDFORBIDFLAG| flag.
- Allow the word with the affix to be part of a compound word on the side of
  the affix with the |spell-COMPOUNDPERMITFLAG|.
- Use the NEEDCOMPOUND flag: word plus affix can only be used as part of a
  compound word. |spell-NEEDCOMPOUND|
- Compound flags: word plus affix can be part of a compound word at the end,
  middle, start, etc.  The flags are combined with the flags of the basic
  word.  |spell-compound|
- NEEDAFFIX: another affix is needed to make a valid word.
- CIRCUMFIX, as explained just below.


IGNOREEXTRA						*spell-IGNOREEXTRA*

Normally Vim gives an error for an extra field that does not start with '#'.
This avoids errors going unnoticed.  However, some files created for Myspell
or Hunspell may contain many entries with an extra field.  Use the IGNOREEXTRA
flag to avoid lots of errors.


CIRCUMFIX						*spell-CIRCUMFIX*

The CIRCUMFIX flag means a prefix and suffix must be added at the same time.
If a prefix has the CIRCUMFIX flag than only suffixes with the CIRCUMFIX flag
can be added, and the other way around.
An alternative is to only specify the suffix, and give the that suffix two
flags: The required prefix and the NEEDAFFIX flag.  |spell-NEEDAFFIX|


PFXPOSTPONE						*spell-PFXPOSTPONE*

When an affix file has very many prefixes that apply to many words it's not
possible to build the whole word list in memory.  This applies to Hebrew (a
list with all words is over a Gbyte).  In that case applying prefixes must be
postponed.  This makes spell checking slower.  It is indicated by this keyword
in the .aff file:

	PFXPOSTPONE ~

Only prefixes without a chop string and without flags can be postponed.
Prefixes with a chop string or with flags will still be included in the word
list.  An exception if the chop string is one character and equal to the last
character of the added string, but in lower case.  Thus when the chop string
is used to allow the following word to start with an upper case letter.


WORDS WITH A SLASH					*spell-SLASH*

The slash is used in the .dic file to separate the basic word from the affix
letters and other flags.  Unfortunately, this means you cannot use a slash in
a word.  Thus "TCP/IP" is not a word but "TCP" with the flags "IP".  To include
a slash in the word put a backslash before it: "TCP\/IP".  In the rare case
you want to use a backslash inside a word you need to use two backslashes.
Any other use of the backslash is reserved for future expansion.


KEEP-CASE WORDS						*spell-KEEPCASE*

In the affix file a KEEPCASE line can be used to define the affix name used
for keep-case words.  Example:

	KEEPCASE = ~

This flag is not supported by Myspell.  It has the meaning that case matters.
This can be used if the word does not have the first letter in upper case at
the start of a sentence.  Example:

    word list	    matches		    does not match ~
    's morgens/=    's morgens		    'S morgens 's Morgens 'S MORGENS
    's Morgens	    's Morgens 'S MORGENS   'S morgens 's morgens

The flag can also be used to avoid that the word matches when it is in all
upper-case letters.


RARE WORDS						*spell-RARE*

In the affix file a RARE line can be used to define the affix name used for
rare words.  Example:

	RARE ? ~

Rare words are highlighted differently from bad words.  This is to be used for
words that are correct for the language, but are hardly ever used and could be
a typing mistake anyway.  When the same word is found as good it won't be
highlighted as rare.

This flag can also be used on an affix, so that a basic word is not rare but
the basic word plus affix is rare |spell-affix-flags|.  However, if the word
also appears as a good word in another way (e.g., in another region) it won't
be marked as rare.


BAD WORDS						*spell-BAD*

In the affix file a BAD line can be used to define the affix name used for
bad words.  Example:

	BAD ! ~

This can be used to exclude words that would otherwise be good.  For example
"the the" in the .dic file:

	the the/! ~

Once a word has been marked as bad it won't be undone by encountering the same
word as good.

The flag also applies to the word with affixes, thus this can be used to mark
a whole bunch of related words as bad.

							*spell-FORBIDDENWORD*
FORBIDDENWORD can be used just like BAD.  For compatibility with Hunspell.

							*spell-NEEDAFFIX*
The NEEDAFFIX flag is used to require that a word is used with an affix.  The
word itself is not a good word (unless there is an empty affix).  Example:

	NEEDAFFIX + ~


COMPOUND WORDS						*spell-compound*

A compound word is a longer word made by concatenating words that appear in
the .dic file.  To specify which words may be concatenated a character is
used.  This character is put in the list of affixes after the word.  We will
call this character a flag here.  Obviously these flags must be different from
any affix IDs used.

							*spell-COMPOUNDFLAG*
The Myspell compatible method uses one flag, specified with COMPOUNDFLAG.  All
words with this flag combine in any order.  This means there is no control
over which word comes first.  Example:
	COMPOUNDFLAG c ~

							*spell-COMPOUNDRULE*
A more advanced method to specify how compound words can be formed uses
multiple items with multiple flags.  This is not compatible with Myspell 3.0.
Let's start with an example:
	COMPOUNDRULE c+ ~
	COMPOUNDRULE se ~

The first line defines that words with the "c" flag can be concatenated in any
order.  The second line defines compound words that are made of one word with
the "s" flag and one word with the "e" flag.  With this dictionary:
	bork/c ~
	onion/s ~
	soup/e ~

You can make these words:
	bork
	borkbork
	borkborkbork
	(etc.)
	onion
	soup
	onionsoup

The COMPOUNDRULE item may appear multiple times.  The argument is made out of
one or more groups, where each group can be:
	one flag			e.g., c
	alternate flags inside []	e.g., [abc]
Optionally this may be followed by:
	*	the group appears zero or more times, e.g., sm*e
	+	the group appears one or more times, e.g., c+
	?	the group appears zero times or once, e.g., x?

This is similar to the regexp pattern syntax (but not the same!).  A few
examples with the sequence of word flags they require:
    COMPOUNDRULE x+	    x xx xxx etc.
    COMPOUNDRULE yz	    yz
    COMPOUNDRULE x+z	    xz xxz xxxz etc.
    COMPOUNDRULE yx+	    yx yxx yxxx etc.
    COMPOUNDRULE xy?z	    xz xyz

    COMPOUNDRULE [abc]z    az bz cz
    COMPOUNDRULE [abc]+z   az aaz abaz bz baz bcbz cz caz cbaz etc.
    COMPOUNDRULE a[xyz]+   ax axx axyz ay ayx ayzz az azy azxy etc.
    COMPOUNDRULE sm*e	    se sme smme smmme etc.
    COMPOUNDRULE s[xyz]*e  se sxe sxye sxyxe sye syze sze szye szyxe  etc.

A specific example: Allow a compound to be made of two words and a dash:
	In the .aff file:
	    COMPOUNDRULE sde ~
	    NEEDAFFIX x ~
	    COMPOUNDWORDMAX 3 ~
	    COMPOUNDMIN 1 ~
	In the .dic file:
	    start/s ~
	    end/e ~
	    -/xd ~

This allows for the word "start-end", but not "startend".

An additional implied rule is that, without further flags, a word with a
prefix cannot be compounded after another word, and a word with a suffix
cannot be compounded with a following word.  Thus the affix cannot appear
on the inside of a compound word.  This can be changed with the
|spell-COMPOUNDPERMITFLAG|.

							*spell-NEEDCOMPOUND*
The NEEDCOMPOUND flag is used to require that a word is used as part of a
compound word.  The word itself is not a good word.  Example:

	NEEDCOMPOUND & ~

							*spell-ONLYINCOMPOUND*
The ONLYINCOMPOUND does exactly the same as NEEDCOMPOUND.  Supported for
compatibility with Hunspell.

							*spell-COMPOUNDMIN*
The minimal character length of a word used for compounding is specified with
COMPOUNDMIN.  Example:
	COMPOUNDMIN 5 ~

When omitted there is no minimal length.  Obviously you could just leave out
the compound flag from short words instead, this feature is present for
compatibility with Myspell.

							*spell-COMPOUNDWORDMAX*
The maximum number of words that can be concatenated into a compound word is
specified with COMPOUNDWORDMAX.  Example:
	COMPOUNDWORDMAX 3 ~

When omitted there is no maximum.  It applies to all compound words.

To set a limit for words with specific flags make sure the items in
COMPOUNDRULE where they appear don't allow too many words.

							*spell-COMPOUNDSYLMAX*
The maximum number of syllables that a compound word may contain is specified
with COMPOUNDSYLMAX.  Example:
	COMPOUNDSYLMAX 6 ~

This has no effect if there is no SYLLABLE item.  Without COMPOUNDSYLMAX there
is no limit on the number of syllables.

If both COMPOUNDWORDMAX and COMPOUNDSYLMAX are defined, a compound word is
accepted if it fits one of the criteria, thus is either made from up to
COMPOUNDWORDMAX words or contains up to COMPOUNDSYLMAX syllables.

						    *spell-COMPOUNDFORBIDFLAG*
The COMPOUNDFORBIDFLAG specifies a flag that can be used on an affix.  It
means that the word plus affix cannot be used in a compound word.  Example:
	affix file:
		COMPOUNDFLAG c ~
		COMPOUNDFORBIDFLAG x ~
		SFX a Y 2 ~
		SFX a 0 s   . ~
		SFX a 0 ize/x . ~
	dictionary:
		word/c ~
		util/ac ~

This allows for "wordutil" and "wordutils" but not "wordutilize".
Note: this doesn't work for postponed prefixes yet.

						    *spell-COMPOUNDPERMITFLAG*
The COMPOUNDPERMITFLAG specifies a flag that can be used on an affix.  It
means that the word plus affix can also be used in a compound word in a way
where the affix ends up halfway the word.  Without this flag that is not
allowed.
Note: this doesn't work for postponed prefixes yet.

						    *spell-COMPOUNDROOT*
The COMPOUNDROOT flag is used for words in the dictionary that are already a
compound.  This means it counts for two words when checking the compounding
rules.  Can also be used for an affix to count the affix as a compounding
word.

						*spell-CHECKCOMPOUNDPATTERN*
CHECKCOMPOUNDPATTERN is used to define patterns that, when matching at the
position where two words are compounded together forbids the compound.
For example:
	CHECKCOMPOUNDPATTERN o e ~

This forbids compounding if the first word ends in "o" and the second word
starts with "e".

The arguments must be plain text, no patterns are actually supported, despite
the item name.  Case is always ignored.

The Hunspell feature to use three arguments and flags is not supported.

							*spell-NOCOMPOUNDSUGS*
This item indicates that using compounding to make suggestions is not a good
idea.  Use this when compounding is used with very short or one-character
words.  E.g. to make numbers out of digits.  Without this flag creating
suggestions would spend most time trying all kind of weird compound words.

	NOCOMPOUNDSUGS ~

							*spell-SYLLABLE*
The SYLLABLE item defines characters or character sequences that are used to
count the number of syllables in a word.  Example:
	SYLLABLE aáeéiíoóöõuúüûy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui ~

Before the first slash is the set of characters that are counted for one
syllable, also when repeated and mixed, until the next character that is not
in this set.  After the slash come sequences of characters that are counted
for one syllable.  These are preferred over using characters from the set.
With the example "ideeen" has three syllables, counted by "i", "ee" and "e".

Only case-folded letters need to be included.

Another way to restrict compounding was mentioned above: Adding the
|spell-COMPOUNDFORBIDFLAG| flag to an affix causes all words that are made
with that affix to not be used for compounding.


UNLIMITED COMPOUNDING					*spell-NOBREAK*

For some languages, such as Thai, there is no space in between words.  This
looks like all words are compounded.  To specify this use the NOBREAK item in
the affix file, without arguments:
	NOBREAK ~

Vim will try to figure out where one word ends and a next starts.  When there
are spelling mistakes this may not be quite right.


							*spell-COMMON*
Common words can be specified with the COMMON item.  This will give better
suggestions when editing a short file.  Example:

	COMMON  the of to and a in is it you that he was for on are ~

The words must be separated by white space, up to 25 per line.
When multiple regions are specified in a ":mkspell" command the common words
for all regions are combined and used for all regions.

							*spell-NOSPLITSUGS*
This item indicates that splitting a word to make suggestions is not a good
idea.  Split-word suggestions will appear only when there are few similar
words.

	NOSPLITSUGS ~

							*spell-NOSUGGEST*
The flag specified with NOSUGGEST can be used for words that will not be
suggested.  Can be used for obscene words.

	NOSUGGEST % ~


REPLACEMENTS						*spell-REP*

In the affix file REP items can be used to define common mistakes.  This is
used to make spelling suggestions.  The items define the "from" text and the
"to" replacement.  Example:

	REP 4 ~
	REP f ph ~
	REP ph f ~
	REP k ch ~
	REP ch k ~

The first line specifies the number of REP lines following.  Vim ignores the
number, but it must be there (for compatibility with Myspell).

Don't include simple one-character replacements or swaps.  Vim will try these
anyway.  You can include whole words if you want to, but you might want to use
the "file:" item in 'spellsuggest' instead.

You can include a space by using an underscore:

	REP the_the the ~


SIMILAR CHARACTERS					*spell-MAP* *E783*

In the affix file MAP items can be used to define letters that are very much
alike.  This is mostly used for a letter with different accents.  This is used
to prefer suggestions with these letters substituted.  Example:

	MAP 2 ~
	MAP eéëêè ~
	MAP uüùúû ~

The first line specifies the number of MAP lines following.  Vim ignores the
number, but the line must be there.

Each letter must appear in only one of the MAP items.  It's a bit more
efficient if the first letter is ASCII or at least one without accents.


.SUG FILE						*spell-NOSUGFILE*

When soundfolding is specified in the affix file then ":mkspell" will normally
produce a .sug file next to the .spl file.  This file is used to find
suggestions by their sound-a-like form quickly.  At the cost of a lot of
memory (the amount depends on the number of words, |:mkspell| will display an
estimate when it's done).

To avoid producing a .sug file use this item in the affix file:

	NOSUGFILE ~

Users can simply omit the .sug file if they don't want to use it.


SOUND-A-LIKE						*spell-SAL*

In the affix file SAL items can be used to define the sounds-a-like mechanism
to be used.  The main items define the "from" text and the "to" replacement.
Simplistic example:

	SAL CIA			 X ~
	SAL CH			 X ~
	SAL C			 K ~
	SAL K			 K ~

There are a few rules and this can become quite complicated.  An explanation
how it works can be found in the Aspell manual:
http://aspell.net/man-html/Phonetic-Code.html.

There are a few special items:

	SAL followup		true ~
	SAL collapse_result	true ~
	SAL remove_accents	true ~

"1" has the same meaning as "true".  Any other value means "false".


SIMPLE SOUNDFOLDING				*spell-SOFOFROM* *spell-SOFOTO*

The SAL mechanism is complex and slow.  A simpler mechanism is mapping all
characters to another character, mapping similar sounding characters to the
same character.  At the same time this does case folding.  You can not have
both SAL items and simple soundfolding.

There are two items required: one to specify the characters that are mapped
and one that specifies the characters they are mapped to.  They must have
exactly the same number of characters.  Example:

    SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ~
    SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkes ~

In the example all vowels are mapped to the same character 'e'.  Another
method would be to leave out all vowels.  Some characters that sound nearly
the same and are often mixed up, such as 'm' and 'n', are mapped to the same
character.  Don't do this too much, all words will start looking alike.

Characters that do not appear in SOFOFROM will be left out, except that all
white space is replaced by one space.  Sequences of the same character in
SOFOFROM are replaced by one.

You can use the |soundfold()| function to try out the results.  Or set the
'verbose' option to see the score in the output of the |z=| command.


UNSUPPORTED ITEMS				*spell-affix-not-supported*

These items appear in the affix file of other spell checkers.  In Vim they are
ignored, not supported or defined in another way.

ACCENT		(Hunspell)				*spell-ACCENT*
		Use MAP instead. |spell-MAP|

BREAK		(Hunspell)				*spell-BREAK*
		Define break points.  Unclear how it works exactly.
		Not supported.

CHECKCOMPOUNDCASE  (Hunspell)			*spell-CHECKCOMPOUNDCASE*
		Disallow uppercase letters at compound word boundaries.
		Not supported.

CHECKCOMPOUNDDUP  (Hunspell)			*spell-CHECKCOMPOUNDDUP*
		Disallow using the same word twice in a compound.  Not
		supported.

CHECKCOMPOUNDREP  (Hunspell)			*spell-CHECKCOMPOUNDREP*
		Something about using REP items and compound words.  Not
		supported.

CHECKCOMPOUNDTRIPLE  (Hunspell)			*spell-CHECKCOMPOUNDTRIPLE*
		Forbid three identical characters when compounding.  Not
		supported.

COMPLEXPREFIXES  (Hunspell)				*spell-COMPLEXPREFIXES*
		Enables using two prefixes.  Not supported.

COMPOUND	(Hunspell)				*spell-COMPOUND*
		This is one line with the count of COMPOUND items, followed by
		that many COMPOUND lines with a pattern.
		Remove the first line with the count and rename the other
		items to COMPOUNDRULE |spell-COMPOUNDRULE|

COMPOUNDFIRST	(Hunspell)				*spell-COMPOUNDFIRST*
		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|

COMPOUNDBEGIN	(Hunspell)				*spell-COMPOUNDBEGIN*
		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|

COMPOUNDEND	(Hunspell)				*spell-COMPOUNDEND*
		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|

COMPOUNDMIDDLE	(Hunspell)				*spell-COMPOUNDMIDDLE*
		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|

COMPOUNDRULES	(Hunspell)				*spell-COMPOUNDRULES*
		Number of COMPOUNDRULE lines following.  Ignored, but the
		argument must be a number.

COMPOUNDSYLLABLE  (Hunspell)			*spell-COMPOUNDSYLLABLE*
		Use SYLLABLE and COMPOUNDSYLMAX instead. |spell-SYLLABLE|
		|spell-COMPOUNDSYLMAX|

KEY		(Hunspell)				*spell-KEY*
		Define characters that are close together on the keyboard.
		Used to give better suggestions.  Not supported.

LANG		(Hunspell)				*spell-LANG*
		This specifies language-specific behavior.  This actually
		moves part of the language knowledge into the program,
		therefore Vim does not support it.  Each language property
		must be specified separately.

LEMMA_PRESENT	(Hunspell)				*spell-LEMMA_PRESENT*
		Only needed for morphological analysis.

MAXNGRAMSUGS	(Hunspell)				*spell-MAXNGRAMSUGS*
		Set number of n-gram suggestions.  Not supported.

PSEUDOROOT	(Hunspell)				*spell-PSEUDOROOT*
		Use NEEDAFFIX instead. |spell-NEEDAFFIX|

SUGSWITHDOTS	(Hunspell)				*spell-SUGSWITHDOTS*
		Adds dots to suggestions.  Vim doesn't need this.

SYLLABLENUM	(Hunspell)				*spell-SYLLABLENUM*
		Not supported.

TRY		(Myspell, Hunspell, others)		*spell-TRY*
		Vim does not use the TRY item, it is ignored.  For making
		suggestions the actual characters in the words are used, that
		is much more efficient.

WORDCHARS	(Hunspell)				*spell-WORDCHARS*
		Used to recognize words.  Vim doesn't need it, because there
		is no need to separate words before checking them (using a
		trie instead of a hashtable).

 vim:tw=78:sw=4:ts=8:noet:ft=help:norl:
